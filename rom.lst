                ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                ;~~  [MyCA] Macro Cross Assembler V1.10 for MyCPU, (c) 2023 by Dennis Kuschel  ~~
                ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                ;[File: my4th-rom_8MHz.asm]
                ;=============================================================================;
                ;  MY4TH Operating System: A very small FORTH system with discrete logic CPU  ;
                ;  (c) in 2022 by Dennis Kuschel, dennis_k@freenet.de                         ;
                ;  This work is puplished under the Creative Commons "CC BY-SA 4.0" license.  ;
                ;=============================================================================;
                
                ;[File: /home/dennis/.bin/myca/include/my4th/my4th.hsm]
                ;------------------------------------------------------------------------------
                ;  My4TH Common Definitions
                ;------------------------------------------------------------------------------
                ;  Version History:
                ;    2022-09-30 : Initial version by DK
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ; Common Settings for My4TH Computer
                ;------------------------------------------------------------------------------
                
                .target my4th
                .mode ascii
                
                ;------------------------------------------------------------------------------
                ; OP-Codes
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ; Registers
                ;------------------------------------------------------------------------------
                
                ; Micocode defined registers:
                TEMP1     SET  0x00  ; temporary register 1, used by microcode
                TEMP2     SET  0x01  ; temporary register 2, used by microcode
                TEMP3     SET  0x02  ; temporary register 3, used by microcode
                TEMP4     SET  0x03  ; temporary register 4, used by microcode
                TEMP5     SET  0x04  ; temporary register 5, used by microcode
                PAR1      SET  0x05  ; free to use by user program
                PAR2      SET  0x06  ; free to use by user program
                SP        SET  0x07  ; Stack Pointer
                PC_L      SET  0x08  ; Program Counter, low
                PC_H      SET  0x09  ; Program Counter, high
                LR_L      SET  0x0A  ; Link Register, low
                LR_H      SET  0x0B  ; Link Register, high
                PTR_L     SET  0x0C  ; Memory Pointer Register, low
                PTR_H     SET  0x0D  ; Memory Pointer Register, high
                ACCU      SET  0x0E  ; Accumulator
                FLAG      SET  0x0F  ; Flag Register for zero- and carry-flag
                
                ; MyCA defined registers (the user may change this):
                R0        SET  0x10  ; Register 0, 8-bit label
                R1        SET  0x11  ; Register 1, 8-bit label
                R2        SET  0x12  ; Register 2, 8-bit label
                R3        SET  0x13  ; Register 3, 8-bit label
                R4        SET  0x14  ; Register 4, 8-bit label
                R4_L      SET  0x14  ; Register 4, 8-bit label for low-byte
                R4_H      SET  0x15  ; Register 4, 8-bit label for high-byte
                R5        SET  0x16  ; Register 5, 8/16-bit label
                R5_L      SET  0x16  ; Register 5, 8-bit label for low-byte
                R5_H      SET  0x17  ; Register 5, 8-bit label for high-byte
                R6        SET  0x18  ; Register 6, 8/16-bit label
                R6_L      SET  0x18  ; Register 6, 8-bit label for low-byte
                R6_H      SET  0x19  ; Register 6, 8-bit label for high-byte
                R7        SET  0x1A  ; Register 7, 8/16-bit label
                R7_L      SET  0x1A  ; Register 7, 8-bit label for low-byte
                R7_H      SET  0x1B  ; Register 7, 8-bit label for high-byte
                OUTP      SET  0x1C  ; Mirror value of Output Port
                
                ;------------------------------------------------------------------------------
                ; Segments
                ;------------------------------------------------------------------------------
                
                
                ; The zero-page goes from 00h-FFh (that is 8000h-80FFh in RAM)
                ; Note that the range 00h-1Fh is reserved for CPU functions
                ZEROPAGE SET 8000h
                _zeropage Segment Data
                ORG 20h
                _zeropage_end Segment Data
                ORG 100h
                ; Registers are located in the zeropage
                REGPAGE     SET ZEROPAGE
                REGPAGE_HI  SET REGPAGE/256
                
                ;pointer to free zero-page space for binary modules
                ZP_FREE_MEM_START  SET 0xE0   ;0xE0-0xFF = 32 bytes free to use
                _zpbinmod Segment Data
                ORG ZP_FREE_MEM_START
                
                ; Stack is between 8100h-81FFh
                STACK SET 8100h
                _stack    Segment Data
                ORG STACK
                
                ; free RAM for data and code starts at 8200h
                RAM SET 8200h
                _ram      Segment Data
                ORG RAM
                
                ; switch to code segment
                _program  Segment Code
                code_segment
                
                ;[File: my4th-rom_8MHz.asm]
                
                
                ;------------------------------------------------------------------------------
                ; Includes and Macros
                ;------------------------------------------------------------------------------
                
                ;[File: version.hsm]
                
                
                ;[File: my4th-rom_8MHz.asm]
                ;[File: tables.asm]
                ;------------------------------------------------------------------------------
                ; Lots of tables
                ;------------------------------------------------------------------------------
                
                ;[File: keydefs.hsm]
                
                
                ; General key code definitions
                
                KCODE_BS      SET 0x08  ;back space
                KCODE_DEL     SET 0x7F
                KCODE_PGUP    SET 0x0E
                KCODE_PGDOWN  SET 0x0F
                KCODE_F1      SET 0x10
                KCODE_F2      SET 0x11
                KCODE_F3      SET 0x12
                KCODE_F4      SET 0x13
                KCODE_F5      SET 0x14
                KCODE_F6      SET 0x15
                KCODE_F7      SET 0x16
                KCODE_F8      SET 0x17
                KCODE_INSERT  SET 0x18
                KCODE_HOME    SET 0x19
                KCODE_END     SET 0x1A
                KCODE_UP      SET 0x1C
                KCODE_DOWN    SET 0x1D
                KCODE_RIGHT   SET 0x1E
                KCODE_LEFT    SET 0x1F
                
                ;------------------------------------------------------------------------------
                ; Define Keycodes for the 6x4 Keypad on the LCD-Display-Board
                ;------------------------------------------------------------------------------
                
                KC_NONE    SET 0x00
                
                KC_0       SET 0x30
                KC_1       SET 0x31
                KC_2       SET 0x32
                KC_3       SET 0x33
                KC_4       SET 0x34
                KC_5       SET 0x35
                KC_6       SET 0x36
                KC_7       SET 0x37
                KC_8       SET 0x38
                KC_9       SET 0x39
                KC_A       SET 0x41
                KC_B       SET 0x42
                KC_C       SET 0x43
                KC_D       SET 0x44
                KC_E       SET 0x45
                KC_F       SET 0x46
                KC_MUL     SET 0x2A
                KC_DIV     SET 0x2F
                KC_PLUS    SET 0x2B
                KC_MINUS   SET 0x2D
                KC_DOT     SET 0x2E
                KC_RESULT  SET 0x3D
                KC_BACK    SET 0x08
                KC_CE      SET 0x03
                
                ;Keypad layout:
                ;---;---+---+---+---;---;
                ; 7 ; 8 | 9 | D | E ; F ;
                ;---;---+---+---+---;---;
                ; 4 ; 5 | 6 | A | B ; C ;
                ;---;---+---+---+---;---;
                ; 1 ; 2 | 3 | * | / ;BAK;
                ;---;---+---+---+---;---;
                ; 0 ; . | = | + | - ;CE ;
                ;---;---+---+---+---;---;
                
                ;Key numbers:
                ;---;---+---+---+---;---;
                ;$05;$04|$03|$02|$01;$00;
                ;---;---+---+---+---;---;
                ;$0D;$0C|$0B|$0A|$09;$08;
                ;---;---+---+---+---;---;
                ;$15;$14|$13|$12|$11;$10;
                ;---;---+---+---+---;---;
                ;$1D;$1C|$1B|$1A|$19;$18;
                ;---;---+---+---+---;---;
                
                ;[File: tables.asm]
                
                aligned_tables Segment Code
                
                ORG 7AE0h  ;Lower 5 bits must be zero
                tab_vt100keys:
    7AE0 001C1D     DB  0,KCODE_UP,KCODE_DOWN,KCODE_RIGHT,KCODE_LEFT,0x82,KCODE_END,0
    7AE3 1E1F82 
    7AE6 1A00   
    7AE8 190000     DB  KCODE_HOME,0,0,0,0,0,0,0
    7AEB 000000 
    7AEE 0000   
    7AF0 131011     DB  KCODE_F4,KCODE_F1,KCODE_F2,KCODE_F3,KCODE_F4,KCODE_F5,KCODE_F5,KCODE_F6,KCODE_F7  ; geht mit putty
    7AF3 121314 
    7AF6 141516 
    7AF9 17187F     DB  KCODE_F8,KCODE_INSERT,KCODE_DEL,KCODE_END,KCODE_PGUP,KCODE_PGDOWN,0
    7AFC 1A0E0F 
    7AFF 00     
                
                ORG 7B00h
                
                ;Table for machine-code relocation (it decodes the length of OP-codes)
                tab_opcode:
    7B00 018303     DB  0x01,0x83,0x03,0x02,0x02,0x01,0x02,0x01  ; RST / LD# / LD  / LDA#/ LDA / LAP / STA / SAP
    7B03 020201 
    7B06 0201   
    7B08 000202     DB  0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02  ; rsv / INC / DEC / ROL / ROR / AND / OR  / XOR
    7B0B 020202 
    7B0E 0202   
    7B10 020200     DB  0x02,0x02,0x00,0x02,0x02,0x02,0x83,0x83  ; ADD / SUB / rsv / CMP#/ CMP / TST / JPF / JNF
    7B13 020202 
    7B16 8383   
    7B18 838301     DB  0x83,0x83,0x01,0x02,0x02,0x01,0x01,0x01  ; JMP / JSR / RET / PSH / POP / IN  / PHL / RTS
    7B1B 020201 
    7B1E 0101   
    7B20 830201     DB  0x83,0x02,0x01,0x01,0x02,0x02,0x01,0x00  ; JPL / RWL / SEC / CLC / AD  / SU  / OUT / rsv
    7B23 010202 
    7B26 0100   
                
                ;Table with supported environment strings
                tab_envstrings:
    7B28 142F43     DB  20,"/COUNTED-STRING",0,1
    7B2B 4F554E 
    7B2E 544544 
    7B31 2D5354 
    7B34 52494E 
    7B37 470001 
    7B3A FF00       DW  255
    7B3C 0A2F48     DB  10,"/HOLD",0,1
    7B3F 4F4C44 
    7B42 0001   
    7B44 7000       DW  NUMBUF_SZ
    7B46 092F50     DB  9,"/PAD",0,1
    7B49 414400 
    7B4C 01     
    7B4D 6000       DW  PAD_SIZE
    7B4F 164144     DB  22,"ADDRESS-UNIT-BITS",0,1
    7B52 445245 
    7B55 53532D 
    7B58 554E49 
    7B5B 542D42 
    7B5E 495453 
    7B61 0001   
    7B63 1000       DW  16
    7B65 0C464C     DB  12,"FLOORED",0,1
    7B68 4F4F52 
    7B6B 454400 
    7B6E 01     
    7B6F 0000       DW  0
    7B71 0D4D41     DB  13,"MAX-CHAR",0,1
    7B74 582D43 
    7B77 484152 
    7B7A 0001   
    7B7C FF00       DW  255
    7B7E 0C4D41     DB  12,"MAX-D",0,2
    7B81 582D44 
    7B84 0002   
    7B86 FFFFFF     DW  0xFFFF,0x7FFF   ; push 0xFFFF first to stack, than push 0x7FFF
    7B89 7F     
    7B8A 0A4D41     DB  10,"MAX-N",0,1
    7B8D 582D4E 
    7B90 0001   
    7B92 FF7F       DW  0x7FFF
    7B94 0A4D41     DB  10,"MAX-U",0,1
    7B97 582D55 
    7B9A 0001   
    7B9C FFFF       DW  0xFFFF
    7B9E 0D4D41     DB  13,"MAX-UD",0,2
    7BA1 582D55 
    7BA4 440002 
    7BA7 FFFFFF     DW  0xFFFF,0xFFFF
    7BAA FF     
    7BAB 175245     DB  23,"RETURN-STACK-CELLS",0,1
    7BAE 545552 
    7BB1 4E2D53 
    7BB4 544143 
    7BB7 4B2D43 
    7BBA 454C4C 
    7BBD 530001 
    7BC0 3200       DW  50
    7BC2 105354     DB  16,"STACK-CELLS",0,1
    7BC5 41434B 
    7BC8 2D4345 
    7BCB 4C4C53 
    7BCE 0001   
    7BD0 8000       DW  128
    7BD2 00         DB  0
                
                ORG 7BE0h  ;Lower 5 bits must be zero (table for S\" word (formatted string))
                tab_formatstr
    7BE0 000708     DB 0,7,8,'c','d',27,12,'g','h','i','j','k',10,'n','n','o','p',
    7BE3 63641B 
    7BE6 0C6768 
    7BE9 696A6B 
    7BEC 0A6E6E 
    7BEF 6F70   
    7BF1 220D73     DB 34,13,'s',9,'u',11,'w','x','y',0,0,0,0,0,0
    7BF4 09750B 
    7BF7 777879 
    7BFA 000000 
    7BFD 000000 
                
                ORG 7C00h
                
                ;Table for converting characters to lower case (aligned to address 7C00h, the lower 8 bits are zero):
                tab_lowerCase:
                tab_dict: ;this table sits inside the "lower case" table and is used to find the correct dictionary pointer
    7C00 66686A     DB  DICTA+0,DICTA+2,DICTA+4,DICTA+6,DICTA+8,DICTA+10,DICTA+12,DICTA+14
    7C03 6C6E70 
    7C06 7274   
    7C08 000000     DB  0,0,0,0,0,0,0,0
    7C0B 000000 
    7C0E 0000   
    7C10 000000     DB  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    7C13 000000 
    7C16 000000 
    7C19 000000 
    7C1C 000000 
    7C1F 00     
    7C20 202122     DB  0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F
    7C23 232425 
    7C26 262728 
    7C29 292A2B 
    7C2C 2C2D2E 
    7C2F 2F     
    7C30 303132     DB  0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F
    7C33 333435 
    7C36 363738 
    7C39 393A3B 
    7C3C 3C3D3E 
    7C3F 3F     
    7C40 406162     DB  0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F
    7C43 636465 
    7C46 666768 
    7C49 696A6B 
    7C4C 6C6D6E 
    7C4F 6F     
    7C50 707172     DB  0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x5B,0x5C,0x5D,0x5E,0x5F
    7C53 737475 
    7C56 767778 
    7C59 797A5B 
    7C5C 5C5D5E 
    7C5F 5F     
    7C60 606162     DB  0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F
    7C63 636465 
    7C66 666768 
    7C69 696A6B 
    7C6C 6C6D6E 
    7C6F 6F     
    7C70 707172     DB  0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F
    7C73 737475 
    7C76 767778 
    7C79 797A7B 
    7C7C 7C7D7E 
    7C7F 7F     
                
                tab_fthVarInit:
    7C80 3084       DW  HEAP_START   ; CP
    7C82 517403     DW  dictionary_8, dictionary_1, dictionary_2, dictionary_3  ; DICTA+0 - DICTA+7
    7C85 507052 
    7C88 8F59   
    7C8A E45CBE     DW  dictionary_4, dictionary_5, dictionary_6, dictionary_7  ; DICTA+8 - DICTA+15
    7C8D 69646F 
    7C90 3573   
    7C92 00FD       DW  USER_MEMORY  ; UP
    7C94 0000FF     DB  0,0,0xFF,0xFF,0  ; BLKSTRUCT
    7C97 FF00   
    7C99 190000     DB  0x19, 0, 0, 0x18, <return, >return      ; JSRSPACE
    7C9C 18CA3A 
    7C9F 190000     DB  0x19, 0, 0, 0x18, <itp_loop, >itp_loop  ; IPRSPACE
    7CA2 18CC48 
    7CA5 0A00       DW  10  ; BASE
    7CA7 00         DB  0   ; EEP_STATE
    7CA8 00         DB  0   ; NEXTINCHR
    7CA9 0000       DW  0   ; BLK
    7CAB 0000       DW  0   ; SCR
    7CAD 00         DB  INDEV_LOCAL  ; INPUTDEV
    7CAE 00         DB  0   ; REFILL
                
                ORG 7CC0h
                
                ;Table for conversion from binary to hex or any other base. Lower 6 bits must be zero.
                tab_num2asc:
    7CC0 303132     DB  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    7CC3 333435 
    7CC6 363738 
    7CC9 394142 
    7CCC 434445 
    7CCF 464748 
    7CD2 494A4B 
    7CD5 4C4D4E 
    7CD8 4F5051 
    7CDB 525354 
    7CDE 555657 
    7CE1 58595A 
                
                ORG 7D00h  ;low-byte must have bits 0-6 = zero
                TAB_KEYNORM  ; for big keyboard with 54 keys, not shifted, the table has a size of 72 bytes
    7D00 1D1C1E     DB  KCODE_DOWN,KCODE_UP,KCODE_RIGHT,0x0D,0x5C,KCODE_BS, 0,0  ; M4
    7D03 0D5C08 
    7D06 0000   
    7D08 5D3D1F     DB  0x5D,0x3D,KCODE_LEFT,0x27,0x5B,0x2D, 0,0  ; M3
    7D0B 275B2D 
    7D0E 0000   
    7D10 2E6C2F     DB  0x2E,0x6C,0x2F,0x3B,0x70,0x30, 0,0  ; M2
    7D13 3B7030 
    7D16 0000   
    7D18 6F392C     DB  0x6F,0x39,0x2C,0x6B,0x69,0x38, 0,0  ; M1
    7D1B 6B6938 
    7D1E 0000   
    7D20 6E686D     DB  0x6E,0x68,0x6D,0x6A,0x75,0x37, 0,0  ; M0
    7D23 6A7537 
    7D26 0000   
    7D28 793662     DB  0x79,0x36,0x62,0x67,0x74,0x35, 0,0  ; OUT7
    7D2B 677435 
    7D2E 0000   
    7D30 636476     DB  0x63,0x64,0x76,0x66,0x72,0x34, 0,0  ; OUT6
    7D33 667234 
    7D36 0000   
    7D38 653378     DB  0x65,0x33,0x78,0x73,0x77,0x32, 0,0  ; OUT5
    7D3B 737732 
    7D3E 0000   
    7D40 201B7A     DB  0x20,0x1B,0x7A,0x61,0x71,0x31, 0,0  ; OUT4
    7D43 617131 
    7D46 0000   
                
                ;[0]    ;[1]
                ;.....  ;.....
                ;.....  ;#....
                ;.#..#  ;.#...
                ;#.##.  ;..#..
                ;.....  ;...#.
                ;.....  ;....#
                ;.....  ;.....
                ;.....  ;.....
                
    7D48 000009 tab_lcd_chr DB  0x00,0x00,0x09,0x16,0x00,0x00,0x00,0x00  ;[0]:~
    7D4B 160000 
    7D4E 0000   
    7D50 001008             DB  0x00,0x10,0x08,0x04,0x02,0x01,0x00,0x00  ;[1]:\
    7D53 040201 
    7D56 0000   
                
                ORG 7D60h  ;low-byte must have bits 0-4 = zero
                TAB_KEYDECODE  ; for key-code decoding of buttons on LCD-board
    7D60 464544     DB  KC_F, KC_E, KC_D, KC_9, KC_8, KC_7, 0, 0
    7D63 393837 
    7D66 0000   
    7D68 434241     DB  KC_C, KC_B, KC_A, KC_6, KC_5, KC_4, 0, 0
    7D6B 363534 
    7D6E 0000   
    7D70 082F2A     DB  KC_BACK, KC_DIV, KC_MUL, KC_3, KC_2, KC_1, 0, 0
    7D73 333231 
    7D76 0000   
    7D78 032D2B     DB  KC_CE, KC_MINUS, KC_PLUS, KC_RESULT, KC_DOT, KC_0, 0, 0
    7D7B 3D2E30 
    7D7E 0000   
                
                ORG 7D80h  ;low-byte must have bits 0-6 = zero
                TAB_KEYSHIFT ; for big keyboard with 54 keys, shifted, the table has a size of 72 bytes
    7D80 1D1C1E     DB  KCODE_DOWN,KCODE_UP,KCODE_RIGHT,0x0D,0x7C,KCODE_DEL, 0,0  ; M4
    7D83 0D7C7F 
    7D86 0000   
    7D88 7D2B1F     DB  0x7D,0x2B,KCODE_LEFT,0x22,0x7B,0x5F, 0,0  ; M3
    7D8B 227B5F 
    7D8E 0000   
    7D90 3E4C3F     DB  0x3E,0x4C,0x3F,0x3A,0x50,0x29, 0,0  ; M2
    7D93 3A5029 
    7D96 0000   
    7D98 4F283C     DB  0x4F,0x28,0x3C,0x4B,0x49,0x2A, 0,0  ; M1
    7D9B 4B492A 
    7D9E 0000   
    7DA0 4E484D     DB  0x4E,0x48,0x4D,0x4A,0x55,0x26, 0,0  ; M0
    7DA3 4A5526 
    7DA6 0000   
    7DA8 595E42     DB  0x59,0x5E,0x42,0x47,0x54,0x25, 0,0  ; OUT7
    7DAB 475425 
    7DAE 0000   
    7DB0 434456     DB  0x43,0x44,0x56,0x46,0x52,0x24, 0,0  ; OUT6
    7DB3 465224 
    7DB6 0000   
    7DB8 452358     DB  0x45,0x23,0x58,0x53,0x57,0x40, 0,0  ; OUT5
    7DBB 535740 
    7DBE 0000   
    7DC0 207E5A     DB  0x20,0x7E,0x5A,0x41,0x51,0x21, 0,0  ; OUT4
    7DC3 415121 
    7DC6 0000   
                
                ; Special LCD characters for the editor:
                ;[2]    ;[3]    ;[4]
                ;#.###  ;..#..  ;..#..
                ;#.#.#  ;..#..  ;..#..
                ;#.#.#  ;.#...  ;...#.
                ;#.#.#  ;#....  ;....#
                ;#.#.#  ;.#...  ;...#.
                ;#.#.#  ;..#..  ;..#..
                ;#.###  ;..#..  ;..#..
                ;.....  ;..#..  ;..#..
                
    7DC8 001715 ed2_chars   DB  0x00,0x17,0x15,0x15,0x15,0x15,0x17,0x00  ;[2]:10
    7DCB 151515 
    7DCE 1700   
    7DD0 000404             DB  0x00,0x04,0x04,0x08,0x10,0x08,0x04,0x04  ;[3]:<
    7DD3 081008 
    7DD6 0404   
    7DD8 000404             DB  0x00,0x04,0x04,0x02,0x01,0x02,0x04,0x04  ;[4]:>
    7DDB 020102 
    7DDE 0404   
                
                ORG 7DE0h  ;table must fit into one 256-byte segment
                TAB_LIB16DEC
    7DE0 346040     DB  >lib16HtoDec,<lib16HtoDec,0x40,0x9C                           ; 40000
    7DE3 9C     
    7DE4 346340     DB  >lib16toDec, <lib16toDec, 0x40,0x1F                           ; 8000
    7DE7 1F     
    7DE8 346320     DB  >lib16toDec, <lib16toDec, 0x20,0x03                           ; 800
    7DEB 03     
    7DEC 348D50     DB  >lib8toDec , <lib8toDec , 0x50                                ; 80
    7DEF 348D08     DB  >lib8toDec , <lib8toDec , 0x08                                ; 8
    7DF2 00         DB  0
                
                ORG 7DFFh
    7DFF 01         DB  0x12 - 0x11
                
                ORG 7E00h
    7E00 001020 TAB_CRC16HI    DB  000h, 010h, 020h, 030h, 040h, 050h, 060h, 070h
    7E03 304050 
    7E06 6070   
    7E08 8191A1                DB  081h, 091h, 0a1h, 0b1h, 0c1h, 0d1h, 0e1h, 0f1h
    7E0B B1C1D1 
    7E0E E1F1   
    7E10 120232                DB  012h, 002h, 032h, 022h, 052h, 042h, 072h, 062h
    7E13 225242 
    7E16 7262   
    7E18 9383B3                DB  093h, 083h, 0b3h, 0a3h, 0d3h, 0c3h, 0f3h, 0e3h
    7E1B A3D3C3 
    7E1E F3E3   
    7E20 243404                DB  024h, 034h, 004h, 014h, 064h, 074h, 044h, 054h
    7E23 146474 
    7E26 4454   
    7E28 A5B585                DB  0a5h, 0b5h, 085h, 095h, 0e5h, 0f5h, 0c5h, 0d5h
    7E2B 95E5F5 
    7E2E C5D5   
    7E30 362616                DB  036h, 026h, 016h, 006h, 076h, 066h, 056h, 046h
    7E33 067666 
    7E36 5646   
    7E38 B7A797                DB  0b7h, 0a7h, 097h, 087h, 0f7h, 0e7h, 0d7h, 0c7h
    7E3B 87F7E7 
    7E3E D7C7   
    7E40 485868                DB  048h, 058h, 068h, 078h, 008h, 018h, 028h, 038h
    7E43 780818 
    7E46 2838   
    7E48 C9D9E9                DB  0c9h, 0d9h, 0e9h, 0f9h, 089h, 099h, 0a9h, 0b9h
    7E4B F98999 
    7E4E A9B9   
    7E50 5A4A7A                DB  05ah, 04ah, 07ah, 06ah, 01ah, 00ah, 03ah, 02ah
    7E53 6A1A0A 
    7E56 3A2A   
    7E58 DBCBFB                DB  0dbh, 0cbh, 0fbh, 0ebh, 09bh, 08bh, 0bbh, 0abh
    7E5B EB9B8B 
    7E5E BBAB   
    7E60 6C7C4C                DB  06ch, 07ch, 04ch, 05ch, 02ch, 03ch, 00ch, 01ch
    7E63 5C2C3C 
    7E66 0C1C   
    7E68 EDFDCD                DB  0edh, 0fdh, 0cdh, 0ddh, 0adh, 0bdh, 08dh, 09dh
    7E6B DDADBD 
    7E6E 8D9D   
    7E70 7E6E5E                DB  07eh, 06eh, 05eh, 04eh, 03eh, 02eh, 01eh, 00eh
    7E73 4E3E2E 
    7E76 1E0E   
    7E78 FFEFDF                DB  0ffh, 0efh, 0dfh, 0cfh, 0bfh, 0afh, 09fh, 08fh
    7E7B CFBFAF 
    7E7E 9F8F   
    7E80 9181B1                DB  091h, 081h, 0b1h, 0a1h, 0d1h, 0c1h, 0f1h, 0e1h
    7E83 A1D1C1 
    7E86 F1E1   
    7E88 100030                DB  010h, 000h, 030h, 020h, 050h, 040h, 070h, 060h
    7E8B 205040 
    7E8E 7060   
    7E90 8393A3                DB  083h, 093h, 0a3h, 0b3h, 0c3h, 0d3h, 0e3h, 0f3h
    7E93 B3C3D3 
    7E96 E3F3   
    7E98 021222                DB  002h, 012h, 022h, 032h, 042h, 052h, 062h, 072h
    7E9B 324252 
    7E9E 6272   
    7EA0 B5A595                DB  0b5h, 0a5h, 095h, 085h, 0f5h, 0e5h, 0d5h, 0c5h
    7EA3 85F5E5 
    7EA6 D5C5   
    7EA8 342414                DB  034h, 024h, 014h, 004h, 074h, 064h, 054h, 044h
    7EAB 047464 
    7EAE 5444   
    7EB0 A7B787                DB  0a7h, 0b7h, 087h, 097h, 0e7h, 0f7h, 0c7h, 0d7h
    7EB3 97E7F7 
    7EB6 C7D7   
    7EB8 263606                DB  026h, 036h, 006h, 016h, 066h, 076h, 046h, 056h
    7EBB 166676 
    7EBE 4656   
    7EC0 D9C9F9                DB  0d9h, 0c9h, 0f9h, 0e9h, 099h, 089h, 0b9h, 0a9h
    7EC3 E99989 
    7EC6 B9A9   
    7EC8 584878                DB  058h, 048h, 078h, 068h, 018h, 008h, 038h, 028h
    7ECB 681808 
    7ECE 3828   
    7ED0 CBDBEB                DB  0cbh, 0dbh, 0ebh, 0fbh, 08bh, 09bh, 0abh, 0bbh
    7ED3 FB8B9B 
    7ED6 ABBB   
    7ED8 4A5A6A                DB  04ah, 05ah, 06ah, 07ah, 00ah, 01ah, 02ah, 03ah
    7EDB 7A0A1A 
    7EDE 2A3A   
    7EE0 FDEDDD                DB  0fdh, 0edh, 0ddh, 0cdh, 0bdh, 0adh, 09dh, 08dh
    7EE3 CDBDAD 
    7EE6 9D8D   
    7EE8 7C6C5C                DB  07ch, 06ch, 05ch, 04ch, 03ch, 02ch, 01ch, 00ch
    7EEB 4C3C2C 
    7EEE 1C0C   
    7EF0 EFFFCF                DB  0efh, 0ffh, 0cfh, 0dfh, 0afh, 0bfh, 08fh, 09fh
    7EF3 DFAFBF 
    7EF6 8F9F   
    7EF8 6E7E4E                DB  06eh, 07eh, 04eh, 05eh, 02eh, 03eh, 00eh, 01eh
    7EFB 5E2E3E 
    7EFE 0E1E   
                
    7F00 002142 TAB_CRC16LO    DB  000h, 021h, 042h, 063h, 084h, 0a5h, 0c6h, 0e7h
    7F03 6384A5 
    7F06 C6E7   
    7F08 08294A                DB  008h, 029h, 04ah, 06bh, 08ch, 0adh, 0ceh, 0efh
    7F0B 6B8CAD 
    7F0E CEEF   
    7F10 311073                DB  031h, 010h, 073h, 052h, 0b5h, 094h, 0f7h, 0d6h
    7F13 52B594 
    7F16 F7D6   
    7F18 39187B                DB  039h, 018h, 07bh, 05ah, 0bdh, 09ch, 0ffh, 0deh
    7F1B 5ABD9C 
    7F1E FFDE   
    7F20 624320                DB  062h, 043h, 020h, 001h, 0e6h, 0c7h, 0a4h, 085h
    7F23 01E6C7 
    7F26 A485   
    7F28 6A4B28                DB  06ah, 04bh, 028h, 009h, 0eeh, 0cfh, 0ach, 08dh
    7F2B 09EECF 
    7F2E AC8D   
    7F30 537211                DB  053h, 072h, 011h, 030h, 0d7h, 0f6h, 095h, 0b4h
    7F33 30D7F6 
    7F36 95B4   
    7F38 5B7A19                DB  05bh, 07ah, 019h, 038h, 0dfh, 0feh, 09dh, 0bch
    7F3B 38DFFE 
    7F3E 9DBC   
    7F40 C4E586                DB  0c4h, 0e5h, 086h, 0a7h, 040h, 061h, 002h, 023h
    7F43 A74061 
    7F46 0223   
    7F48 CCED8E                DB  0cch, 0edh, 08eh, 0afh, 048h, 069h, 00ah, 02bh
    7F4B AF4869 
    7F4E 0A2B   
    7F50 F5D4B7                DB  0f5h, 0d4h, 0b7h, 096h, 071h, 050h, 033h, 012h
    7F53 967150 
    7F56 3312   
    7F58 FDDCBF                DB  0fdh, 0dch, 0bfh, 09eh, 079h, 058h, 03bh, 01ah
    7F5B 9E7958 
    7F5E 3B1A   
    7F60 A687E4                DB  0a6h, 087h, 0e4h, 0c5h, 022h, 003h, 060h, 041h
    7F63 C52203 
    7F66 6041   
    7F68 AE8FEC                DB  0aeh, 08fh, 0ech, 0cdh, 02ah, 00bh, 068h, 049h
    7F6B CD2A0B 
    7F6E 6849   
    7F70 97B6D5                DB  097h, 0b6h, 0d5h, 0f4h, 013h, 032h, 051h, 070h
    7F73 F41332 
    7F76 5170   
    7F78 9FBEDD                DB  09fh, 0beh, 0ddh, 0fch, 01bh, 03ah, 059h, 078h
    7F7B FC1B3A 
    7F7E 5978   
    7F80 88A9CA                DB  088h, 0a9h, 0cah, 0ebh, 00ch, 02dh, 04eh, 06fh
    7F83 EB0C2D 
    7F86 4E6F   
    7F88 80A1C2                DB  080h, 0a1h, 0c2h, 0e3h, 004h, 025h, 046h, 067h
    7F8B E30425 
    7F8E 4667   
    7F90 B998FB                DB  0b9h, 098h, 0fbh, 0dah, 03dh, 01ch, 07fh, 05eh
    7F93 DA3D1C 
    7F96 7F5E   
    7F98 B190F3                DB  0b1h, 090h, 0f3h, 0d2h, 035h, 014h, 077h, 056h
    7F9B D23514 
    7F9E 7756   
    7FA0 EACBA8                DB  0eah, 0cbh, 0a8h, 089h, 06eh, 04fh, 02ch, 00dh
    7FA3 896E4F 
    7FA6 2C0D   
    7FA8 E2C3A0                DB  0e2h, 0c3h, 0a0h, 081h, 066h, 047h, 024h, 005h
    7FAB 816647 
    7FAE 2405   
    7FB0 DBFA99                DB  0dbh, 0fah, 099h, 0b8h, 05fh, 07eh, 01dh, 03ch
    7FB3 B85F7E 
    7FB6 1D3C   
    7FB8 D3F291                DB  0d3h, 0f2h, 091h, 0b0h, 057h, 076h, 015h, 034h
    7FBB B05776 
    7FBE 1534   
    7FC0 4C6D0E                DB  04ch, 06dh, 00eh, 02fh, 0c8h, 0e9h, 08ah, 0abh
    7FC3 2FC8E9 
    7FC6 8AAB   
    7FC8 446506                DB  044h, 065h, 006h, 027h, 0c0h, 0e1h, 082h, 0a3h
    7FCB 27C0E1 
    7FCE 82A3   
    7FD0 7D5C3F                DB  07dh, 05ch, 03fh, 01eh, 0f9h, 0d8h, 0bbh, 09ah
    7FD3 1EF9D8 
    7FD6 BB9A   
    7FD8 755437                DB  075h, 054h, 037h, 016h, 0f1h, 0d0h, 0b3h, 092h
    7FDB 16F1D0 
    7FDE B392   
    7FE0 2E0F6C                DB  02eh, 00fh, 06ch, 04dh, 0aah, 08bh, 0e8h, 0c9h
    7FE3 4DAA8B 
    7FE6 E8C9   
    7FE8 260764                DB  026h, 007h, 064h, 045h, 0a2h, 083h, 0e0h, 0c1h
    7FEB 45A283 
    7FEE E0C1   
    7FF0 1F3E5D                DB  01fh, 03eh, 05dh, 07ch, 09bh, 0bah, 0d9h, 0f8h
    7FF3 7C9BBA 
    7FF6 D9F8   
    7FF8 173655                DB  017h, 036h, 055h, 074h, 093h, 0b2h, 0d1h, 0f0h
    7FFB 7493B2 
    7FFE D1F0   
                ;[File: my4th-rom_8MHz.asm]
                ;[File: strings.asm]
                ;------------------------------------------------------------------------------
                ; Define Text Strings
                ;------------------------------------------------------------------------------
                
                _strings Segment Code
                
                ORG 7800h
                
                ;the following strings must all fit into one 256-byte-page
                forth_strings_start:
    7800 203F20 text_errQuote   DB " ? missing ",0x22,0
    7803 6D6973 
    7806 73696E 
    7809 672022 
    780C 00     
    780D 203F20 text_errSyntax  DB " ? syntax",0
    7810 73796E 
    7813 746178 
    7816 00     
    7817 203F20 text_errValue   DB " ? value",0
    781A 76616C 
    781D 756500 
    7820 203F20 text_errStack   DB " ? stack",0
    7823 737461 
    7826 636B00 
    7829 203F20 text_errTooLong DB " ? too long",0
    782C 746F6F 
    782F 206C6F 
    7832 6E6700 
    7835 202049 text_errInOut   DB "  I/O Error",0
    7838 2F4F20 
    783B 457272 
    783E 6F7200 
    7841 204552 text_errMem     DB " ERROR: Out of Memory",0
    7844 524F52 
    7847 3A204F 
    784A 757420 
    784D 6F6620 
    7850 4D656D 
    7853 6F7279 
    7856 00     
    7857 203F20 text_errWord    DB " ? unknown word ",0
    785A 756E6B 
    785D 6E6F77 
    7860 6E2077 
    7863 6F7264 
    7866 2000   
    7868 203F20 text_errNumber  DB " ? number too large",0
    786B 6E756D 
    786E 626572 
    7871 20746F 
    7874 6F206C 
    7877 617267 
    787A 6500   
                
                ;these strings can wrap over a 256-byte-boundary:
    787C 203F20 text_errCmd     DB " ? Unknown command",0
    787F 556E6B 
    7882 6E6F77 
    7885 6E2063 
    7888 6F6D6D 
    788B 616E64 
    788E 00     
    788F 203F20 text_runerr     DB " ? RUN word not found\n",0
    7892 52554E 
    7895 20776F 
    7898 726420 
    789B 6E6F74 
    789E 20666F 
    78A1 756E64 
    78A4 0A00   
    78A6 203F20 text_errImport  DB " ? unknown import word ",0
    78A9 756E6B 
    78AC 6E6F77 
    78AF 6E2069 
    78B2 6D706F 
    78B5 727420 
    78B8 776F72 
    78BB 642000 
    78BE 0A6162 text_abort      DB "\naborted\n",0
    78C1 6F7274 
    78C4 65640A 
    78C7 00     
    78C8 20636F text_compiled   DB " compiled\n",0
    78CB 6D7069 
    78CE 6C6564 
    78D1 0A00   
    78D3 72756E text_run        DB "run",0
    78D6 00     
    78D7 205772 text_wrongver   DB " Wrong My4TH version!\n",0
    78DA 6F6E67 
    78DD 204D79 
    78E0 345448 
    78E3 207665 
    78E6 727369 
    78E9 6F6E21 
    78EC 0A00   
    78EE 206F6B text_forth_ok   DB " ok\n",0
    78F1 0A00   
    78F3 2020   text_saving1    DB "  "
    78F5 736176 text_saving2    DB "saving...",0
    78F8 696E67 
    78FB 2E2E2E 
    78FE 00     
    78FF 0A6C6F text_loading    DB "\nloading screen...",0
    7902 616469 
    7905 6E6720 
    7908 736372 
    790B 65656E 
    790E 2E2E2E 
    7911 00     
    7912 5B7361 text_ed_headln  DB "[save] [save+quit] [quit] [clear]",0
    7915 76655D 
    7918 205B73 
    791B 617665 
    791E 2B7175 
    7921 69745D 
    7924 205B71 
    7927 756974 
    792A 5D205B 
    792D 636C65 
    7930 61725D 
    7933 00     
                ;text_ed_quit    DB "\nQuit\n",0
    7934 207361 text_savedto    DB " saved to blocks ",0
    7937 766564 
    793A 20746F 
    793D 20626C 
    7940 6F636B 
    7943 732000 
    7946 20746F text_to         DB " to ",0
    7949 2000   
    794B 204552 text_error      DB " ERROR\n",0
    794E 524F52 
    7951 0A00   
    7953 507265 text_autostart1 DB "Press any key to stop autostart\n",0
    7956 737320 
    7959 616E79 
    795C 206B65 
    795F 792074 
    7962 6F2073 
    7965 746F70 
    7968 206175 
    796B 746F73 
    796E 746172 
    7971 740A00 
    7974 4E6F77 text_autostart2 DB "Now executing screen ",0
    7977 206578 
    797A 656375 
    797D 74696E 
    7980 672073 
    7983 637265 
    7986 656E20 
    7989 00     
    798A 506C65 text_useterm    DB "Please use the RS232 terminal",0
    798D 617365 
    7990 207573 
    7993 652074 
    7996 686520 
    7999 525332 
    799C 333220 
    799F 746572 
    79A2 6D696E 
    79A5 616C00 
                
    79A8 0A5765 text_heading1   DB "\nWelcome to My4TH"
    79AB 6C636F 
    79AE 6D6520 
    79B1 746F20 
    79B4 4D7934 
    79B7 5448   
    79B9 2076                   DB " v"
    79BB 312E32                 DB "1.2"
    79BE 202F20                 DB " / ",0
    79C1 00     
    79C2 204D48 text_heading2   DB " MHz\n",0
    79C5 7A0A00 
                
    79C8 1B5B44 text_backsp     DB 27,"[D ",
    79CB 20     
    79CC 1B5B44 text_left       DB 27,"[D",0
    79CF 00     
    79D0 1B5B43 text_right      DB 27,"[C",0
    79D3 00     
    79D4 1B5B31 text_home       DB 27,"[1;1H",0
    79D7 3B3148 
    79DA 00     
    79DB 1B5B31 text_clear      DB 27,"[1;1H",27,"[J",0
    79DE 3B3148 
    79E1 1B5B4A 
    79E4 00     
                
    79E5 454550 text_eeproms1   DB "EEPROMs: ",0
    79E8 524F4D 
    79EB 733A20 
    79EE 00     
    79EF 20626C text_eeproms2   DB " blocks)\n",0
    79F2 6F636B 
    79F5 73290A 
    79F8 00     
    79F9 204B42 text_eeproms3   DB " KB installed\n",0
    79FC 20696E 
    79FF 737461 
    7A02 6C6C65 
    7A05 640A00 
    7A08 6E6F6E text_eeplist    DB "none",0,"24LC512",0,"24LC1025",0,"24LC1026",0
    7A0B 650032 
    7A0E 344C43 
    7A11 353132 
    7A14 003234 
    7A17 4C4331 
    7A1A 303235 
    7A1D 003234 
    7A20 4C4331 
    7A23 303236 
    7A26 00     
                ;[File: my4th-rom_8MHz.asm]
                ;[File: variables.asm]
                ;------------------------------------------------------------------------------
                ; Variables and Registers are defined here
                ;------------------------------------------------------------------------------
                
                _zeropage Segment Data
                
                ; Common system / library variables
                LIB_BUF       DS 14 ; 14 character universal buffer
                LIB_TFDATA    DS 6  ; 6 bytes for the transfer functions in transfer.asm
                LIB_BIGKEYB   DS 1  ; flag: if set to 1, the big keyboard with 4x40 LCD is installed
                LIB_KEYREPC   DS 2  ; keyboard key repeat counter
                LIB_DISPMAXX  DS 1  ; X size (width) of the current display
                LIB_DISPMAXY  DS 1  ; Y size (height) of the current display
                LIB_LCDMAXX   DS 1  ; max. X-position on the LCD (20 or 40)
                LIB_LCDOUT    DS 1  ; flag: if set to 1, all print-functions are printing on LCD instead over UART
                LIB_LCDENAS   DS 1  ; LCD enable bits: bit4 = LCD1, bit5 = LCD2, bit1 = always 1, all other bits must be 0!
                LIB_LCDCRSR   DS 1  ; flag: nonzero when the cursor is on
                LIB_KBNOKEYB  DS 1  ; for keyboard input: Key-Debounce-"Counter"
                LIB_LCDPOSX   DS 1  ; cursor X-position on the display
                LIB_LCDPOSY   DS 1  ; cursor Y-position on the display
                LIB_LCDBUFP   DS 1  ; ptr into LCD_BUFFER (lower 8-bit of the buffer address)
                LIB_EEPADDR   DS 1  ; address of currently selected EEPROM
                LIB_EEADDRS   DS 8  ; addresses of all detected EEPROMs (0=no EEPROM)
                LIB_NUMPAGES  DS 2  ; count of 1kb pages the EEPROMs can store
                LIB_I2C_C0D0  DS 1  ; I2C: SCL=0, SDA=0  (R6_L)
                LIB_I2C_C0D1  DS 1  ; I2C: SCL=0, SDA=1  (R7_L)
                LIB_I2C_C1D0  DS 1  ; I2C: SCL=1, SDA=0  (R6_H)
                LIB_I2C_C1D1  DS 1  ; I2C: SCL=1, SDA=1  (R7_H)
                LIB_MYNOR_OUT DS 2  ; shadow values for MyNOR output ports 1 and 2
                
                ;------------------------------------------------------------------------
                ; Forth Variables
                ;------------------------------------------------------------------------
                
                ;------------------------------------------
                
                ; Memory for program header (contains the variables CP and DICTA, and system vectors, UP )
                PRGHDR_SIZE SET 3*6 + 2 + 2*8 + 2 + 5 ; 43 bytes
                PRGHEADER   DS  PRGHDR_SIZE
                
                ; System vectors
                VECT_OUTPUT SET PRGHEADER+0  ; if not NULL, vector for printing characters on external device
                VECT_INPUT  SET PRGHEADER+3  ; if not NULL, external function for keyboard input (non-blocking 'readkey')
                VECT_OK     SET PRGHEADER+6  ; this vector gets called to print the OK text
                VECT_PROMPT SET PRGHEADER+9  ; vector to print the prompt 
                VECT_INPSTR SET PRGHEADER+12 ; vector for custom input string function (see input_string in input.asm)
                VECT_GETNBR SET PRGHEADER+15 ; vector for converting numbers from a string
                
                VECTOR1       SET VECT_OUTPUT
                OUTPUT_VECTOR SET REGPAGE + VECT_OUTPUT ;JSR to address OUTPUT_VECTOR to call the vector
                INPUT_VECTOR  SET REGPAGE + VECT_INPUT  ;JSR to address INPUT_VECTOR to call the vector
                OK_VECTOR     SET REGPAGE + VECT_OK     ;JSR to address OK_VECTOR to call the vector
                PROMPT_VECTOR SET REGPAGE + VECT_PROMPT ;JSR to address PROMPT_VECTOR to call the vector
                INPSTR_VECTOR SET REGPAGE + VECT_INPSTR ;JSR to address INPSTR_VECTOR to call the vector
                GETNBR_VECTOR SET REGPAGE + VECT_GETNBR ;JSR to address GETNBR_VECTOR to call the vector
                
                ; start of pre-initialized variables
                VAR_INIT_START  SET CP_L
                
                ; pointer to beginning of free memory (the "heap") (this is also the Forth variable "HERE")
                CP_L        SET PRGHEADER+18
                CP_H        SET PRGHEADER+19
                
                ; 8 dictionary pointers
                DICTA       SET PRGHEADER+20
                
                ; Forth user pointer
                UP          SET PRGHEADER+36
                UP_L        SET UP
                UP_H        SET UP+1
                
                ; Storage for the block structure
                BLKSTR_SIZE SET 5
                BLKSTRUCT   SET PRGHEADER+38
                BLKSTR_BUF  SET BLKSTRUCT
                BLKSTR_BLK  SET BLKSTRUCT+2
                BLKSTR_UPD  SET BLKSTRUCT+4
                
                ;space for JSR via pointer
                JSRSPACE      DS 6   ;contains JSR x, JMP return
                JSRSPACE_JMP  SET REGPAGE + JSRSPACE
                
                ;space for JSR/JMP instruction for the interpreter
                IPRSPACE      DS 6   ;contains JSR x, JMP interpreterloop
                IPRSPACE_JMP  SET REGPAGE + IPRSPACE
                
                ; Forth BASE variable
                BASE        DS  2
                
                ; state of the EEPROM (1=active read transfer)
                EEP_STATE   DS 1
                
                ;storage for next input char (if available)
                NEXTINCHR   DS 1
                
                ; Storage for block number
                BLK         DS 2
                BLK_L       SET BLK
                BLK_H       SET BLK+1
                
                ; Storage for the block most recently listed
                SCR         DS 2
                SCR_L       SET SCR
                SCR_H       SET SCR+1
                
                INPUTDEV    DS 1  ; current input device for string command execution
                INDEV_LOCAL   SET 0  ; the input device is the local keyboard or a terminal connected to the UART
                INDEV_FILE    SET 1  ; the input device is a screen loaded from EEPROM
                INDEV_REMOTE  SET 2  ; the input device is a remote host
                
                ; Flag for REFILL
                REFILL      DS 1
                
                VAR_INIT_END    SET REFILL+1
                ; end of pre-initialized variables
                ;------------------------------------------
                
                ; Helper pointer for DOES>
                DOESH       DS 2
                DOESH_L     SET DOESH
                DOESH_H     SET DOESH+1
                
                ; Forth parameter stack pointer (0x8100 - 0x817F)
                fPSP        DS 1
                
                ; System data stack pointer
                SYSSP       DS 1
                
                ; Return stack stack pointer
                RETSP       DS 1
                
                ; Control flow stack pointer for conditional jumps and other compiler constructs
                CCFSP       DS 1
                
                ; Control flow stack pointer for loop control
                LCFSP       DS 1
                
                ; Buffer for mathematical calculations: shares two bytes space with "JSRSPACE"
                MATH_BUF    SET JSRSPACE+1
                
                ; interpreter state: 0 = execute words, 1 = compile word address to dictionary
                STATE       DS 2
                
                ; pointer to start of code of current word that is getting compiled
                CW          DS 2
                CW_L        SET CW
                CW_H        SET CW+1
                
                ; pointer to the last added word
                DICTL       DS 2
                DICTL_L     SET DICTL
                DICTL_H     SET DICTL+1
                
                ; pointer to list head pointer of the selected dictionary
                DICTLH      DS 1
                
                ; current parser input data pointer. This is the Forth variable >IN (but it does not start with 0).
                INPTR       DS 2
                INPTR_L     SET INPTR
                INPTR_H     SET INPTR+1
                
                ; temporary storage for the return stack pointer
                RSP         DS 1
                
                ; Storage for random number generator
                RANDVAR     DS 3
                
                ; buffer pointer for pictured numeric output string
                NB          DS 2
                NB_L        SET NB
                NB_H        SET NB+1
                
                ; the terminal input buffer
                TIBUF_SZ    SET 80
                TIBUF       SET FORTH_INPBUF
                
                ; if screen is loaded from EEPROM, this is the current line number 0-15
                FILE_LNBR   DS 1
                
                ;------------------------------------------------------------------------
                ; Binary Driver Variables
                ;------------------------------------------------------------------------
                
                _zpbinmod Segment Data
                
                DRIVER_VARS DS 32   ; dummy: allocate 32 bytes for external driver code
                
                ;------------------------------------------------------------------------
                ; Buffer memory 0x8200 - 0x83FF
                ;------------------------------------------------------------------------
                
                ;_buffermem Segment Data
                ;ORG 0x8200
                
                _ram      Segment Data  ;starts at 0x8200
                
                LCD_BUFFER    DS 4*40
                FORTH_INPBUF  DS TIBUF_SZ  ;buffer for keyboard input
                FILE_LINEBUF  DS 65  ;used as input buffer for the LOAD command (SCREEN lines)
                UART_BUFFER   DS 170 ;minimum size for command execution, but buffer can occupy more memory
                ;no more buffers are allowed to follow here, because they are overwritten
                ;by data received via UART
                
                ;Define a dummy-segment for FORTH user program data. This is a "memory barrier" and
                ;will issue a warning in the list file when the variables defined above will overwrite
                ;the beginning of the FORTH data area.
                forth_program  Segment Data
                ORG FORTH_START
                ;[File: my4th-rom_8MHz.asm]
                ;[File: keydefs.hsm]
                
                ;[File: my4th-rom_8MHz.asm]
                
                PRINT   MACRO x
                          JSR  printstrm
                          DB   <x
                          DB   >x
                        ENDMACRO 
                
                ;------------------------------------------------------------------------------
                ; The program code starts here
                ;------------------------------------------------------------------------------
                
                _program  Segment Code
                ORG 0x2D00
                
                ;[File: jumplist.asm]
                ;------------------------------------------------------------------------------
                ; List with usefull library jumps
                ;------------------------------------------------------------------------------
                
    2D00 189575 J_2D00  JMP  reset_entry
    2D03 182433 J_2D03  JMP  print_char
    2D06 184633 J_2D06  JMP  print_str
    2D09 18B633 J_2D09  JMP  print_hexbyte
    2D0C 18DF33 J_2D0C  JMP  print_decword
    2D0F 189732 J_2D0F  JMP  display_clear
    2D12 18BF32 J_2D12  JMP  display_gotoxy
    2D15 18B332 J_2D15  JMP  display_cursor_on
    2D18 18B932 J_2D18  JMP  display_cursor_off
    2D1B 18A12E J_2D1B  JMP  lcd_init
    2D1E 18302F J_2D1E  JMP  lcd_term
    2D21 183531 J_2D21  JMP  lcd_out_ch
    2D24 187D31 J_2D24  JMP  lcd_out_fast
    2D27 183F32 J_2D27  JMP  lcd_load_charset
    2D2A 18C039 J_2D2A  JMP  keyb_readkey   ;non-blocking keyboard input function, reads from keyboard
    2D2D 18AC34 J_2D2D  JMP  inp_readkey    ;blocking read-key function, reads from keyboard and UART or over a vector
    2D30 18F62D J_2D30  JMP  i2c_start_addr
    2D33 18DE2D J_2D33  JMP  i2c_stop
    2D36 18042E J_2D36  JMP  i2c_send
    2D39 182E2E J_2D39  JMP  i2c_recv
    2D3C 18DB44 J_2D3C  JMP  push_data_R4
    2D3F 18FD44 J_2D3F  JMP  push_data_R5
    2D42 180E45 J_2D42  JMP  pop_data_R4
    2D45 182445 J_2D45  JMP  pop_data_R5
    2D48 18124C J_2D48  JMP  search_forth_word
    2D4B 180739 J_2D4B  JMP  eeprom_read_forth_block
    2D4E 182539 J_2D4E  JMP  eeprom_write_forth_block
    2D51 184F46 J_2D51  JMP  set_vector     ;In: accu = vector number, R4 = new function address
    2D54 185C46 J_2D54  JMP  get_vector     ;In: accu = vector number, Out: R4 = current function address
    2D57 189076 J_2D57  JMP  uart_xmit
    2D5A 18CD76 J_2D5A  JMP  uart_recv
    2D5D 188F40 J_2D5D  JMP  negate_R45
    2D60 189D42 J_2D60  JMP  multiply_u
    2D63 184442 J_2D63  JMP  mul32u
    2D66 182143 J_2D66  JMP  mul32s
    2D69 184C43 J_2D69  JMP  divide_u
    2D6C 182441 J_2D6C  JMP  div_u32u16
    2D6F 180A42 J_2D6F  JMP  div_i32i16
                
                ;reserve space for 10 more vectors
                    DS 10*3
                ;[File: my4th-rom_8MHz.asm]
                ;[File: mynor-out.asm]
                ;------------------------------------------------------------------------------
                ; Functions to access the digital output ports on the MyNOR platform
                ;------------------------------------------------------------------------------
                
                ;[File: my4th-rom_8MHz.asm]
                ;[File: delay.asm]
                ;------------------------------------------------------------------------------
                ; Delay - routines to delay program execution, used by the FORTH word "msec"
                ;------------------------------------------------------------------------------
                
                ;Put UART code into a special segment so it never crosses a 256-byte boundary
                delay_functions Segment Code
                ORG 0x7670
                
                ;Delay routine for 8 MHz CPU clock frequency:
                delay_ms:
                          ; Delay program execution for several milliseconds.
                          ; In: ACCU = number of milliseconds to delay.
    7670 011026           LD   R0,#38
    7673 207376 _dlms01   JLP  _dlms01
    7676 0B10             ROL  R0
    7678 23               CLC
    7679 0A0E             DEC
    767B 150E             TST
    767D 177076           JNF  delay_ms
    7680 1A               RET
                
                ;Delay routine for 10 MHz CPU clock frequency:
                
                ;Delay routine for 12 MHz CPU clock frequency:
                
                ;Delay routine for 14 MHz CPU clock frequency:
                ;[File: my4th-rom_8MHz.asm]
                ;[File: uart.asm]
                ;------------------------------------------------------------------------------
                ; UART Functions for sending / receiving with 2400 baud
                ;------------------------------------------------------------------------------
                
                ;Put UART code into a special segment so it never crosses a 256-byte boundary
                uart_functions Segment Code
                ORG 0x7690
                
                UART_TXD_DEFAULT  SET 0x01   ; TXD is high by default
                
                ;UART routines for 8 MHz CPU clock frequency:
                
                uart_xmit:
                          ;@API UART
                          ; Send a character / byte over the UART TxD line with 2400 baud
                          ; In: ACCU = character, OUTP = bits 0-6 of Output Port 3
                          ; Changes: ACCU
                
                          ;send start-bit
    7690 0606             STA  PAR2
    7692 041C             LDA  OUTP
    7694 0105FE           AND  #0xFE
    7697 0D05   
    7699 260E             OUT
    769B 061C             STA  OUTP
                          ;delay
    769D 0C0E             ROR  ACCU
    769F 0C0E             ROR  ACCU
    76A1 090E             INC
    76A3 090E             INC
                          ;output bits
    76A5 010508           LD   PAR1,#8
    76A8 041C   _sndbit   LDA  OUTP
    76AA 0C06             ROR  PAR2
    76AC 0E0F             OR   FLAG
    76AE 260E             OUT
                          ;delay
    76B0 090E             INC
    76B2 020E0E           LD   ACCU,ACCU
    76B5 020E0E           LD   ACCU,ACCU
                          ;output next bit
    76B8 0A05             DEC  PAR1
    76BA 1505             TST  PAR1
    76BC 17A876           JNF  _sndbit
                          ;send stop-bit
    76BF 041C             LDA  OUTP
    76C1 010501           OR   #0x01
    76C4 0E05   
    76C6 260E             OUT
    76C8 061C             STA  OUTP
                          ;correct R0L
    76CA 0C06             ROR  PAR2
                          ;return
    76CC 1A               RET
                
                uart_recv:
                          ;@API UART
                          ; Receive a character / byte over the UART RxD line with 2400 baud
                          ; Out: ACCU = received byte
                          ; Changes: ACCU
                          ;
                          ;wait for start-bit (falling edge on RxD)
    76CD 1D     _rcvch1   IN
    76CE 060F             STA  FLAG
    76D0 17CD76           JNF  _rcvch1
    76D3 09A4   _rcvch2   INC  RANDVAR
    76D5 1D               IN
    76D6 060F             STA  FLAG
    76D8 16D376           JPF  _rcvch2
                          ;delay
    76DB 090E             INC
    76DD 090E             INC
    76DF 090E             INC
    76E1 090E             INC
                          ;receive 8 bits
    76E3 010508           LD   PAR1,#8
                _rcvch3   ;delay
    76E6 0F0E             XOR  ACCU
    76E8 090E             INC
    76EA 23               CLC
    76EB 23               CLC
                          ;receive next bit
    76EC 1D               IN
    76ED 060F             STA  FLAG
    76EF 0C06             ROR  PAR2
    76F1 0A05             DEC  PAR1
    76F3 1505             TST  PAR1
    76F5 17E676           JNF  _rcvch3
                          ;return
    76F8 0406             LDA  PAR2
    76FA 1A               RET
                
                
                ;------------------------------------------------------------------------------
                
                ;UART routines for 10 MHz CPU clock frequency:
                
                ;------------------------------------------------------------------------------
                
                ;UART routines for 12 MHz CPU clock frequency:
                
                ;------------------------------------------------------------------------------
                
                ;UART routines for 14 MHz CPU clock frequency:
                
                _program  Segment Code
                
                ;  IO-Speedtest mit ./my4th -t -d timing -c 20000 -f 8
                ;[File: my4th-rom_8MHz.asm]
                ;[File: i2c.asm]
                ;------------------------------------------------------------------------------
                ; I2C Interface (bit-banging)
                ;------------------------------------------------------------------------------
                
                i2c_init:
                          ;@API I2C
                          ; Initialize the I2C-Bus (bring the bus into a defined state).
    2D90 1E               PHL
    2D91 011101           LD   R1,#1
    2D94 19A72D           JSR  i2c_start
    2D97 192E2E           JSR  i2c_recv
    2D9A 19DE2D           JSR  i2c_stop
    2D9D 19A72D           JSR  i2c_start
    2DA0 192E2E           JSR  i2c_recv
                
                i2c_stop_ret:
    2DA3 19DE2D           JSR  i2c_stop
    2DA6 1F               RTS
                
                i2c_start: 
                          ;@API I2C
                          ; Send a start-condition and prepare registers R6 and R7
                          ; for the following I2C-transfer. While the I2C-transfer
                          ; is in progress, the user is not allowed to write to
                          ; OUT_PORT3 and OUTP.
                          ; Out: FLAG = 1 on success
                          ; Changes: ACCU
    2DA7 0302             LDA  #0x02
    2DA9 0E1C             OR   OUTP
    2DAB 260E             OUT                     ; SDA = 1
    2DAD 0105FB           AND  #0xFB
    2DB0 0D05   
    2DB2 064D             STA  LIB_I2C_C0D1       ; SDA = 1, SCL = 0
    2DB4 010504           OR   #0x04
    2DB7 0E05   
    2DB9 260E             OUT                     ; SCL = 1
                          ;test if SDA is 1
    2DBB 1B0E             PSH
    2DBD 1D               IN
    2DBE 0C0E             ROR
    2DC0 060F             STA  FLAG
    2DC2 1C0E             POP
    2DC4 17CD3A           JNF  ret_opc
    2DC7 064F             STA  LIB_I2C_C1D1       ; SDA = 1, SCL = 1
    2DC9 0105FD           AND  #0xFD
    2DCC 0D05   
    2DCE 260E             OUT                     ; SDA = 0
    2DD0 064E             STA  LIB_I2C_C1D0       ; SDA = 0, SCL = 1
    2DD2 0105FB           AND  #0xFB
    2DD5 0D05   
    2DD7 064C             STA  LIB_I2C_C0D0       ; SDA = 0, SCL = 0
    2DD9 260E             OUT                     ; SCL = 0
    2DDB 061C             STA  OUTP
    2DDD 1A               RET
                
                i2c_stop:
                          ;@API I2C
                          ; Send a stop-condition
                          ; Changes: ACCU
    2DDE 041C             LDA  OUTP
    2DE0 0105FB           AND  #0xFB
    2DE3 0D05   
    2DE5 260E             OUT             ; SDA = X, SCL = 0
    2DE7 044C             LDA  LIB_I2C_C0D0
    2DE9 260E             OUT             ; SDA = 0, SCL = 0
    2DEB 044E             LDA  LIB_I2C_C1D0
    2DED 260E             OUT             ; SDA = 0, SCL = 1
    2DEF 044F             LDA  LIB_I2C_C1D1
    2DF1 260E             OUT             ; SDA = 1, SCL = 1
    2DF3 061C             STA  OUTP
    2DF5 1A               RET
                
                i2c_start_addr:
                          ;@API I2C
                          ; Send a start-condition followed by the I2C-address-byte.
                          ; In : R0 = I2C-address and R/W-bit
                          ; Out: FLAG = acknowledge-bit  (FLAG = 0 when OK)
                          ; Changes: ACCU, R0, R1
    2DF6 1E               PHL
    2DF7 19A72D           JSR  i2c_start
    2DFA 17CB3A           JNF  return_flag_1
    2DFD 1C0B             POP  LR_H
    2DFF 1C0A             POP  LR_L
    2E01 021110           LD   R1,R0
                
                i2c_send:
                          ;@API I2C
                          ; Send a byte over I2C
                          ; In : R1 = byte to send
                          ; Out: FLAG = acknowledge-bit  (FLAG = 0 when OK)
                          ; Changes: ACCU, R0, R1
    2E04 011008           LD   R0,#8
    2E07 0B11   _i2csn4   ROL  R1
    2E09 16182E           JPF  _i2csn5
                          ;SDA = 0
    2E0C 264C             OUT  LIB_I2C_C0D0       ; SDA = 0, SCL = 0
    2E0E 264E             OUT  LIB_I2C_C1D0       ; SDA = 0, SCL = 1
    2E10 264C             OUT  LIB_I2C_C0D0       ; SDA = 0, SCL = 0
    2E12 20072E           JLP  _i2csn4
    2E15 18212E           JMP  _i2csn6
                _i2csn5   ;SDA = 1
    2E18 264D             OUT  LIB_I2C_C0D1       ; SDA = 1, SCL = 0
    2E1A 264F             OUT  LIB_I2C_C1D1       ; SDA = 1, SCL = 1
    2E1C 264D             OUT  LIB_I2C_C0D1       ; SDA = 1, SCL = 0
    2E1E 20072E           JLP  _i2csn4
                _i2csn6   ;last bit send, prepare to receive ACK
    2E21 264D             OUT  LIB_I2C_C0D1       ; SDA = 1, SCL = 0
    2E23 264F             OUT  LIB_I2C_C1D1       ; SDA = 1, SCL = 1
    2E25 23               CLC                     ; delay
                          ;receive ACK/NAK
    2E26 1D               IN
    2E27 0C0E             ROR
    2E29 060F             STA  FLAG
    2E2B 264D             OUT  LIB_I2C_C0D1       ; SDA = 1, SCL = 0
    2E2D 1A               RET
                
                i2c_recv:
                          ;@API I2C
                          ; Receive a byte over I2C
                          ; In : R1 = acknowledge-bit
                          ; Out: R0 and ACCU = received byte
                          ; Changes: ACCU, R0
    2E2E 264D             OUT  LIB_I2C_C0D1       ; SDA = 1
    2E30 264F             OUT  LIB_I2C_C1D1       ; SCL = 1
    2E32 1D               IN
    2E33 0C0E             ROR
    2E35 264D             OUT  LIB_I2C_C0D1       ; SCL = 0
    2E37 060F             STA  FLAG
    2E39 0B10             ROL  R0
    2E3B 264F             OUT  LIB_I2C_C1D1       ; SCL = 1
    2E3D 1D               IN
    2E3E 0C0E             ROR
    2E40 264D             OUT  LIB_I2C_C0D1       ; SCL = 0
    2E42 060F             STA  FLAG
    2E44 0B10             ROL  R0
    2E46 264F             OUT  LIB_I2C_C1D1       ; SCL = 1
    2E48 1D               IN
    2E49 0C0E             ROR
    2E4B 264D             OUT  LIB_I2C_C0D1       ; SCL = 0
    2E4D 060F             STA  FLAG
    2E4F 0B10             ROL  R0
    2E51 264F             OUT  LIB_I2C_C1D1       ; SCL = 1
    2E53 1D               IN
    2E54 0C0E             ROR
    2E56 264D             OUT  LIB_I2C_C0D1       ; SCL = 0
    2E58 060F             STA  FLAG
    2E5A 0B10             ROL  R0
    2E5C 264F             OUT  LIB_I2C_C1D1       ; SCL = 1
    2E5E 1D               IN
    2E5F 0C0E             ROR
    2E61 264D             OUT  LIB_I2C_C0D1       ; SCL = 0
    2E63 060F             STA  FLAG
    2E65 0B10             ROL  R0
    2E67 264F             OUT  LIB_I2C_C1D1       ; SCL = 1
    2E69 1D               IN
    2E6A 0C0E             ROR
    2E6C 264D             OUT  LIB_I2C_C0D1       ; SCL = 0
    2E6E 060F             STA  FLAG
    2E70 0B10             ROL  R0
    2E72 264F             OUT  LIB_I2C_C1D1       ; SCL = 1
    2E74 1D               IN
    2E75 0C0E             ROR
    2E77 264D             OUT  LIB_I2C_C0D1       ; SCL = 0
    2E79 060F             STA  FLAG
    2E7B 0B10             ROL  R0
    2E7D 264F             OUT  LIB_I2C_C1D1       ; SCL = 1
    2E7F 1D               IN
    2E80 0C0E             ROR
    2E82 264D             OUT  LIB_I2C_C0D1       ; SCL = 0
    2E84 060F             STA  FLAG
    2E86 0B10             ROL  R0
                          ;send ACK/NAK
    2E88 1511             TST  R1
    2E8A 17972E           JNF  _i2crv2
                          ;send ACK (SDA = 0)
    2E8D 264C             OUT  LIB_I2C_C0D0       ; SDA = 0, SCL = 0
    2E8F 264E             OUT  LIB_I2C_C1D0       ; SDA = 0, SCL = 1
    2E91 23               CLC                     ; delay
    2E92 264C             OUT  LIB_I2C_C0D0       ; SDA = 0, SCL = 0
    2E94 189C2E           JMP  _i2crv3
                _i2crv2   ;send NAK (SDA = 1)
    2E97 264D             OUT  LIB_I2C_C0D1       ; SDA = 1, SCL = 0
    2E99 264F             OUT  LIB_I2C_C1D1       ; SDA = 1, SCL = 1
    2E9B 23               CLC                     ; delay
    2E9C 264D   _i2crv3   OUT  LIB_I2C_C0D1       ; SDA = 1, SCL = 0
    2E9E 0410             LDA  R0
    2EA0 1A               RET
                ;[File: my4th-rom_8MHz.asm]
                ;[File: lcd.asm]
                ;------------------------------------------------------------------------------
                ; LCD Support Library
                ;------------------------------------------------------------------------------
                
                
                LCDENA1   SET  0x12|UART_TXD_DEFAULT  ;bit0 = UART, bit1 (sda) = 1, bit2 (scl) = 0, bit3 (E) = 0, bit4/5 = lcd enable
                LCDENA2   SET  0x22|UART_TXD_DEFAULT  ;bit0 = UART, bit1 (sda) = 1, bit2 (scl) = 0, bit3 (E) = 0, bit4/5 = lcd enable
                LCDDTMD   SET  0x06|UART_TXD_DEFAULT  ;bit0 = UART, bit1 (sda) = 1, bit2 (scl) = 1, bit3 (E) = 0, bit4/5 = don't care
                LCDDTMR   SET  0x02|UART_TXD_DEFAULT  ;bit0 = UART, bit1 (sda) = 1, bit2 (scl) = 0, bit3 (E) = 0, bit4/5 = don't care
                
                CRSR_ON_CMD  SET 0x0F  ;0x0E = underline, 0x0F = blinking cursor
                
                lcd_init:
                          ; Initialize LCD display.
    2EA1 1E               PHL
    2EA2 19A62E           JSR  _lcdini2  ;need to initialize the LCD twice for reliable operation
    2EA5 03               DB   0x03  ;skip next byte (PHL instruction)
    2EA6 1E     _lcdini2  PHL
    2EA7 19562F           JSR  lcdSetCmdReg
    2EAA 261C             OUT  OUTP
    2EAC 013B13           LD   LIB_LCDENAS,#LCDENA1  ; start with first half of the LCD
    2EAF 19D92E           JSR  _lcdinit
    2EB2 013914           LD   LIB_LCDMAXX,#20
    2EB5 1534             TST  LIB_BIGKEYB
    2EB7 16C32E           JPF  _lcdini1
    2EBA 013928           LD   LIB_LCDMAXX,#40
    2EBD 013B23           LD   LIB_LCDENAS,#LCDENA2  ; then initialize the second half of the LCD
    2EC0 19D92E           JSR  _lcdinit
    2EC3 19A52F _lcdini1  JSR  lcd_clear
    2EC6 19422F           JSR  lcdWait2ms
    2EC9 19C62F           JSR  lcd_cursor_on
                          ;finished
    2ECC 015400           LD   VECT_OUTPUT+2,#0  ; set standard output vector so text is printed on LCD
    2ECF 013A01           LD   LIB_LCDOUT,#1
    2ED2 023739           LD   LIB_DISPMAXX,LIB_LCDMAXX
    2ED5 013804           LD   LIB_DISPMAXY,#4
    2ED8 1F               RTS
                
                _lcdinit: ;initialize the currently selected LCD (E1/E2)
    2ED9 1E               PHL
                          ;configure interface (set to 4-bit)
    2EDA 19562F           JSR  lcdSetCmdReg
    2EDD 261C             OUT  OUTP
    2EDF 19422F           JSR  lcdWait2ms
    2EE2 0330             LDA  #0x30
    2EE4 19652F           JSR  lcdSendNibble
    2EE7 0304             LDA  #4
    2EE9 197076           JSR  delay_ms
    2EEC 0330             LDA  #0x30
    2EEE 19652F           JSR  lcdSendNibble
    2EF1 19422F           JSR  lcdWait2ms
    2EF4 0330             LDA  #0x30
    2EF6 19652F           JSR  lcdSendNibble
    2EF9 19422F           JSR  lcdWait2ms
    2EFC 0320             LDA  #0x20  ;configure 4-bit mode
    2EFE 19652F           JSR  lcdSendNibble
    2F01 19422F           JSR  lcdWait2ms
                          ;send bytes
    2F04 0328             LDA  #0x28     ;4-bit mode
    2F06 19752F           JSR  lcdSendByte
    2F09 0306             LDA  #0x06     ;entry mode: increment, no shift
    2F0B 19752F           JSR  lcdSendByte
    2F0E 0310             LDA  #0x10     ;no display shift
    2F10 19752F           JSR  lcdSendByte
    2F13 0301             LDA  #0x01     ;clear the LCD
    2F15 19752F           JSR  lcdSendByte
    2F18 19422F           JSR  lcdWait2ms
    2F1B 011000           LD   R0,#0
    2F1E 011102           LD   R1,#2
    2F21 010C48           LD   PTR_L,#<tab_lcd_chr
    2F24 010D7D           LD   PTR_H,#>tab_lcd_chr
    2F27 193F32           JSR  lcd_load_charset
    2F2A 030C             LDA  #0x0C     ;switch display on (and cursor off)
    2F2C 19752F           JSR  lcdSendByte
    2F2F 1F               RTS
                
                lcd_term:
                          ; Switch display off
    2F30 153A             TST  LIB_LCDOUT
    2F32 16CD3A           JPF  ret_opc
    2F35 1E               PHL
    2F36 19A52F           JSR  lcd_clear
    2F39 03               DB   0x03  ;skip next byte (PSH instruction)
                lcd_disable:
    2F3A 1E               PHL
    2F3B 19D32F           JSR  lcd_cursor_off
    2F3E 19C275           JSR  terminal_init
    2F41 1F               RTS
                
                lcdWait2ms:
    2F42 0302             LDA  #2
    2F44 187076           JMP  delay_ms
                
                lcdSetDataReg:
    2F47 043B             LDA  LIB_LCDENAS
    2F49 260E             OUT
    2F4B 010504           OR   #0x04 ; SCL high, clock in the E-bits
    2F4E 0E05   
    2F50 260E             OUT
    2F52 011C07           LD   OUTP,#LCDDTMD
    2F55 1A               RET
                
                lcdSetCmdReg:
    2F56 043B             LDA  LIB_LCDENAS
    2F58 260E             OUT
    2F5A 010504           OR   #0x04 ; SCL high, clock in the E-bits
    2F5D 0E05   
    2F5F 260E             OUT
    2F61 011C03           LD   OUTP,#LCDDTMR
    2F64 1A               RET
                
                lcdSendNibble:
                          ; Send a data nibble to the LCD
                          ; Input: ACCU = data nibble in bits 4-7
    2F65 0E1C             OR   OUTP
    2F67 260E             OUT  ACCU
    2F69 0606             STA  PAR2
    2F6B 010508           LD   PAR1,#0x08
    2F6E 0E05             OR   PAR1
    2F70 260E             OUT  ACCU   ; E=1
    2F72 2606             OUT  PAR2   ; E=0
    2F74 1A               RET
                
                lcdSendByte:
                          ; Send a data byte to the LCD in 4-bit mode
                          ; Input: ACCU = data byte
                          ; Changes: ACCU, R1
    2F75 0611             STA  R1
                lcdSendR1:
    2F77 03F0             LDA  #0xF0
    2F79 0D11             AND  R1
    2F7B 0E1C             OR   OUTP
    2F7D 260E             OUT  ACCU
    2F7F 0606             STA  PAR2
    2F81 010508           LD   PAR1,#0x08
    2F84 0E05             OR   PAR1
    2F86 260E             OUT  ACCU   ; E=1
    2F88 2606             OUT  PAR2   ; E=0
    2F8A 0411             LDA  R1
    2F8C 23               CLC
    2F8D 0B0E             ROL
    2F8F 23               CLC
    2F90 0B0E             ROL
    2F92 23               CLC
    2F93 0B0E             ROL
    2F95 23               CLC
    2F96 0B0E             ROL
    2F98 0E1C             OR   OUTP
    2F9A 260E             OUT  ACCU
    2F9C 0606             STA  PAR2
    2F9E 0E05             OR   PAR1
    2FA0 260E             OUT  ACCU   ; E=1
    2FA2 2606             OUT  PAR2   ; E=0
    2FA4 1A               RET
                
                lcd_clear:
                          ; Clear the LCD display.
                          ; The cursor will be set to upper left edge.
                          ; Changes: ACCU, R0, R1
    2FA5 1E               PHL
                          ;send clear-display-command
    2FA6 0301             LDA  #0x01
    2FA8 19D82F           JSR  sendCmdToAllLCD
    2FAB 19422F           JSR  lcdWait2ms
    2FAE 0110A0           LD   R0,#4*40
    2FB1 0320             LDA  #0x20
    2FB3 010C00           LD   PTR_L,#<LCD_BUFFER
    2FB6 010D82           LD   PTR_H,#>LCD_BUFFER
    2FB9 193D3C           JSR  memset
                          ;reset cursor position
    2FBC 013E00           LD   LIB_LCDPOSX,#0
    2FBF 013F00           LD   LIB_LCDPOSY,#0
    2FC2 199231           JSR  lcd_rst_crsr
    2FC5 1F               RTS
                
                lcd_cursor_on:
                          ; Switch cursor on
                          ; Changes: ACCU, R0, R1
    2FC6 013C01           LD   LIB_LCDCRSR,#1
    2FC9 153A             TST  LIB_LCDOUT
    2FCB 179231           JNF  lcd_rst_crsr
    2FCE 030F             LDA  #CRSR_ON_CMD
    2FD0 18D82F           JMP  sendCmdToAllLCD
                
                lcd_cursor_off:
                          ; Switch cursor off
                          ; Changes: ACCU, R0, R1
    2FD3 013C00           LD   LIB_LCDCRSR,#0
                
                sendCrsrOffCmd:
    2FD6 030C             LDA  #0x0C
                
                sendCmdToAllLCD:
                          ; Send command in ACCU to all available LCD controller chips
    2FD8 1E               PHL
    2FD9 1B0E             PSH
    2FDB 013B13           LD   LIB_LCDENAS,#LCDENA1
    2FDE 19562F           JSR  lcdSetCmdReg
    2FE1 1C0E             POP
    2FE3 1B0E             PSH
    2FE5 19752F           JSR  lcdSendByte
    2FE8 153A             TST  LIB_LCDOUT
    2FEA 17F02F           JNF  _sctal1
    2FED 1C0E             POP
    2FEF 1F               RTS
    2FF0 013B23 _sctal1   LD   LIB_LCDENAS,#LCDENA2
    2FF3 19562F           JSR  lcdSetCmdReg
    2FF6 1C0E             POP
    2FF8 19752F           JSR  lcdSendByte
    2FFB 1F               RTS
                
                lcd_shift:
                          ; Shift LCD one line up, clear last line
    2FFC 1E               PHL
    2FFD 1B10             PSH  R0
    2FFF 1B11             PSH  R1
    3001 1B13             PSH  R3
    3003 1B14             PSH  R4
    3005 1B16             PSH  R5
    3007 1B0C             PSH  PTR_L
    3009 1B0D             PSH  PTR_H
                          ;print out all lines, shift buffer one line up
    300B 011300           LD   R3,#0  ; line counter (destination line)
    300E 011400           LD   R4,#<(LCD_BUFFER+0)  ; destination address in memory
    3011 011628           LD   R5,#<(LCD_BUFFER+40) ; source address in memory
                _lcdsft7  ;setup first/next line to output
    3014 011000           LD   R0,#0
    3017 021113           LD   R1,R3
    301A 19B631           JSR  lcd_gotoxy
                          ;copy/output one row
    301D 19472F           JSR  lcdSetDataReg
    3020 021039           LD   R0,LIB_LCDMAXX ; row counter, counts down to zero
    3023 020C16 _lcdsft6  LD   PTR_L,R5
    3026 010D82           LD   PTR_H,#>LCD_BUFFER
    3029 05               LAP
    302A 020C14           LD   PTR_L,R4
    302D 07               SAP
    302E 19752F           JSR  lcdSendByte
    3031 0914             INC  R4
    3033 0916             INC  R5
    3035 202330           JLP  _lcdsft6
                          ;add an offset to R4/R5 if LCD is only 4x20 (because buffer is 4x40)
    3038 153A             TST  LIB_LCDOUT
    303A 174C30           JNF  _lcdsft8
    303D 010514           LD   PAR1,#20
    3040 0414             LDA  R4
    3042 2405             AD   PAR1
    3044 0614             STA  R4
    3046 0416             LDA  R5
    3048 2405             AD   PAR1
    304A 0616             STA  R5
                _lcdsft8  ;copy next line
    304C 0913             INC  R3
    304E 0303             LDA  #3
    3050 1413             CMP  R3
    3052 171430           JNF  _lcdsft7
                          ;clear last line
    3055 020C14           LD   PTR_L,R4
    3058 011000           LD   R0,#0
    305B 011103           LD   R1,#3
    305E 19B631           JSR  lcd_gotoxy
    3061 19472F           JSR  lcdSetDataReg
    3064 021039           LD   R0,LIB_LCDMAXX
    3067 0320   _lcdsft9  LDA  #20h
    3069 07               SAP
    306A 090C             INC  PTR_L
    306C 19752F           JSR  lcdSendByte
    306F 206730           JLP  _lcdsft9
                          ;set cursor to beginning of last line
    3072 011000           LD   R0,#0
    3075 011103           LD   R1,#3
    3078 19B631           JSR  lcd_gotoxy
    307B 1C0D             POP  PTR_H
    307D 1C0C             POP  PTR_L
    307F 1C16             POP  R5
    3081 1C14             POP  R4
    3083 1C13             POP  R3
    3085 1C11             POP  R1
    3087 1C10             POP  R0
    3089 1F               RTS
                
                lcd_print:
                          ; Print a character on the LCD
                          ; In: ACCU = character
                          ; Changes: ACCU
    308A 0606             STA  PAR2
    308C 0105E0           AND  #0xE0
    308F 0D05   
    3091 150E             TST
    3093 16F830           JPF  _lcdpr1  ; value is below < 0x20
    3096 153C   _lcdpr0   TST  LIB_LCDCRSR
    3098 16CA30           JPF  _lcdpr7
    309B 043E             LDA  LIB_LCDPOSX
    309D 090E             INC
    309F 1439             CMP  LIB_LCDMAXX
    30A1 17CA30           JNF  _lcdpr7
                          ;next printed character will result
                          ;in moving the cursor outside the view area:
                          ;the cursor must then be set to the next
                          ;valid position
    30A4 1E               PHL
    30A5 0406             LDA  PAR2
    30A7 193531           JSR  lcd_out_ch
    30AA 1B10             PSH  R0
    30AC 1B11             PSH  R1
    30AE 043F             LDA  LIB_LCDPOSY
    30B0 1303             CMP  #3       ;last line, last row? If yes:
    30B2 16C230           JPF  _lcdpr8  ;switch cursor off, because it is behind the scene
    30B5 013E00           LD   LIB_LCDPOSX,#0
    30B8 093F             INC  LIB_LCDPOSY
    30BA 199231           JSR  lcd_rst_crsr
    30BD 1C11             POP  R1
    30BF 1C10             POP  R0
    30C1 1F               RTS
    30C2 19D62F _lcdpr8   JSR  sendCrsrOffCmd
    30C5 1C11             POP  R1
    30C7 1C10             POP  R0
    30C9 1F               RTS
                
                _lcdpr7   ;continue with outputting the character
    30CA 043E             LDA  LIB_LCDPOSX
    30CC 1439             CMP  LIB_LCDMAXX
    30CE 0406             LDA  PAR2
    30D0 173531           JNF  lcd_out_ch
                          ;wrap around into next LCD line
    30D3 1E               PHL
    30D4 1B06             PSH  PAR2
    30D6 013E00           LD   LIB_LCDPOSX,#0
    30D9 043F             LDA  LIB_LCDPOSY
    30DB 1303             CMP  #3
    30DD 16F030           JPF  _lcdpr5
    30E0 093F             INC  LIB_LCDPOSY
    30E2 1B10             PSH  R0
    30E4 1B11             PSH  R1
    30E6 199231           JSR  lcd_rst_crsr
    30E9 1C11             POP  R1
    30EB 1C10             POP  R0
    30ED 18F330           JMP  _lcdpr6
                _lcdpr5   ;shift content of display one line up, and clear last line
    30F0 19FC2F           JSR  lcd_shift
    30F3 1C0E   _lcdpr6   POP  ACCU
    30F5 183631           JMP  _lcdout
                
                _lcdpr1   ;test for special characters
    30F8 0406             LDA  PAR2
    30FA 130D             CMP  #0x0D  ;CR '\r'
    30FC 162A31           JPF  _lcdpr2
    30FF 130A             CMP  #0x0A  ;LF '\n'
    3101 161D31           JPF  _lcdpr4
    3104 1308             CMP  #0x08  ;Backspace
    3106 179630           JNF  _lcdpr0
                          ;Backspace
    3109 1E               PHL
    310A 153E             TST  LIB_LCDPOSX
    310C 16CA3A           JPF  return
    310F 1B10             PSH  R0
    3111 1B11             PSH  R1
    3113 0A3E             DEC  LIB_LCDPOSX
    3115 0A40             DEC  LIB_LCDBUFP
    3117 199231           JSR  lcd_rst_crsr
    311A 182531           JMP  _lcdpr3
                _lcdpr4   ;LF
    311D 1E               PHL
    311E 1B10             PSH  R0
    3120 1B11             PSH  R1
    3122 19A731           JSR  lcd_newline
    3125 1C11   _lcdpr3   POP  R1
    3127 1C10             POP  R0
    3129 1F               RTS
                _lcdpr2   ;CR
    312A 1E               PHL
    312B 1B10             PSH  R0
    312D 1B11             PSH  R1
    312F 199E31           JSR  lcd_return
    3132 182531           JMP  _lcdpr3
                
                lcd_out_ch:
                          ;Print character in accu to the LCD.
                          ;Write chacter also to the backlog buffer.
                          ;Correct character codes before printing (~ and \)
                          ; This function does no safety checkings and
                          ; does not support special control characters.
    3135 1E               PHL
    3136 137E   _lcdout   CMP  #'~'
    3138 173D31           JNF  _lcdoch1
    313B 0300             LDA  #0
    313D 135C   _lcdoch1  CMP  #'\\'
    313F 174431           JNF  _lcdoch2
    3142 0301             LDA  #1
    3144 1B11   _lcdoch2  PSH  R1
    3146 0611             STA  R1
    3148 1B0C             PSH  PTR_L
    314A 1B0D             PSH  PTR_H
    314C 020C40           LD   PTR_L,LIB_LCDBUFP
    314F 010D82           LD   PTR_H,#>LCD_BUFFER
    3152 07               SAP
    3153 1C0D             POP  PTR_H
    3155 1C0C             POP  PTR_L
    3157 0940             INC  LIB_LCDBUFP
    3159 093E             INC  LIB_LCDPOSX
                          ; code inlined: (JSR  lcdSetDataReg)
    315B 043B             LDA  LIB_LCDENAS
    315D 260E             OUT
    315F 010504           OR   #0x04 ; SCL high, clock in the E-bits
    3162 0E05   
    3164 260E             OUT
    3166 011C07           LD   OUTP,#LCDDTMD
                          ;
    3169 19772F           JSR  lcdSendR1
    316C 1C11             POP  R1
    316E 1F               RTS
                
                lcd_out_fch:
                          ; Same like lcd_out_fast, but corrects special characters
    316F 137E             CMP  #'~'
    3171 177631           JNF  _lcdofc1
    3174 0300             LDA  #0
    3176 135C   _lcdofc1  CMP  #'\\'
    3178 177D31           JNF  lcd_out_fast
    317B 0301             LDA  #1
                
                lcd_out_fast:
                          ; Print a character on the LCD *fast*.
                          ; This function does no safety checkings and
                          ; does not support special control characters.
                          ; It also does not write to the LCD backlog
                          ; buffer, so scrolling the LCD up is not possible.
                          ; In: ACCU = character
                          ; Changes: ACCU, R1
    317D 0611             STA  R1
    317F 093E             INC  LIB_LCDPOSX
    3181 043B             LDA  LIB_LCDENAS
    3183 260E             OUT
    3185 010504           OR   #0x04 ; SCL high, clock in the E-bits
    3188 0E05   
    318A 260E             OUT
    318C 011C07           LD   OUTP,#LCDDTMD
    318F 18772F           JMP  lcdSendR1
                
                lcd_rst_crsr:
                          ; Reset cursor position to position stored in LIB_LCDPOSX/Y
    3192 02103E           LD   R0,LIB_LCDPOSX
    3195 02113F           LD   R1,LIB_LCDPOSY
    3198 18B631           JMP  lcd_gotoxy
                
                lcd_home:
                          ; Move cursor to top left position
    319B 013F00           LD   LIB_LCDPOSY,#0
                
                lcd_return:
                          ; Move cursor to beginning of current line.
                          ; Changes: ACCU, R0, R1
    319E 02113F           LD   R1,LIB_LCDPOSY
    31A1 011000           LD   R0,#0
    31A4 18B631           JMP  lcd_gotoxy
                
                lcd_newline:
                          ; Move cursor to beginning of next line.
                          ; Changes: ACCU, R0, R1
    31A7 043F             LDA  LIB_LCDPOSY
    31A9 1303             CMP  #3
    31AB 16FC2F           JPF  lcd_shift
    31AE 011000           LD   R0,#0
    31B1 02113F           LD   R1,LIB_LCDPOSY
    31B4 0911             INC  R1
                
                lcd_gotoxy:
                          ; Set the cursor to the next position to print to.
                          ; In: R0 = X-position, R1 = Y-position
                          ; Changes: ACCU, R1
    31B6 1E               PHL
    31B7 023E10           LD   LIB_LCDPOSX,R0
    31BA 023F11           LD   LIB_LCDPOSY,R1
    31BD 153A             TST  LIB_LCDOUT
    31BF 17EC31           JNF  _lgt10
                          ;gotoxy on a small 4x20 LCD
    31C2 0380             LDA  #0x80
    31C4 014000           LD   LIB_LCDBUFP,#<(LCD_BUFFER+0*40)
    31C7 1511             TST  R1
    31C9 162432           JPF  _lgt11
    31CC 0A11             DEC  R1
    31CE 03C0             LDA  #0xC0
    31D0 014028           LD   LIB_LCDBUFP,#<(LCD_BUFFER+1*40)
    31D3 1511             TST  R1
    31D5 162432           JPF  _lgt11
    31D8 0A11             DEC  R1
    31DA 0394             LDA  #0x94
    31DC 014050           LD   LIB_LCDBUFP,#<(LCD_BUFFER+2*40)
    31DF 1511             TST  R1
    31E1 162432           JPF  _lgt11
    31E4 03D4             LDA  #0xD4
    31E6 014078           LD   LIB_LCDBUFP,#<(LCD_BUFFER+3*40)
    31E9 182432           JMP  _lgt11
                _lgt10    ;gotoxy on a big 4x40 LCD
    31EC 153C             TST  LIB_LCDCRSR
    31EE 16F731           JPF  _lgt12
    31F1 19D62F           JSR  sendCrsrOffCmd
    31F4 02113F           LD   R1,LIB_LCDPOSY
    31F7 013B13 _lgt12    LD   LIB_LCDENAS,#LCDENA1
    31FA 0380             LDA  #0x80
    31FC 014000           LD   LIB_LCDBUFP,#<(LCD_BUFFER+0*40)
    31FF 1511             TST  R1
    3201 162432           JPF  _lgt11
    3204 0A11             DEC  R1
    3206 03C0             LDA  #0xC0
    3208 014028           LD   LIB_LCDBUFP,#<(LCD_BUFFER+1*40)
    320B 1511             TST  R1
    320D 162432           JPF  _lgt11
    3210 0A11             DEC  R1
    3212 013B23           LD   LIB_LCDENAS,#LCDENA2
    3215 0380             LDA  #0x80
    3217 014050           LD   LIB_LCDBUFP,#<(LCD_BUFFER+2*40)
    321A 1511             TST  R1
    321C 162432           JPF  _lgt11
    321F 03C0             LDA  #0xC0
    3221 014078           LD   LIB_LCDBUFP,#<(LCD_BUFFER+3*40)
    3224 2410   _lgt11    AD   R0
    3226 0611             STA  R1
    3228 19562F           JSR  lcdSetCmdReg
    322B 19772F           JSR  lcdSendR1
    322E 0440             LDA  LIB_LCDBUFP
    3230 2410             AD   R0
    3232 0640             STA  LIB_LCDBUFP
    3234 153C             TST  LIB_LCDCRSR
    3236 16CA3A           JPF  rts_opc
    3239 030F             LDA  #CRSR_ON_CMD
    323B 19752F           JSR  lcdSendByte
    323E 1F               RTS
                
                lcd_load_charset:
                          ; Load a custom character set (up to 8 characters)
                          ; into the LCD. Custom characters can be displayed
                          ; with character codes 0-7.
                          ; In: R0 = ID of first character to load (0-7),
                          ;     R1 = count of characters to load (1-8),
                          ;     PTR = pointer to bitmap data (8 byte per character),
                          ;     note: set R0=0, R1=8 to load all 8 characters at once
                          ; Changes: ACCU, R0, R1, PTR
    323F 153A             TST  LIB_LCDOUT
    3241 166232           JPF  _lcdlcs3
    3244 1E               PHL
    3245 1B10             PSH  R0
    3247 1B11             PSH  R1
    3249 1B0C             PSH  PTR_L
    324B 1B0D             PSH  PTR_H
    324D 013B13           LD   LIB_LCDENAS,#LCDENA1
    3250 196232           JSR  _lcdlcs3
    3253 1C0D             POP  PTR_H
    3255 1C0C             POP  PTR_L
    3257 1C11             POP  R1
    3259 1C10             POP  R0
    325B 013B23           LD   LIB_LCDENAS,#LCDENA2
    325E 196232           JSR  _lcdlcs3
    3261 1F               RTS
    3262 1E     _lcdlcs3  PHL
    3263 1B11             PSH  R1
    3265 0410             LDA  R0
    3267 23               CLC
    3268 0B0E             ROL
    326A 0B0E             ROL
    326C 0B0E             ROL
    326E 010540           OR   #0x40
    3271 0E05   
    3273 0611             STA  R1
    3275 19562F           JSR  lcdSetCmdReg
    3278 19772F           JSR  lcdSendR1
    327B 19472F           JSR  lcdSetDataReg
    327E 1C10             POP  R0
    3280 1B10   _lcdlcs2  PSH  R0
    3282 011008           LD   R0,#8
    3285 19CE3A _lcdlcs1  JSR  lap_inc_ptr
    3288 19752F           JSR  lcdSendByte
    328B 208532           JLP  _lcdlcs1
    328E 1C10             POP  R0
    3290 208032           JLP  _lcdlcs2
    3293 199231           JSR  lcd_rst_crsr
    3296 1F               RTS
                
                ;pr_nibble:
                ;          ; Print a single hex-nibble
                ;          ; In: nibble in ACCU
                ;          SU   #10
                ;          JPF  _prnib2
                ;          ADD  #3Ah
                ;          JMP  uart_xmit
                ;_prnib2   ADD  #40h
                ;          JMP  uart_xmit
                ;
                ;pr_hexbyte:
                ;          ;@API Printing
                ;          ; Print a byte in hexadecimal
                ;          ; In: byte in ACCU
                ;          ; Changes: ACCU
                ;          PHL
                ;          PSH  ACCU
                ;          CLC
                ;          ROR
                ;          CLC
                ;          ROR
                ;          CLC
                ;          ROR
                ;          CLC
                ;          ROR
                ;          JSR  pr_nibble
                ;          POP  ACCU
                ;          AND  #0Fh
                ;          JSR  pr_nibble
                ;          POP  LR_H
                ;          POP  LR_L
                ;          RET
                
                ;[File: my4th-rom_8MHz.asm]
                ;[File: print.asm]
                ;------------------------------------------------------------------------------
                ; Printing
                ;------------------------------------------------------------------------------
                
                display_clear:
                          ;@API Printing
                          ; Clears the screen (LCD or terminal window)
                          ; Changes: ACCU, R0, R1, PTR
    3297 153A             TST  LIB_LCDOUT
    3299 17A52F           JNF  lcd_clear
    329C 010CDB           LD   PTR_L,#<text_clear
    329F 010D79           LD   PTR_H,#>text_clear
    32A2 184633           JMP  print_str
                
                display_home:
                          ;@API Printing
                          ; Move cursor to home position (upper left edge of terminal window or LCD).
                          ; Changes: ACCU, R0, R1, PTR
    32A5 153A             TST  LIB_LCDOUT
    32A7 179B31           JNF  lcd_home
    32AA 010CD4           LD   PTR_L,#<text_home
    32AD 010D79           LD   PTR_H,#>text_home
    32B0 184633           JMP  print_str
                
                display_cursor_on:
                          ;@API Printing
                          ; Switch cursor on (only applicable with LCD)
                          ; Changes: ACCU
    32B3 153A             TST  LIB_LCDOUT
    32B5 17C62F           JNF  lcd_cursor_on
    32B8 1A               RET
                
                display_cursor_off:
                          ;@API LCD
                          ; Switch cursor off (only applicable with LCD)
                          ; Changes: ACCU
    32B9 153A             TST  LIB_LCDOUT
    32BB 17D32F           JNF  lcd_cursor_off
    32BE 1A               RET
                
                display_gotoxy:
                          ;@API Printing
                          ; Set the cursor to the next position to print to.
                          ; In: R0 = X-position, R1 = Y-position
                          ; Changes: ACCU, R0, R1, R4, R5
    32BF 153A             TST  LIB_LCDOUT
    32C1 17B631           JNF  lcd_gotoxy
    32C4 1E               PHL
    32C5 1B11             PSH  R1
    32C7 1B10             PSH  R0
    32C9 19A532           JSR  display_home
    32CC 1C0E             POP
    32CE 150E             TST
    32D0 16DB32           JPF  _digxy1
    32D3 19EB32           JSR  _digxy2
    32D6 0343             LDA  #'C'
    32D8 192433           JSR  print_char
    32DB 1C0E   _digxy1   POP
    32DD 150E             TST
    32DF 16CA3A           JPF  return
    32E2 19EB32           JSR  _digxy2
    32E5 0342             LDA  #'B'
    32E7 192433           JSR  print_char
    32EA 1F               RTS
    32EB 1E     _digxy2   PHL
    32EC 0614             STA  R4_L
    32EE 031B             LDA  #27
    32F0 192433           JSR  print_char
    32F3 035B             LDA  #'['
    32F5 192433           JSR  print_char
    32F8 011500           LD   R4_H,#0
    32FB 01160A           LD   R5_L,#10
    32FE 011700           LD   R5_H,#0
    3301 194C43           JSR  divide_u
    3304 1514             TST  R4_L
    3306 161033           JPF  _digxy3
    3309 0330             LDA  #0x30
    330B 0E14             OR   R4_L
    330D 192433           JSR  print_char
    3310 0330   _digxy3   LDA  #0x30
    3312 0E16             OR   R5_L
    3314 192433           JSR  print_char
    3317 1F               RTS
                
                print_space:
                          ;@API Printing
                          ; Print only a space character.
                          ; Changes: ACCU
    3318 0320             LDA  #32
    331A 182433           JMP  print_char
                
                print_cr:
                          ;@API Printing
                          ; Print only a CR character.
                          ; Changes: ACCU
    331D 030D             LDA  #13
    331F 182433           JMP  print_char
                
                print_nl:
                          ;@API Printing
                          ; Print New-Line characters CR/NL.
                          ; Changes: ACCU
    3322 030A             LDA  #10
                
                print_char:
                          ;@API Printing
                          ; Print a character.
                          ; In: ACCU = character to print
                          ; Changes: ACCU
    3324 1554             TST  VECT_OUTPUT+2
    3326 175280           JNF  OUTPUT_VECTOR
    3329 153A             TST  LIB_LCDOUT
    332B 178A30           JNF  lcd_print
    332E 130A             CMP  #10
    3330 179076           JNF  uart_xmit
    3333 1E     _prCrLf   PHL
    3334 030D             LDA  #13
    3336 199076           JSR  uart_xmit
    3339 1C0B             POP  LR_H
    333B 1C0A             POP  LR_L
    333D 0F0E   _prLf     XOR  ACCU  ;insert "waitstates", this will insert a 2nd stop-bit so a serial connection with 8n2 will be possible
    333F 0F0E             XOR  ACCU
    3341 030A             LDA  #10
    3343 189076           JMP  uart_xmit
                
                print_str:
                          ;@API Printing
                          ; Print a string.
                          ; In: PTR = pointer to zero-terminated string.
                          ; Changes: ACCU, PTR
    3346 1E               PHL
    3347 153A             TST  LIB_LCDOUT
    3349 177133           JNF  _prstlp1
    334C 1554             TST  VECT_OUTPUT+2
    334E 177133           JNF  _prstlp1
                _prstlp2  ;UART
    3351 05               LAP
    3352 150E             TST
    3354 16CA3A           JPF  return
    3357 130A             CMP  #10
    3359 176233           JNF  _prstlp3
    335C 193333           JSR  _prCrLf
    335F 186533           JMP  _prstlp4
    3362 199076 _prstlp3  JSR  uart_xmit
    3365 090C   _prstlp4  INC  PTR_L
    3367 150C             TST  PTR_L
    3369 175133           JNF  _prstlp2
    336C 090D             INC  PTR_H
    336E 185133           JMP  _prstlp2
                
                _prstlp1  ;print on LCD or other device
    3371 05               LAP
    3372 150E             TST
    3374 16CA3A           JPF  return
    3377 192433           JSR  print_char
    337A 090C             INC  PTR_L
    337C 150C             TST  PTR_L
    337E 177133           JNF  _prstlp1
    3381 090D             INC  PTR_H
    3383 187133           JMP  _prstlp1
                
                printstrm:
                          ;Print a string, the pointer to the string
                          ;follows the JSR instruction to this routine.
                          ;Only use together with the PRINT macro.
    3386 1E               PHL
    3387 19563B           JSR  pop_ptr
    338A 19CE3A           JSR  lap_inc_ptr
    338D 0606             STA  PAR2
    338F 19CE3A           JSR  lap_inc_ptr
    3392 193D3B           JSR  psh_ptr
    3395 020C06           LD   PTR_L,PAR2
    3398 060D             STA  PTR_H
    339A 194633           JSR  print_str
    339D 1F               RTS
                
                print_nibble:
                          ; Print a single hex-nibble
                          ; In: nibble in ACCU
    339E 01050A           SU   #10
    33A1 2505   
    33A3 16AE33           JPF  _prnib1
    33A6 01053A           ADD  #3Ah
    33A9 1005   
    33AB 182433           JMP  print_char
    33AE 010540 _prnib1   ADD  #40h
    33B1 1005   
    33B3 182433           JMP  print_char
                
                print_hexbyte:
                          ;@API Printing
                          ; Print a byte in hexadecimal
                          ; In: byte in ACCU
                          ; Changes: ACCU
    33B6 1E               PHL
    33B7 1B0E             PSH  ACCU
    33B9 23               CLC
    33BA 0C0E             ROR
    33BC 23               CLC
    33BD 0C0E             ROR
    33BF 23               CLC
    33C0 0C0E             ROR
    33C2 23               CLC
    33C3 0C0E             ROR
    33C5 199E33           JSR  print_nibble
    33C8 1C0E             POP  ACCU
    33CA 01050F           AND  #0Fh
    33CD 0D05   
    33CF 199E33           JSR  print_nibble
    33D2 1F               RTS
                
                print_hexword:
                          ;@API Printing
                          ; Print a word (16-bit) in hexadecimal
                          ; In: word in R4
                          ; Changes: ACCU
    33D3 1E               PHL
    33D4 0415             LDA  R4_H
    33D6 19B633           JSR  print_hexbyte
    33D9 0414             LDA  R4_L
    33DB 19B633           JSR  print_hexbyte
    33DE 1F               RTS
                
                ;-------------------------------------------------
                
                print_decword:
                          ;@API Printing
                          ; Print a word (16-bit unsigned) in decimal notation
                          ; In: word in R4
                          ; Changes: ACCU
    33DF 1E               PHL
                print_decword_rts:
    33E0 1B10             PSH  R0
    33E2 1B11             PSH  R1
    33E4 1B12             PSH  R2
    33E6 19423B           JSR  psh_r4
    33E9 19473B           JSR  psh_r5
    33EC 193D3B           JSR  psh_ptr
    33EF 191D34           JSR  convert_16bit_to_decimal
    33F2 011004           LD   R0,#4
    33F5 05     _prdw01   LAP
    33F6 090C             INC  PTR_L
    33F8 1330             CMP  #0x30
    33FA 170334           JNF  _prdw02
    33FD 20F533           JLP  _prdw01
    3400 05     _prdw06   LAP
    3401 090C             INC  PTR_L
    3403 192433 _prdw02   JSR  print_char
    3406 1510             TST  R0
    3408 0A10             DEC  R0
    340A 170034           JNF  _prdw06
    340D 19563B           JSR  pop_ptr
    3410 19603B           JSR  pop_r5
    3413 195B3B           JSR  pop_r4
    3416 1C12             POP  R2
    3418 1C11             POP  R1
    341A 1C10             POP  R0
    341C 1F               RTS
                
                convert_16bit_to_decimal:
                          ;@API Printing
                          ; Convert a 16-bit binary number into a 5 digits decimal number.
                          ; In : 16-bit number in R4
                          ; Out: 5 digits decimal number in LIB_BUF. PTR points to LIB_BUF.
                          ; Changes: R0, R1, R2, R4, R5, PTR
    341D 1E               PHL
                          ;setup decoder loop for 15 digits
    341E 011220           LD   R2,#LIB_BUF
    3421 010CE0           LD   PTR_L,#<TAB_LIB16DEC
                          ;enter the loop
    3424 012500           LD   LIB_BUF+5,#0
                _libdec1  ;loop
    3427 010D7D           LD   PTR_H,#>TAB_LIB16DEC
    342A 05               LAP
    342B 150E             TST
    342D 164034           JPF  _libdec2  ; finished
    3430 060B             STA  LR_H
    3432 090C             INC  PTR_L
    3434 05               LAP
    3435 060A             STA  LR_L
    3437 090C             INC  PTR_L
    3439 011104           LD   R1,#4
    343C 011000           LD   R0,#0
    343F 1A               RET
                _libdec2  ;return ptr to LIB_BUF
    3440 010D80           LD   PTR_H,#>ZEROPAGE
    3443 010C20           LD   PTR_L,#LIB_BUF
    3446 1F               RTS
                lib2decRet:
    3447 1B0C             PSH  PTR_L
    3449 010D80           LD   PTR_H,#>ZEROPAGE
    344C 020C12           LD   PTR_L,R2
    344F 0410             LDA  R0
    3451 010530           OR   #0x30
    3454 0E05   
    3456 07               SAP
    3457 0912             INC  R2
    3459 1C0C             POP  PTR_L
    345B 090C             INC  PTR_L
    345D 182734           JMP  _libdec1
                lib16HtoDec:
    3460 011103           LD   R1,#3
                lib16toDec:
    3463 05               LAP
    3464 0616             STA  R5_L
    3466 090C             INC  PTR_L
    3468 05               LAP
    3469 0617             STA  R5_H
    346B 0414   _l16td1   LDA  R4_L
    346D 2516             SU   R5_L
    346F 0605             STA  PAR1
    3471 0415             LDA  R4_H
    3473 1117             SUB  R5_H
    3475 177D34           JNF  _l16td2
    3478 021405           LD   R4_L,PAR1
    347B 0615             STA  R4_H
    347D 0B10   _l16td2   ROL  R0
    347F 0C17             ROR  R5_H
    3481 0C16             ROR  R5_L
    3483 0A11             DEC  R1
    3485 1511             TST  R1
    3487 176B34           JNF  _l16td1
    348A 184734           JMP  lib2decRet
                lib8toDec:
    348D 05               LAP
    348E 0616             STA  R5_L
    3490 0414   _l8td1    LDA  R4_L
    3492 2516             SU   R5_L
    3494 179934           JNF  _l8td2
    3497 0614             STA  R4_L
    3499 0B10   _l8td2    ROL  R0
    349B 0C16             ROR  R5_L
    349D 0A11             DEC  R1
    349F 1511             TST  R1
    34A1 179034           JNF  _l8td1
    34A4 184734           JMP  lib2decRet
                ;[File: my4th-rom_8MHz.asm]
                ;[File: input.asm]
                ;------------------------------------------------------------------------------
                ; Input (read a string from console / terminal)
                ;------------------------------------------------------------------------------
                
                call_vect_input:  ; call function v_keyb_input via a vector
                ;          TST  VECT_INPUT+2
                ;          JNF  INPUT_VECTOR
    34A7 1534             TST  LIB_BIGKEYB
    34A9 17C039           JNF  keyb_readkey
                ;          JMP  uart_recv
                
                inp_readkey:
                          ;call readkey over a vector (if any is set), 
                          ;only return when a key was pressed.
    34AC 1E               PHL
    34AD 1B12             PSH  R2
    34AF 1B13             PSH  R3
    34B1 1B14             PSH  R4_L
    34B3 1B15             PSH  R4_H
    34B5 1B0C             PSH  PTR_L
    34B7 1B0D             PSH  PTR_H
    34B9 1557             TST  VECT_INPUT+2
    34BB 16C934           JPF  _inprk01
    34BE 195580 _inprk02  JSR  INPUT_VECTOR
    34C1 150E             TST
    34C3 16BE34           JPF  _inprk02
    34C6 18CC34           JMP  _inprk03
    34C9 196D3C _inprk01  JSR  readkey
    34CC 1C0D   _inprk03  POP  PTR_H
    34CE 1C0C             POP  PTR_L
    34D0 1C15             POP  R4_H
    34D2 1C14             POP  R4_L
    34D4 1C13             POP  R3
    34D6 1C12             POP  R2
    34D8 1F               RTS
                
                forth_edlin:
                          ;input a line: R4=buffer, R5=default str, R0=bufsize
    34D9 1E               PHL
    34DA 021814           LD   R6_L,R4_L
    34DD 021915           LD   R6_H,R4_H
    34E0 011200           LD   R2,#0
    34E3 021110           LD   R1,R0
    34E6 0A11             DEC  R1
    34E8 19283B _edln01   JSR  ld_ptr_r5
    34EB 19033B           JSR  inc_r5
    34EE 05               LAP  
    34EF 192F3B           JSR  ld_ptr_r6
    34F2 150E             TST
    34F4 161135           JPF  _edln02
    34F7 190D3B           JSR  inc_r6
    34FA 07               SAP  
    34FB 192433           JSR  print_char
    34FE 0912             INC  R2
    3500 0412             LDA  R2
    3502 1340             CMP  #0x40
    3504 161135           JPF  _edln02
    3507 0A11             DEC  R1
    3509 1511             TST  R1
    350B 17E834           JNF  _edln01
    350E 19DA3A           JSR  inc_ptr
    3511 031B   _edln02   LDA  #0x1B
    3513 192433           JSR  print_char
    3516 035B             LDA  #0x5B
    3518 192433           JSR  print_char
    351B 19423B           JSR  psh_r4
    351E 021412           LD   R4_L,R2
    3521 011500           LD   R4_H,#0
    3524 19DF33           JSR  print_decword
    3527 0344             LDA  #0x44
    3529 192433           JSR  print_char
    352C 195B3B           JSR  pop_r4
    352F 011A00           LD   R7_L,#0
    3532 011100           LD   R1,#0
    3535 184435           JMP  _forth_inpstr
                
                input_string:
                          ;@API Input
                          ; Read a string from terminal (entered by user)
                          ; The read string will be terminated with a trailing zero, thus
                          ; a maximum of R0 - 1 characters can be entered on the terminal.
                          ; In: R0 = buffersize,
                          ;     R4_L,R4_H = ptr to destination buffer,
                          ; Out: entered string in destination buffer
                          ; Changes: ACCU, R0, R1, R2, R3, R5, R6, R7, PTR
    3538 1E               PHL
    3539 011200           LD   R2,#0      ; R2 = entered string length
    353C 153A             TST  LIB_LCDOUT
    353E 17FA35           JNF  _inputstr_lcd
    3541 011100           LD   R1,#0      ; R1 = cursor position
                _forth_inpstr:            ;This label is referenced by Forth user code, so DO NOT TOUCH the 7 lines above
    3544 19213B           JSR  ld_ptr_r4  ; R4 = ptr to beginning of input buffer
    3547 021310           LD   R3,R0      ; R3 = max buffer size
    354A 0A13             DEC  R3
    354C 185E80           JMP  INPSTR_VECTOR  ;will usually jump to input_str_loop
                
                input_str_loop:
                _inps01   ;input loop
    354F 1B11             PSH  R1
    3551 19AC34           JSR  inp_readkey
    3554 1C11             POP  R1
                
    3556 131F             CMP  #KCODE_LEFT
    3558 16CC35           JPF  _crsrL
    355B 131E             CMP  #KCODE_RIGHT
    355D 16E235           JPF  _crsrR
    3560 1308             CMP  #KCODE_BS
    3562 169535           JPF  _in_del
    3565 130D             CMP  #0x0D
    3567 16BA35           JPF  _in_ent
    356A 0610             STA  R0
    356C 0105E0           AND  #0xE0
    356F 0D05   
    3571 150E             TST
    3573 164F35           JPF  _inps01  ; character < 32, not printable
                          ;check if still space is in buffer
    3576 0411             LDA  R1
    3578 1413             CMP  R3
    357A 164F35           JPF  _inps01  ; no space left
                          ;write character into buffer and increment cursor position
    357D 0410             LDA  R0
    357F 19D93A           JSR  sap_inc_ptr
    3582 0411             LDA  R1
    3584 1412             CMP  R2
    3586 178B35           JNF  _inps03
    3589 0912             INC  R2
    358B 0911   _inps03   INC  R1
                          ;print character and loop
    358D 0410             LDA  R0
    358F 192433           JSR  print_char
    3592 184F35           JMP  _inps01
                
                _in_del   ;"Delete / Backspace" was pressed
                          ;delete works only at the end of the entered line
    3595 0411             LDA  R1
    3597 1412             CMP  R2
    3599 17CC35           JNF  _crsrL   ; do "cursor left"
                          ;remove last character from buffer
    359C 1511             TST  R1
    359E 164F35           JPF  _inps01  ; no character at left side of cursor
    35A1 0A11             DEC  R1
    35A3 0A12             DEC  R2
    35A5 19EF3A           JSR  dec_ptr
                          ;send ESC-sequence to delete a character and move cursor left
    35A8 193D3B           JSR  psh_ptr
    35AB 010CC8           LD   PTR_L,#<text_backsp
    35AE 010D79           LD   PTR_H,#>text_backsp
    35B1 194633 _inps04   JSR  print_str
    35B4 19563B           JSR  pop_ptr
    35B7 184F35           JMP  _inps01
                
                _in_ent   ;"ENTER" was pressed
                          ;append zero to the buffer and return
    35BA 0414             LDA  R4_L
    35BC 2412             AD   R2
    35BE 060C             STA  PTR_L
    35C0 020D15           LD   PTR_H,R4_H
    35C3 17C835           JNF  _inps07
    35C6 090D             INC  PTR_H
    35C8 0300   _inps07   LDA  #0
    35CA 07               SAP
    35CB 1F               RTS
                
                _crsrL    ;"Cursor left"
    35CC 1511             TST  R1
    35CE 164F35           JPF  _inps01  ; no character at left side of cursor
    35D1 0A11             DEC  R1
    35D3 19EF3A           JSR  dec_ptr
    35D6 193D3B           JSR  psh_ptr
    35D9 010CCC           LD   PTR_L,#<text_left
    35DC 010D79           LD   PTR_H,#>text_left
    35DF 18B135           JMP  _inps04
                
                _crsrR    ;"Cursor right"
    35E2 0411             LDA  R1
    35E4 1412             CMP  R2
    35E6 164F35           JPF  _inps01  ; cursor is already at right most position
    35E9 0911             INC  R1
    35EB 19DA3A           JSR  inc_ptr
    35EE 193D3B           JSR  psh_ptr
    35F1 010CD0           LD   PTR_L,#<text_right
    35F4 010D79           LD   PTR_H,#>text_right
    35F7 18B135           JMP  _inps04
                
                _inputstr_lcd:
                          ;input a string on the LCD
                          ;max. line length is 40 character
                          ;Input:
                          ;  R0 = buffer size
                          ;  R4 = ptr to beginning of the buffer
    35FA 0A10             DEC  R0
    35FC 021A3E           LD   R7_L,LIB_LCDPOSX ; R7_L = left x-position of input field
    35FF 0327             LDA  #39   ;right most screen position, this is 39 on a 40x4 LCD
    3601 251A             SU   R7_L
    3603 061B             STA  R7_H  ;R7_H = maximum length of the input string
    3605 2510             SU   R0
    3607 170D36           JNF  _inpl01
    360A 021B10           LD   R7_H,R0
                _inpl01   ;R7_L = left x-position of input field
                          ;R7_H = max. buffer length / input length
                          ;R4 = ptr to beginning of the buffer
                          ;R2 = cursor position
                          ;R3 = current length of the string
    360D 19213B           JSR  ld_ptr_r4
    3610 0300             LDA  #0
                          ;STA  R2   ;already set to zero in the code above (input_string)
    3612 0613             STA  R3
    3614 07               SAP
                
                _inpl02   ;print input buffer and position the cursor
    3615 041A             LDA  R7_L
    3617 19DD36           JSR  _inpl16
    361A 19213B           JSR  ld_ptr_r4
    361D 19CE3A _inpl04   JSR  lap_inc_ptr
    3620 150E             TST
    3622 162B36           JPF  _inpl03
    3625 193531           JSR  lcd_out_ch
    3628 181D36           JMP  _inpl04
    362B 0320   _inpl03   LDA  #0x20
    362D 193531           JSR  lcd_out_ch
                
                _inpl12   ;position the cursor
    3630 0412             LDA  R2
    3632 19DB36           JSR  _inpl15
                
                _inpl05   ;read next key
    3635 1B1A             PSH  R7_L
    3637 1B1B             PSH  R7_H
    3639 19AC34           JSR  inp_readkey
    363C 1C1B             POP  R7_H
    363E 1C1A             POP  R7_L
                
    3640 131F             CMP  #KCODE_LEFT
    3642 169636           JPF  _inpl06
    3645 131E             CMP  #KCODE_RIGHT
    3647 16A036           JPF  _inpl07
    364A 130D             CMP  #13
    364C 16E536           JPF  _inpl08
    364F 1308             CMP  #8
    3651 16AC36           JPF  _inpl09
                
                          ;check if character is printable
    3654 0611             STA  R1
    3656 03E0             LDA  #0xE0
    3658 0D11             AND  R1
    365A 150E             TST
    365C 163536           JPF  _inpl05
                          ;print it
                          ;1. check if there is "space" at the end of the line
    365F 0413             LDA  R3
    3661 141B             CMP  R7_H
    3663 163536           JPF  _inpl05  ;no space, ignore this keypress
                          ;2. move rest of the line to the right to insert space for the new character
    3666 0413             LDA  R3
    3668 2414             AD   R4_L
    366A 060C             STA  PTR_L
    366C 020D15           LD   PTR_H,R4_H
    366F 177436           JNF  _inpl10
    3672 090D             INC  PTR_H
    3674 0413   _inpl10   LDA  R3
    3676 2512             SU   R2
    3678 090E             INC   ;move also the terminating zero at the end of the string
    367A 0610             STA  R0
    367C 19CE3A _inpl11   JSR  lap_inc_ptr
    367F 07               SAP
    3680 19EF3A           JSR  dec_ptr
    3683 19EF3A           JSR  dec_ptr
    3686 207C36           JLP  _inpl11
                          ;3. write character into memory and print out the new line
    3689 19DA3A           JSR  inc_ptr
    368C 0411             LDA  R1
    368E 07               SAP
    368F 0912             INC  R2
    3691 0913             INC  R3
    3693 181536           JMP  _inpl02
                
                _inpl06   ;cursor left
    3696 1512             TST  R2
    3698 163536           JPF  _inpl05
    369B 0A12             DEC  R2
    369D 183036           JMP  _inpl12
                
                _inpl07   ;cursor right
    36A0 0412             LDA  R2
    36A2 1413             CMP  R3
    36A4 163536           JPF  _inpl05
    36A7 0912             INC  R2
    36A9 183036           JMP  _inpl12
                
                _inpl09   ;delete
    36AC 1512             TST  R2
    36AE 163536           JPF  _inpl05
    36B1 0412             LDA  R2
    36B3 2414             AD   R4_L
    36B5 060C             STA  PTR_L
    36B7 020D15           LD   PTR_H,R4_H
    36BA 17BF36           JNF  _inpl13
    36BD 090D             INC  PTR_H
    36BF 0413   _inpl13   LDA  R3
    36C1 2512             SU   R2
    36C3 0610             STA  R0
    36C5 0910             INC  R0  ;move also the terminating zero at the end of the string
    36C7 05     _inpl14   LAP
    36C8 19EF3A           JSR  dec_ptr
    36CB 19D93A           JSR  sap_inc_ptr
    36CE 19DA3A           JSR  inc_ptr
    36D1 20C736           JLP  _inpl14
    36D4 0A12             DEC  R2
    36D6 0A13             DEC  R3
    36D8 181536           JMP  _inpl02
                
                _inpl15   ;set cursor to offset in accu
    36DB 241A             AD   R7_L
    36DD 0610   _inpl16   STA  R0
    36DF 02113F           LD   R1,LIB_LCDPOSY
    36E2 18B631           JMP  lcd_gotoxy
                
                _inpl08   ;return
    36E5 0413             LDA  R3
    36E7 19DB36           JSR  _inpl15
    36EA 1F               RTS
                
                ;pr_nibble:
                ;          ; Print a single hex-nibble
                ;          ; In: nibble in ACCU
                ;          SU   #10
                ;          JPF  _prnib2
                ;          ADD  #3Ah
                ;          JMP  uart_xmit
                ;_prnib2   ADD  #40h
                ;          JMP  uart_xmit
                ;
                ;pr_hexbyte:
                ;          ;@API Printing
                ;          ; Print a byte in hexadecimal
                ;          ; In: byte in ACCU
                ;          ; Changes: ACCU
                ;          PHL
                ;          PSH  ACCU
                ;          CLC
                ;          ROR
                ;          CLC
                ;          ROR
                ;          CLC
                ;          ROR
                ;          CLC
                ;          ROR
                ;          JSR  pr_nibble
                ;          POP  ACCU
                ;          AND  #0Fh
                ;          JSR  pr_nibble
                ;          POP  LR_H
                ;          POP  LR_L
                ;          RET
                ;[File: my4th-rom_8MHz.asm]
                ;[File: eeprom.asm]
                ;------------------------------------------------------------------------------
                ; EEPROM Functions
                ;------------------------------------------------------------------------------
                ; 
                ; Possible board configurations:
                ;
                ; EEPROM Socket 1:
                ;     24LC512 : 0xA0
                ;     24LC1025: 0xA0 / 0xA8
                ;     24LC1026: 0xA0 / 0xA2
                ; 
                ; EEPROM Socket 2:
                ;     24LC512 : 0xA6
                ;     24LC1025: 0xA6 / 0xAE
                ;     24LC1026: 0xA4 / 0xA6
                ;
                ; If the board is populated with two 24LC512, and two more 24LC512 shall be
                ; connected, the these 24LC512 must have the addresses 0xAA and 0xAC.
                ;
                
                eeprom_init:
                          ; Initialize the EEPROM library.
                          ; Find all EEPROMs attached to the system.
    36EB 1E               PHL
    36EC 010C42           LD   PTR_L,#LIB_EEADDRS
    36EF 010D80           LD   PTR_H,#REGPAGE_HI
    36F2 011008           LD   R0,#8
    36F5 193B3C           JSR  memclr
    36F8 064A             STA  LIB_NUMPAGES+0
    36FA 064B             STA  LIB_NUMPAGES+1
                          ;test if an EEPROM is in socket 1
    36FC 011100           LD   R1,#0
    36FF 03A0             LDA  #0xA0
    3701 195538           JSR  eeprom_test
    3704 162C37           JPF  _eepin01
                          ;check if it is an 24LC512/24LC1025/24LC1026
    3707 0142A0           LD   LIB_EEADDRS+0,#0xA0
    370A 03A8             LDA  #0xA8
    370C 195538           JSR  eeprom_test
    370F 161B37           JPF  _eepin02
                          ;it is an 24LC1025
    3712 0143A8           LD   LIB_EEADDRS+1,#0xA8
    3715 011102           LD   R1,#2
    3718 182C37           JMP  _eepin01
                _eepin02  ;check for 24LC1026
    371B 03A2             LDA  #0xA2
    371D 195538           JSR  eeprom_test
    3720 011101           LD   R1,#1
    3723 162C37           JPF  _eepin01  ;it is an 24LC512
    3726 0143A2           LD   LIB_EEADDRS+1,#0xA2
    3729 011103           LD   R1,#3     ;it is an 24LC1026
                _eepin01  ;test socket 2
    372C 011200           LD   R2,#0
    372F 03A6             LDA  #0xA6
    3731 195538           JSR  eeprom_test
    3734 165F37           JPF  _eepin03
                          ;check if it is an 24LC512/24LC1025/24LC1026
    3737 0144A6           LD   LIB_EEADDRS+2,#0xA6
    373A 03AE             LDA  #0xAE
    373C 195538           JSR  eeprom_test
    373F 164B37           JPF  _eepin04
                          ;it is an 24LC1025
    3742 0145AE           LD   LIB_EEADDRS+3,#0xAE
    3745 011202           LD   R2,#2
    3748 185F37           JMP  _eepin03
                _eepin04  ;check for 24LC1026
    374B 03A4             LDA  #0xA4
    374D 195538           JSR  eeprom_test
    3750 011201           LD   R2,#1
    3753 165F37           JPF  _eepin03  ;it is an 24LC512
    3756 0144A4           LD   LIB_EEADDRS+2,#0xA4
    3759 0145A6           LD   LIB_EEADDRS+3,#0xA6
    375C 011203           LD   R2,#3     ;it is an 24LC1026
                _eepin03  ;all detected. Tighten the list of EEPROMs:
    375F 1542             TST  LIB_EEADDRS+0
    3761 177337           JNF  _eepin07
                          ;socket 1 is empty
    3764 024244           LD   LIB_EEADDRS+0,LIB_EEADDRS+2
    3767 024345           LD   LIB_EEADDRS+1,LIB_EEADDRS+3
    376A 014400           LD   LIB_EEADDRS+2,#0
    376D 014500           LD   LIB_EEADDRS+3,#0
    3770 188137           JMP  _eepin08
    3773 1543   _eepin07  TST  LIB_EEADDRS+1
    3775 178137           JNF  _eepin08
                          ;socket 1 has an 24LC512
    3778 024344           LD   LIB_EEADDRS+1,LIB_EEADDRS+2
    377B 024445           LD   LIB_EEADDRS+2,LIB_EEADDRS+3
    377E 014500           LD   LIB_EEADDRS+3,#0
                _eepin08  ;count the just found EEPROMs
    3781 010C42           LD   PTR_L,#LIB_EEADDRS
    3784 010D80           LD   PTR_H,#REGPAGE_HI
    3787 0A4A             DEC  LIB_NUMPAGES
    3789 094A   _eepin10  INC  LIB_NUMPAGES
    378B 19CE3A           JSR  lap_inc_ptr
    378E 150E             TST
    3790 178937           JNF  _eepin10
    3793 19EF3A           JSR  dec_ptr
                          ;now search for EEPROMs at the still untested addresses
                          ;in the range 0xA0 - 0xAF
                          ;PTR points to the end of the list of valid EEPROM addresses
    3796 011300           LD   R3,#0
    3799 0114A0           LD   R4,#0xA0
    379C 0414   _eepin12  LDA  R4
    379E 1442             CMP  LIB_EEADDRS+0
    37A0 16C137           JPF  _eepin09
    37A3 1443             CMP  LIB_EEADDRS+1
    37A5 16C137           JPF  _eepin09
    37A8 1444             CMP  LIB_EEADDRS+2
    37AA 16C137           JPF  _eepin09
    37AD 1445             CMP  LIB_EEADDRS+3
    37AF 16C137           JPF  _eepin09
    37B2 195538           JSR  eeprom_test
    37B5 16C137           JPF  _eepin09
    37B8 0414             LDA  R4
    37BA 19D93A           JSR  sap_inc_ptr
    37BD 094A             INC  LIB_NUMPAGES
    37BF 0913             INC  R3
    37C1 0914   _eepin09  INC  R4
    37C3 0914             INC  R4
    37C5 0414             LDA  R4
    37C7 13B0             CMP  #0xB0
    37C9 179C37           JNF  _eepin12
                          ;calculate overall size
    37CC 23               CLC
    37CD 011006           LD   R0,#6
    37D0 214A   _eepin11  RWL  LIB_NUMPAGES
    37D2 20D037           JLP  _eepin11
                          ;print list of detected EEPROMs
                          PRINT text_eeproms1
    37D5 198633           JSR  printstrm
    37D8 E5               DB   <text_eeproms1
    37D9 79               DB   >text_eeproms1
    37DA 1513             TST  R3
    37DC 16E837           JPF  _eepin13
    37DF 190C38           JSR  _eepin14
                          PRINT text_eeproms3
    37E2 198633           JSR  printstrm
    37E5 F9               DB   <text_eeproms3
    37E6 79               DB   >text_eeproms3
                ;   JMP _eepin21
    37E7 1F               RTS
    37E8 021011 _eepin13  LD   R0,R1
    37EB 191538           JSR  printEepromName
    37EE 032C             LDA  #','
    37F0 192433           JSR  print_char
    37F3 021012           LD   R0,R2
    37F6 191538           JSR  printEepromName
    37F9 0320             LDA  #' '
    37FB 192433           JSR  print_char
    37FE 0328             LDA  #'('
    3800 192433           JSR  print_char
    3803 190C38           JSR  _eepin14
                          PRINT text_eeproms2
    3806 198633           JSR  printstrm
    3809 EF               DB   <text_eeproms2
    380A 79               DB   >text_eeproms2
                ;      ;print all device addresses
                ;_eepin21 LD   PTR_L,#LIB_EEADDRS
                ;         LD   PTR_H,#REGPAGE_HI
                ;         LD   R0,#8
                ;_eepin20 JSR  lap_inc_ptr
                ;         JSR  print_hexbyte
                ;         JSR  print_space
                ;         JLP  _eepin20
                ;         JSR  print_nl
                ;      ;end    
    380B 1F               RTS
    380C 02144A _eepin14  LD   R4_L,LIB_NUMPAGES+0
    380F 02154B           LD   R4_H,LIB_NUMPAGES+1
    3812 18DF33           JMP  print_decword
                
                printEepromName:
                          ;R0 = index to the list of EEPROM names
                          ; IDs for EEPROMs:  1 = 24LC512, 2 = 24LC1025, 3 = 24LC1026
    3815 1E               PHL
    3816 010C08           LD   PTR_L,#<text_eeplist
    3819 010D7A           LD   PTR_H,#>text_eeplist
    381C 1510             TST  R0
    381E 162C38           JPF  _peen01
    3821 19CE3A _peen02   JSR  lap_inc_ptr
    3824 150E             TST
    3826 172138           JNF  _peen02
    3829 202138           JLP  _peen02
    382C 194633 _peen01   JSR  print_str
    382F 1F               RTS
                
                fblockToEepromAddr:
                          ;Convert a Forth Block Number to an
                          ;EEPROM device- and memory address
                          ;Input:  R4 = Forth Block Number
                          ;Output: ACCU/LIB_EEPADDR = EEPROM device address, R4 = memory address, Flag = 0
                          ;Changes: R0, R4, PTR
    3830 0414             LDA  R4_L
    3832 254A             SU   LIB_NUMPAGES
    3834 0415             LDA  R4_H
    3836 114B             SUB  LIB_NUMPAGES+1
    3838 16CD3A           JPF  ret_opc
    383B 0300             LDA  #0
    383D 01100A           LD   R0,#10
    3840 2114   _fbtea01  RWL  R4
    3842 0B0E             ROL  ACCU
    3844 204038           JLP  _fbtea01
    3847 010542           AD   #LIB_EEADDRS
    384A 2405   
    384C 060C             STA  PTR_L
    384E 010D80           LD   PTR_H,#REGPAGE_HI
    3851 05               LAP
    3852 0641             STA  LIB_EEPADDR
    3854 1A               RET  ;return with flag = 0
                
                eeprom_test:
                          ; Test if an EEPROM is present.
                          ; In : ACCU = EEPROM address
                          ; Out: FLAG = 0 when eeprom is present
    3855 1E               PHL
    3856 0610             STA  R0
    3858 1B11             PSH  R1
    385A 19F62D           JSR  i2c_start_addr
    385D 19DE2D           JSR  i2c_stop
    3860 1C11             POP  R1
    3862 1F               RTS
                
                eeprom_start_write:
                          ;@API EEPROM
                          ; Start a write-transfer.
                          ; In : R4 : 16-bit EEPROM write address
                          ; Out: FLAG = 0 on success
                          ; Changes: ACCU, R0, R1
    3863 1E               PHL
    3864 021041           LD   R0,LIB_EEPADDR
    3867 19F62D           JSR  i2c_start_addr
    386A 167F38           JPF  _eepstw2  ; error
    386D 021115 _eepstw3  LD   R1,R4_H
    3870 19042E           JSR  i2c_send
    3873 167F38           JPF  _eepstw2  ; error
    3876 021114           LD   R1,R4_L
    3879 19042E           JSR  i2c_send
    387C 17CA3A           JNF  return
    387F 19DE2D _eepstw2  JSR  i2c_stop
    3882 22               SEC
    3883 1F               RTS
                
                eeprom_start_write_ackpoll:
                          ;@API EEPROM
                          ; Start a write-transfer, but wait until
                          ; previous write has been completed in the EEPROM.
                          ; In : R4 : 16-bit EEPROM write address
                          ; Out: FLAG = 0 on success
                          ; Changes: ACCU, R0, R1
    3884 1E               PHL
    3885 19A72D _eepstw4  JSR  i2c_start
    3888 17CB3A           JNF  return_flag_1
    388B 021141           LD   R1,LIB_EEPADDR
    388E 19042E           JSR  i2c_send
    3891 176D38           JNF  _eepstw3  ; ok, device is ready again
    3894 19DE2D           JSR  i2c_stop
    3897 188538           JMP  _eepstw4
                
                eeprom_start_read:
                          ;@API EEPROM
                          ; Start a read-transfer.
                          ; In : R4 : 16-bit EEPROM read address
                          ; Out: R6/R7 contain prepared data for the I2C transfer
                          ;      FLAG = 0 on success
                          ; Changes: ACCU, R0, R1, R6, R7
    389A 1E               PHL
    389B 196338           JSR  eeprom_start_write
    389E 16CA3A           JPF  return ;error
    38A1 021041           LD   R0,LIB_EEPADDR
    38A4 0910             INC  R0
    38A6 19F62D           JSR  i2c_start_addr
    38A9 1F               RTS          
                
                eeprom_read_block:
                          ;@API EEPROM
                          ; Read a block of data into memory.
                          ; In: PTR = ptr to destination memory
                          ;     R5 = number of bytes to read (16 bit)
                          ; Changes: ACCU, R0, R1, R5, PTR
    38AA 1E               PHL
    38AB 011100           LD   R1,#0
    38AE 1516             TST  R5_L
    38B0 17BA38           JNF  _eeprb04
    38B3 1517             TST  R5_H
    38B5 16CA3A           JPF  return
    38B8 0A17             DEC  R5_H
    38BA 0A16   _eeprb04  DEC  R5_L
                          ;load n-1 bytes
    38BC 1516   _eeprb01  TST  R5_L
    38BE 17C838           JNF  _eeprb02
    38C1 1517             TST  R5_H
    38C3 16DA38           JPF  _eeprb03
    38C6 0A17             DEC  R5_H
    38C8 0A16   _eeprb02  DEC  R5_L
    38CA 192E2E           JSR  i2c_recv
    38CD 07               SAP
    38CE 090C             INC  PTR_L
    38D0 150C             TST  PTR_L
    38D2 17BC38           JNF  _eeprb01
    38D5 090D             INC  PTR_H
    38D7 18BC38           JMP  _eeprb01
                _eeprb03  ;last byte
    38DA 011101           LD   R1,#1
    38DD 192E2E           JSR  i2c_recv
    38E0 19D93A           JSR  sap_inc_ptr
    38E3 1F               RTS
                
                eeprom_write_block:
                          ; Write a block of data to EEPROM.
                          ; NOTE: Do not write over page-boundaries of 128 byte!
                          ;       After calling this function (or when the end
                          ;       of a page was reached), eeprom_stop must be called!
                          ; In : PTR = ptr to source memory
                          ;      R2  = number of bytes to write (max 128!)
                          ; Out: FLAG = 0 on success
                          ; Changes: ACCU, R0, R1, R2, PTR
    38E4 1E               PHL
    38E5 05     _eepwb01  LAP
    38E6 090C             INC  PTR_L
    38E8 150C             TST  PTR_L
    38EA 17EF38           JNF  _eepwb02
    38ED 090D             INC  PTR_H
    38EF 0611   _eepwb02  STA  R1
    38F1 19042E           JSR  i2c_send
    38F4 16CA3A           JPF  return  ; error
    38F7 0A12             DEC  R2
    38F9 1512             TST  R2
    38FB 17E538           JNF  _eepwb01
    38FE 23               CLC
    38FF 1F               RTS
                
                eeprom_stop:
                          ;@API EEPROM
                          ; Stop a EEPROM transaction
                          ; Changes: ACCU
    3900 18DE2D           JMP  i2c_stop
                
                eeprom_stop_ret:
    3903 190039           JSR  eeprom_stop
    3906 1F               RTS
                
                eeprom_read_forth_block:
                          ;Read a Forth block from EEPROM to memory
                          ;Input:  R4 = Forth Block Number, R5 = memory destination address
                          ;Output: FLAG = 0 on success
                          ;Changes: All registers
    3907 1E               PHL
    3908 193038           JSR  fblockToEepromAddr
    390B 16CA3A           JPF  return
    390E 199A38           JSR  eeprom_start_read
    3911 16CA3A           JPF  return
    3914 19283B           JSR  ld_ptr_r5
    3917 011600           LD   R5_L,#0
    391A 011704           LD   R5_H,#4
    391D 19AA38           JSR  eeprom_read_block
    3920 190039           JSR  eeprom_stop
    3923 23               CLC
    3924 1F               RTS
                
                eeprom_write_forth_block:
                          ;Write a Forth block from memory to EEPROM
                          ;Input:  R4 = Forth Block Number, R5 = memory source address
                          ;Output: FLAG = 0 on success
                          ;Changes: All registers
    3925 1E               PHL
    3926 193038           JSR  fblockToEepromAddr
    3929 16CA3A           JPF  return
    392C 19283B           JSR  ld_ptr_r5
    392F 011608           LD   R5_L,#8   ; 8 blocks of 128 bytes = 1024 bytes to write
                          ;R4 = 16-bit EEPROM address
    3932 198438 _ewfb01   JSR  eeprom_start_write_ackpoll
    3935 16CA3A           JPF  return  ; error
    3938 011280           LD   R2,#128
    393B 19E438           JSR  eeprom_write_block
    393E 1B0F             PSH  FLAG
    3940 190039           JSR  eeprom_stop
    3943 1C0F             POP  FLAG
    3945 16CA3A           JPF  return  ; error
    3948 0380             LDA  #128
    394A 2414             AD   R4_L
    394C 0614             STA  R4_L
    394E 175339           JNF  _ewfb02
    3951 0915             INC  R4_H
    3953 0A16   _ewfb02   DEC  R5_L
    3955 1516             TST  R5_L
    3957 173239           JNF  _ewfb01
    395A 23               CLC
    395B 1F               RTS
                
                ;[File: my4th-rom_8MHz.asm]
                ;[File: keyboard.asm]
                ;------------------------------------------------------------------------------
                ; Keyboard functions
                ;------------------------------------------------------------------------------
                
                
                
                keyboard_init:
                          ; Detect the installed keyboard
    395C 1E               PHL
    395D 013400           LD   LIB_BIGKEYB,#0
    3960 0114F0           LD   R4_L,#0xF0
    3963 01153F           LD   R4_H,#0x3F
    3966 198739           JSR  output_m
    3969 1D               IN
    396A 0B0E             ROL
    396C 167F39           JPF  _init_smallkeyb
    396F 0115BF           LD   R4_H,#0xBF
    3972 198739           JSR  output_m
    3975 1D               IN
    3976 0B0E             ROL
    3978 177F39           JNF  _init_smallkeyb
                
                _init_bigkeyb:
                          ;successfully detected the big keyboard with 4x40 LCD
    397B 013401           LD   LIB_BIGKEYB,#1
    397E 1F               RTS
                
                _init_smallkeyb
                          ;small or no keyboard installed
    397F 013400           LD   LIB_BIGKEYB,#0
    3982 1F               RTS
                
                keyboard_term:
    3983 013400           LD   LIB_BIGKEYB,#0
    3986 1A               RET
                
                output_m:
                          ; Output the eight M-bits on the additional 74HC574 on the keyboard
                          ; and output OUT3-OUT7 on the output port.
                          ; In: R4_L bits 3-7 = OUT3-OUT7, R4_H bits 0-7 = M-bits
                          ; Changes: ACCU
    3987 03F0             LDA  #0xF0
    3989 0D15             AND  R4_H
    398B 0605             STA  PAR1
    398D 030B             LDA  #0x0B  ;SCL = low 
    398F 0D1C             AND  OUTP
    3991 061C             STA  OUTP
    3993 0E05             OR   PAR1
    3995 260E             OUT
    3997 010504           OR   #0x04  ;SCL = high
    399A 0E05   
    399C 260E             OUT
    399E 0415             LDA  R4_H
    39A0 23               CLC
    39A1 0B0E             ROL
    39A3 23               CLC
    39A4 0B0E             ROL
    39A6 23               CLC
    39A7 0B0E             ROL
    39A9 23               CLC
    39AA 0B0E             ROL
    39AC 0E1C             OR   OUTP   ;SCL = low 
    39AE 260E             OUT
    39B0 010504           OR   #0x04  ;SCL = high
    39B3 0E05   
    39B5 260E             OUT
    39B7 0414             LDA  R4_L
    39B9 0E1C             OR   OUTP   ;SCL = low 
    39BB 260E             OUT
    39BD 061C             STA  OUTP
    39BF 1A               RET
                
                keyb_readkey:
                          ; Read the keyboard (if any is installed).
                          ; Out: ACCU = key code or 0 if no button was pressed.
                          ;      See KC_xxx - defines in keydefs.hsm for details.
                          ; Changes: ACCU, R0, PTR
    39C0 09A4             INC  RANDVAR
    39C2 1534             TST  LIB_BIGKEYB
    39C4 16693A           JPF  readkey_3x5
                
                          ;read the big keyboard here
    39C7 1E               PHL
    39C8 1B14             PSH  R4_L
    39CA 1B15             PSH  R4_H
                          ;Test if any key is pressed. Exit early if not.
    39CC 011400           LD   R4_L,#0x00
    39CF 0115A0           LD   R4_H,#0xA0
    39D2 198739           JSR  output_m
    39D5 1D               IN
    39D6 0106FC           LD   PAR2,#0xFC
    39D9 0D06             AND  PAR2
    39DB 13FC             CMP  #0xFC
    39DD 16593A           JPF  _rdbk05  ;no key pressed
                          ;test if no key was pressed within last 8 polls (debounce keyboard)
    39E0 153D             TST  LIB_KBNOKEYB
    39E2 013DFF           LD   LIB_KBNOKEYB,#0xFF
    39E5 16FC39           JPF  _rdbk08
                          ;a key is still pressed,
                          ;maintain the key-repeat-counter
    39E8 1535             TST  LIB_KEYREPC+0
    39EA 17F439           JNF  _rdbk09
    39ED 1536             TST  LIB_KEYREPC+1
    39EF 16F939           JPF  _rdbk10 
    39F2 0A36             DEC  LIB_KEYREPC+1
    39F4 0A35   _rdbk09   DEC  LIB_KEYREPC+0
    39F6 18623A           JMP  _rdbk06 ;some key was already pressed, ignore this keystroke and re-start debouncing
    39F9 013532 _rdbk10   LD   LIB_KEYREPC+0,#50
                
                _rdbk08   ;scan all key rows, begin with OUT4
    39FC 0114E0           LD   R4_L,#0xE0
    39FF 0115BF           LD   R4_H,#0xBF
    3A02 011009           LD   R0,#9
    3A05 198739 _rdbk01   JSR  output_m
    3A08 1D               IN
    3A09 0D06             AND  PAR2
    3A0B 13FC             CMP  #0xFC
    3A0D 17283A           JNF  _rdbk02  ;some key is pressed
                          ;scan next row
    3A10 23               CLC
    3A11 2114             RWL  R4
    3A13 0310             LDA  #0x10
    3A15 0E14             OR   R4_L
    3A17 0614             STA  R4_L
    3A19 03C0             LDA  #0xC0
    3A1B 0F15             XOR  R4_H
    3A1D 0615             STA  R4_H
    3A1F 20053A           JLP  _rdbk01
                          ;no key pressed, may be shift was pressed, but ignore it.
    3A22 013D00           LD   LIB_KBNOKEYB,#0
    3A25 18623A           JMP  _rdbk06
    3A28 0A10   _rdbk02   DEC  R0
                          ;R0 = row
                          ;find the column now and
                          ;add column-number (0 to 5) to (row number * 8)
    3A2A 0606             STA  PAR2
    3A2C 0B10             ROL  R0
    3A2E 0B10             ROL  R0
    3A30 0B10             ROL  R0
    3A32 0A10             DEC  R0
    3A34 0910   _rdbk03   INC  R0
    3A36 0B06             ROL  PAR2
    3A38 16343A           JPF  _rdbk03
                          ;check the shift-key status, choose other table if shift is pressed
    3A3B 0114F0           LD   R4_L,#0xF0
    3A3E 0115FF           LD   R4_H,#0xFF
    3A41 198739           JSR  output_m
    3A44 1D               IN
    3A45 0B0E             ROL
    3A47 0300             LDA  #<TAB_KEYNORM
    3A49 164E3A           JPF  _rdbk04
    3A4C 0380             LDA  #<TAB_KEYSHIFT
                _rdbk04   ;translate the code
    3A4E 0E10             OR   R0
    3A50 060C             STA  PTR_L
    3A52 010D7D           LD   PTR_H,#>TAB_KEYNORM
    3A55 05               LAP
                          ;return key-code in ACCU
    3A56 18643A           JMP  _rdbk07
    3A59 013578 _rdbk05   LD   LIB_KEYREPC+0,#120
    3A5C 013601           LD   LIB_KEYREPC+1,#1
    3A5F 23               CLC
    3A60 0B3D             ROL  LIB_KBNOKEYB
    3A62 0300   _rdbk06   LDA  #0
    3A64 1C15   _rdbk07   POP  R4_H
    3A66 1C14             POP  R4_L
    3A68 1F               RTS
                
                readkey_3x5:
                          ; Read the 3x5 keyboard on the LCD Extension Board.
    3A69 030F             LDA  #0x0F
    3A6B 0D1C             AND  OUTP
    3A6D 260E             OUT
    3A6F 0105F0           OR   #0xF0
    3A72 0E05   
    3A74 061C             STA  OUTP
    3A76 0105FC           LD   PAR1,#0xFC
                          ;Test if any key is pressed. Exit early if not.
    3A79 1D               IN
    3A7A 0D05             AND  PAR1
    3A7C 13FC             CMP  #0xFC
    3A7E 17873A           JNF  _kbgk06
    3A81 23               CLC
    3A82 0B3D   _kbgk07   ROL  LIB_KBNOKEYB
    3A84 0300   _kbgk08   LDA  #0
    3A86 1A               RET
                _kbgk06   ;test if no key was pressed within last 8 polls (debounce keyboard)
    3A87 153D             TST  LIB_KBNOKEYB
    3A89 013DFF           LD   LIB_KBNOKEYB,#0xFF
    3A8C 17843A           JNF  _kbgk08 ;some key was already pressed, ignore this keystroke and re-start debouncing
                          ;scan all keys because at least one key must be pressed now
    3A8F 0106EF           LD   PAR2,#0xEF
    3A92 0110FF           LD   R0,#0xFF
    3A95 041C   _kbgk01   LDA  OUTP
    3A97 0D06             AND  PAR2
    3A99 260E             OUT
    3A9B 0910             INC  R0
    3A9D 1D               IN
    3A9E 0D05             AND  PAR1
    3AA0 13FC             CMP  #0xFC
    3AA2 17AD3A           JNF  _kbgk02
    3AA5 0B06             ROL  PAR2
    3AA7 16953A           JPF  _kbgk01
    3AAA 18823A           JMP  _kbgk07
                _kbgk02   ;add column-number (0 to 5) to (row number * 8)
    3AAD 0606             STA  PAR2
    3AAF 0B10             ROL  R0
    3AB1 0B10             ROL  R0
    3AB3 0B10             ROL  R0
    3AB5 0A10             DEC  R0
    3AB7 0910   _kbgk05   INC  R0
    3AB9 0B06             ROL  PAR2
    3ABB 16B73A           JPF  _kbgk05
                          ;translate the code
    3ABE 0360             LDA  #<TAB_KEYDECODE
    3AC0 0E10             OR   R0
    3AC2 060C             STA  PTR_L
    3AC4 010D7D           LD   PTR_H,#>TAB_KEYDECODE
    3AC7 05               LAP
                          ;return key-code in ACCU (see KC_xx defines)
    3AC8 1A               RET
                
                
                ;pr_nibble:
                ;          ; Print a single hex-nibble
                ;          ; In: nibble in ACCU
                ;          SU   #10
                ;          JPF  _prnib2
                ;          ADD  #3Ah
                ;          JMP  uart_xmit
                ;_prnib2   ADD  #40h
                ;          JMP  uart_xmit
                ;
                ;pr_hexbyte:
                ;          ;@API Printing
                ;          ; Print a byte in hexadecimal
                ;          ; In: byte in ACCU
                ;          ; Changes: ACCU
                ;          PHL
                ;          PSH  ACCU
                ;          CLC
                ;          ROR
                ;          CLC
                ;          ROR
                ;          CLC
                ;          ROR
                ;          CLC
                ;          ROR
                ;          JSR  pr_nibble
                ;          POP  ACCU
                ;          AND  #0Fh
                ;          JSR  pr_nibble
                ;          POP  LR_H
                ;          POP  LR_L
                ;          RET
                ;[File: my4th-rom_8MHz.asm]
                ;[File: misc.asm]
                ;------------------------------------------------------------------------------
                ; Misc Functions
                ;------------------------------------------------------------------------------
                
                return_flag_0:
                          ;@API Misc
                          ; Pull return-address from stack and return to caller. Set FLAG to 0.
                          ; Changes: LR
    3AC9 23               CLC
                
                return:   ;@API Misc
                          ; Pull return-address from stack and return to caller
                          ; Changes: LR
                
                rts_opc:  ;@API Misc
                          ; Return to caller (single RTS OP-Code)
    3ACA 1F               RTS
                
                return_flag_1:
                          ;@API Misc
                          ; Pull return-address from stack and return to caller. Set FLAG to 1.
                          ; Changes: LR
    3ACB 22               SEC
    3ACC 1F               RTS
                
                ret_opc:  ;@API Misc
                          ; Return to caller (single RET OP-Code)
    3ACD 1A               RET
                
                ;request_romversion:
                ;          ;@API Misc
                ;          ; Request a specific ROM version. This function checks if the requested
                ;          ; or a later ROM version is installed. If not, an error message is printed
                ;          ; and the CPU is halted.
                ;          ; In: ACCU = required ROM version: bits 7-4 = major version number, bits 3-0 = minor version number
                ;          ; Changes: ACCU
                ;          STA  PAR1
                ;          LDA  #0x12
                ;          SU   PAR1
                ;          JPF  ret_opc
                ;          LD   PTR_L,#<text_err_ver
                ;          LD   PTR_H,#>text_err_ver
                
                ;update_crc:
                ;          ;@API Misc
                ;          ; Update CRC-value in R4 with value in ACCU
                ;          ; In:  CRC-value in R4, byte in ACCU
                ;          ; Out: updated CRC-value in R4
                ;          ; Changes: ACCU, PTR
                ;          XOR  R4_H
                ;          STA  PTR_L
                ;          LD   PTR_H,#>TAB_CRC16HI
                ;          LAP
                ;          XOR  R4_L
                ;          STA  R4_H
                ;          LD   PTR_H,#>TAB_CRC16LO
                ;          LAP
                ;          STA  R4_L
                ;          RET
                ;
                
                ;get_cpuspeed:
                ;          ;@API Misc
                ;          ; Tests if the CPU is clocked with 4 MHz or with 8 MHz.
                ;          ; Out: FLAG = 1 when CPU frequency is 4 MHz, FLAG = 0 when CPU frequency is 8 MHz.
                ;          TST  LIB_CPUSPEED
                ;          RET
                
                ;delay_2m5:
                ;          ;@API Misc
                ;          ; Delay program execution for 2.5 ms
                ;          ; Changes: ACCU
                ;          TST  LIB_CPUSPEED
                ;          JNF  _dlay8
                ;          LDA  #26
                ;_dlay6    DEC
                ;          TST
                ;          JNF  _dlay6
                ;          RET
                ;_dlay8    LDA  #53
                ;_dlay7    DEC
                ;          TST
                ;          JNF  _dlay7
                ;          STA  PAR1
                ;          ROR  PAR1
                ;          RET
                
                ;delay_1s:
                ;          ;@API Misc
                ;          ; Delay program execution for 1 second
                ;          ; Changes: ACCU
                ;          LDA  #100
                ;delay:
                ;          ;@API Misc
                ;          ; Delay program execution in steps of 10ms
                ;          ; In: ACCU = time in steps of 10ms (set ACCU to 100 for 1 second delay)
                ;          ; Changes: ACCU
                ;          STA  PAR2
                ;          TST  LIB_CPUSPEED
                ;          JNF  _dlay3
                ;          ;delay loop for 4MHz clock
                ;_dlay1    LDA  #108
                ;_dlay2    DEC
                ;          TST
                ;          JNF  _dlay2
                ;          DEC  PAR2
                ;          TST  PAR2
                ;          JNF  _dlay1
                ;          RET
                ;          ;delay loop for 8MHz clock
                ;_dlay3    LDA  #216
                ;_dlay5    DEC
                ;          TST
                ;          JNF  _dlay5
                ;          DEC  PAR2
                ;          TST  PAR2
                ;          JNF  _dlay3
                ;          RET
                
                lap_inc_ptr:
                          ;@API Registers
                          ; Load ACCU and increment PTR afterwards
                          ; In:  PTR = pointer to data
                          ; Out: ACCU = value from memory where PTR has pointed to
                          ;      PTR = old pointer incremented by one
                          ; Changes ACCU, PTR
    3ACE 05               LAP
    3ACF 090C             INC  PTR_L
    3AD1 150C             TST  PTR_L
    3AD3 17CD3A           JNF  ret_opc
    3AD6 090D             INC  PTR_H
    3AD8 1A               RET
                
                sap_inc_ptr:
                          ;@API Registers
                          ; Store ACCU and increment PTR afterwards
                          ; In:  PTR = pointer to memory cell where data shall be written to
                          ;      ACCU = data byte
                          ; Out: PTR = old pointer incremented by one
                          ; Changes PTR
    3AD9 07               SAP
                
                inc_ptr:  ;@API Registers
                          ; Increment PTR register by one
                          ; In:  PTR
                          ; Out: PTR = old pointer incremented by one
                          ; Changes PTR
    3ADA 090C             INC  PTR_L
    3ADC 150C             TST  PTR_L
    3ADE 17CD3A           JNF  ret_opc
    3AE1 090D             INC  PTR_H
    3AE3 1A               RET
                
                inc_ptr_lap:
                          ;@API Registers
                          ; Increment PTR first and then load ACCU
                          ; In:  PTR = memory pointer
                          ; Out: PTR = old pointer incremented by one
                          ;      ACCU = data from memory cell where incremented PTR points to
                          ; Changes PTR
    3AE4 090C             INC  PTR_L
    3AE6 150C             TST  PTR_L
    3AE8 17ED3A           JNF  _incptla
    3AEB 090D             INC  PTR_H
    3AED 05     _incptla  LAP
    3AEE 1A               RET
                
                dec_ptr:  ;@API Registers
                          ; Decrement PTR register by one
                          ; In:  PTR
                          ; Out: PTR = old pointer decremented by one
                          ; Changes PTR
    3AEF 150C             TST  PTR_L
    3AF1 17F63A           JNF  _decpt1
    3AF4 0A0D             DEC  PTR_H
    3AF6 0A0C   _decpt1   DEC  PTR_L
    3AF8 1A               RET
                
                inc_r4:   ;@API Registers
                          ; Increment R4 register (16-bit) by one
                          ; In:  R4
                          ; Out: R4 = old R4 incremented by one
                          ; Changes: R4
    3AF9 0914             INC  R4_L
    3AFB 1514             TST  R4_L
    3AFD 17CD3A           JNF  ret_opc
    3B00 0915             INC  R4_H
    3B02 1A               RET
                
                inc_r5:   ;@API Registers
                          ; Increment R5 register (16-bit) by one
                          ; In:  R5
                          ; Out: R5 = old R5 incremented by one
                          ; Changes: R5
    3B03 0916             INC  R5_L
    3B05 1516             TST  R5_L
    3B07 17CD3A           JNF  ret_opc
    3B0A 0917             INC  R5_H
    3B0C 1A               RET
                
                inc_r6:   ;@API Registers
                          ; Increment R6 register (16-bit) by one
                          ; In:  R6
                          ; Out: R6 = old R6 incremented by one
                          ; Changes: R6
    3B0D 0918             INC  R6_L
    3B0F 1518             TST  R6_L
    3B11 17CD3A           JNF  ret_opc
    3B14 0919             INC  R6_H
    3B16 1A               RET
                
                inc_r7:   ;@API Registers
                          ; Increment R7 register (16-bit) by one
                          ; In:  R7
                          ; Out: R7 = old R7 incremented by one
                          ; Changes: R7
    3B17 091A             INC  R7_L
    3B19 151A             TST  R7_L
    3B1B 17CD3A           JNF  ret_opc
    3B1E 091B             INC  R7_H
    3B20 1A               RET
                
                ld_ptr_r4:
                          ;@API Registers
                          ; Load PTR with value in R4
                          ; In:  R4
                          ; Out: PTR = R4
                          ; Changes: PTR
    3B21 020C14           LD   PTR_L,R4_L
    3B24 020D15           LD   PTR_H,R4_H
    3B27 1A               RET
                
                ld_ptr_r5:
                          ;@API Registers
                          ; Load PTR with value in R5
                          ; In:  R5
                          ; Out: PTR = R5
                          ; Changes: PTR
    3B28 020C16           LD   PTR_L,R5_L
    3B2B 020D17           LD   PTR_H,R5_H
    3B2E 1A               RET
                
                ld_ptr_r6:
                          ;@API Registers
                          ; Load PTR with value in R6
                          ; In:  R6
                          ; Out: PTR = R6
                          ; Changes: PTR
    3B2F 020C18           LD   PTR_L,R6_L
    3B32 020D19           LD   PTR_H,R6_H
    3B35 1A               RET
                
                ld_ptr_r7:
                          ;@API Registers
                          ; Load PTR with value in R7
                          ; In:  R7
                          ; Out: PTR = R7
                          ; Changes: PTR
    3B36 020C1A           LD   PTR_L,R7_L
    3B39 020D1B           LD   PTR_H,R7_H
    3B3C 1A               RET
                
                psh_ptr:  ;@API Registers
                          ; Push PTR on the stack
                          ; In: PTR
    3B3D 1B0C             PSH  PTR_L
    3B3F 1B0D             PSH  PTR_H
    3B41 1A               RET
                
                psh_r4:   ;@API Registers
                          ; Push R4 (16-bit) on the stack
                          ; In: R4
    3B42 1B14             PSH  R4_L
    3B44 1B15             PSH  R4_H
    3B46 1A               RET
                
                psh_r5:   ;@API Registers
                          ; Push R5 (16-bit) on the stack
                          ; In: R5
    3B47 1B16             PSH  R5_L
    3B49 1B17             PSH  R5_H
    3B4B 1A               RET
                
                psh_r6:   ;@API Registers
                          ; Push R6 (16-bit) on the stack
                          ; In: R6
    3B4C 1B18             PSH  R6_L
    3B4E 1B19             PSH  R6_H
    3B50 1A               RET
                
                psh_r7:   ;@API Registers
                          ; Push R7 (16-bit) on the stack
                          ; In: R7
    3B51 1B1A             PSH  R7_L
    3B53 1B1B             PSH  R7_H
    3B55 1A               RET
                
                pop_ptr:  ;@API Registers
                          ; Poll PTR from the stack
                          ; Out: PTR
                          ; Changes: PTR
    3B56 1C0D             POP  PTR_H
    3B58 1C0C             POP  PTR_L
    3B5A 1A               RET
                
                pop_r4:   ;@API Registers
                          ; Poll R4 (16-bit) from the stack
                          ; Out: R4
                          ; Changes: R4
    3B5B 1C15             POP  R4_H
    3B5D 1C14             POP  R4_L
    3B5F 1A               RET
                
                pop_r5:   ;@API Registers
                          ; Poll R5 (16-bit) from the stack
                          ; Out: R5
                          ; Changes: R5
    3B60 1C17             POP  R5_H
    3B62 1C16             POP  R5_L
    3B64 1A               RET
                
                pop_r6:   ;@API Registers
                          ; Poll R6 (16-bit) from the stack
                          ; Out: R6
                          ; Changes: R6
    3B65 1C19             POP  R6_H
    3B67 1C18             POP  R6_L
    3B69 1A               RET
                
                pop_r7:   ;@API Registers
                          ; Poll R7 (16-bit) from the stack
                          ; Out: R7
                          ; Changes: R7
    3B6A 1C1B             POP  R7_H
    3B6C 1C1A             POP  R7_L
    3B6E 1A               RET
                
                is_digit:
                          ;@API Checkers
                          ; Check if ACCU contains a valid digit ('0' - '9')
                          ; In:  ACCU = ASCII character
                          ; Out: Returns with cleared FLAG when ACCU contains a digit.
    3B6F 1B0E             PSH  ACCU
    3B71 010530           SU   #'0'
    3B74 2505   
    3B76 17813B           JNF  _isdig01
    3B79 01050A           SUB  #10
    3B7C 1105   
    3B7E 1C0E             POP  ACCU
    3B80 1A               RET
    3B81 22     _isdig01  SEC
    3B82 1C0E             POP  ACCU
    3B84 1A               RET
                
                is_alpha:
                          ;@API Checkers
                          ; Check if ACCU contains a valid letter ('a' - 'z', 'A' - 'Z')
                          ; In:  ACCU = ASCII character
                          ; Out: Returns with cleared FLAG when ACCU contains a letter.
    3B85 1B0E             PSH  ACCU
    3B87 010541           SU   #'A'
    3B8A 2505   
    3B8C 17A73B           JNF  _isalp01
    3B8F 01051A           SUB  #'Z'+1-'A'
    3B92 1105   
    3B94 17A43B           JNF  _isalp02
    3B97 010506           SUB  #'a'-('Z'+1)
    3B9A 1105   
    3B9C 17A73B           JNF  _isalp01
    3B9F 01051A           SUB  #'z'+1-'a'
    3BA2 1105   
    3BA4 1C0E   _isalp02  POP  ACCU
    3BA6 1A               RET
    3BA7 22     _isalp01  SEC
    3BA8 1C0E             POP  ACCU
    3BAA 1A               RET
                
                is_hexchar:
                          ;@API Checkers
                          ; Check if ACCU contains a hex character ('0' - '9', 'A' - 'F')
                          ; In:  ACCU = ASCII character
                          ; Out: Returns with cleared FLAG when ACCU contains a hex character.
                          ;      The ACCU contains the converted number (0x00 - 0x0F)
                          ; Changes: ACCU
    3BAB 010530           SU   #'0'
    3BAE 2505   
    3BB0 17E93B           JNF  _ishex01
    3BB3 02060E           LD   PAR2,ACCU
    3BB6 01050A           SUB  #10
    3BB9 1105   
    3BBB 16C23B           JPF  _ishex02
    3BBE 020E06           LD   ACCU,PAR2
    3BC1 1A               RET  ; FLAG = 0, ACCU = number 0-9
    3BC2 010507 _ishex02  SUB  #7
    3BC5 1105   
    3BC7 17E93B           JNF  _ishex01
    3BCA 010506           SUB  #6
    3BCD 1105   
    3BCF 16D93B           JPF  _ishex03
    3BD2 010510 _ishex04  ADD  #16
    3BD5 1005   
    3BD7 23               CLC
    3BD8 1A               RET  ; FLAG = 0, ACCU = number 10-15
    3BD9 01051A _ishex03  SUB  #0x1A
    3BDC 1105   
    3BDE 17E93B           JNF  _ishex01
    3BE1 010506           SUB  #6
    3BE4 1105   
    3BE6 17D23B           JNF  _ishex04
    3BE9 22     _ishex01  SEC
    3BEA 1A               RET
                
                to_upper:
                          ;@API Conversion
                          ; Convert character in ACCU to upper case.
                          ; In:  ACCU = any ASCII character
                          ; Out: ACCU = upper case letter if ACCU contains a letter
                          ; Changes: ACCU
    3BEB 1E               PHL
    3BEC 19853B           JSR  is_alpha
    3BEF 16F73B           JPF  _toup1
    3BF2 0105DF           AND  #0xDF
    3BF5 0D05   
    3BF7 1F     _toup1    RTS
                
                to_lower:
                          ;@API Conversion
                          ; Convert character in ACCU to lower case.
                          ; In:  ACCU = any ASCII character
                          ; Out: ACCU = lower case letter if ACCU contains a letter
                          ; Changes: ACCU
    3BF8 1E               PHL
    3BF9 19853B           JSR  is_alpha
    3BFC 16043C           JPF  _tolo1
    3BFF 010520           OR   #0x20
    3C02 0E05   
    3C04 1F     _tolo1    RTS
                
                skip_space:
                          ;@API Strings
                          ; Skip leading space characters in a text string.
                          ; In:  PTR = pointer to string in memory
                          ; Out: PTR = pointer to first non-space character in the string
                          ; Changes: ACCU, PTR
    3C05 05               LAP
    3C06 1320             CMP  #' '
    3C08 17CD3A           JNF  ret_opc
    3C0B 090C             INC  PTR_L
    3C0D 150C             TST  PTR_L
    3C0F 17053C           JNF  skip_space
    3C12 090D             INC  PTR_H
    3C14 18053C           JMP  skip_space
                
                strcpy:
                          ;@API Strings
                          ; Copy a string (zero-terminated)
                          ; In: R4 = source address, R5 = destination address
                          ; Changes: ACCU, PTR, R4, R5
    3C17 1E               PHL
    3C18 19213B _stcp01   JSR  ld_ptr_r4
    3C1B 19F93A           JSR  inc_r4
    3C1E 05               LAP
    3C1F 19283B           JSR  ld_ptr_r5
    3C22 19033B           JSR  inc_r5
    3C25 07               SAP
    3C26 150E             TST
    3C28 17183C           JNF  _stcp01
    3C2B 1F               RTS
                
                strlen:
                          ;@API Strings
                          ; Get the length of a string (zero-terminated)
                          ; In : PTR = pointer to string
                          ; Out: R0 = string length
                          ; Changes: ACCU, R0, PTR
    3C2C 1E               PHL
    3C2D 0110FF           LD   R0,#0xFF
    3C30 0910   _stln01   INC  R0
    3C32 19CE3A           JSR  lap_inc_ptr
    3C35 150E             TST
    3C37 17303C           JNF  _stln01
    3C3A 1F               RTS
                
                memclr:   ; Clear a region of memory (write zeros)
    3C3B 0300             LDA  #0
                memset:
                          ;@API Strings
                          ; Initialize memory with a constant value
                          ; In : PTR = pointer to memory,
                          ;      R0 = number of bytes to write,
                          ;      ACCU = value to write
                          ; Changes: ACCU, R0, PTR
    3C3D 1510             TST  R0
    3C3F 0A10             DEC  R0
    3C41 16CD3A           JPF  ret_opc
    3C44 07               SAP
    3C45 090C             INC  PTR_L
    3C47 150C             TST  PTR_L
    3C49 173D3C           JNF  memset
    3C4C 090D             INC  PTR_H
    3C4E 183D3C           JMP  memset
                
                ;set_stdout:
                ;          ;@API Printing
                ;          ; Set user defined standard output function for printing characters,
                ;          ; strings and numbers via the usual API print functions.
                ;          ; The new output function must not save LR to the stack because
                ;          ; it was already saved by the caller. The character to output
                ;          ; is available in ACCU. The function must not change any register
                ;          ; except the ACCU. See also the description of print_char.
                ;          ; In: R4 = pointer to the new print function
                ;          ; Changes: NONE
                ;          ; ROM: 1.2
                ;          LD   VECT_OUTPUT+0,R4_L
                ;          LD   VECT_OUTPUT+1,R4_H
                ;          RET
                ;[File: my4th-rom_8MHz.asm]
                ;[File: transfer.asm]
                ;------------------------------------------------------------------------------
                ; Data transfer (via RS232 to/from the host computer)
                ;------------------------------------------------------------------------------
                
                CMD_NOP       SET 0x00
                CMD_LISTEN1   SET 0x01
                CMD_LISTEN2   SET 0x06
                CMD_EXECUTE   SET 0x02  ;execute text string
                CMD_READ1K    SET 0x12  ;read 1kb from EEPROM
                CMD_WRITE1K   SET 0x13  ;write 1kb text data to EEPROM
                
                REP_NACK      SET 0x04
                REP_ACK       SET 0x05
                REP_COK       SET 0x0E
                REP_CERR      SET 0x0F
                REP_BUSY      SET 0x10
                REP_CONT      SET 0x11
                REP_BINMODE   SET 0x86
                
                ESC_00_1F     SET 0x15  ;Escape for 0x00 - 0x1F, followed by an ASCII character where only bits 0-4 are used
                ESC_80_9F     SET 0x16  ;Escape for 0x80 - 0x9F, followed by an ASCII character where only bits 0-4 are used
                ESC_A0_FF     SET 0x17  ;Escape for 0xA0 - 0xFF, followed by an ASCII character in the range 0x20 - 0x7F
                
                readkey_xfer:
                          ; Read a key input from either UART or the keyboard.
                          ; If a special character was received over UART, the data
                          ; transfer mode will be entered. When the data transfer
                          ; mode was entered in the meantime, this function will not return.
                          ; Out: ACCU = key code (ASCII value)
    3C51 1E               PHL
    3C52 013300           LD   LIB_TFDATA+5,#0  ;flag: if set, forth must be restarted
    3C55 1534   _rkxf00   TST  LIB_BIGKEYB
    3C57 171C3D           JNF  _rkxf01
                          ;no keyboard installed, poll only the UART
    3C5A 19CD76 _rkxf04   JSR  uart_recv
    3C5D 1301             CMP  #CMD_LISTEN1
    3C5F 164E77           JPF  _binmode_enter
    3C62 1306             CMP  #CMD_LISTEN2
    3C64 164E77           JPF  _binmode_enter
    3C67 150E             TST
    3C69 165A3C           JPF  _rkxf04
    3C6C 1F               RTS  ;return key code
                
                readkey:  ; Same like readkey_xfer, but also decodes VT100 escape sequences.
                          ; This function implements a keyboard abstraction layer, the
                          ; returned key codes are the same for a physical keyboard and a
                          ; serial VT100 terminal.
                          ; Out: ACCU = key code (ASCII value)
    3C6D 1E               PHL
    3C6E 013300           LD   LIB_TFDATA+5,#0  ;flag: if set, forth must be restarted
    3C71 1534             TST  LIB_BIGKEYB
    3C73 171C3D           JNF  _rkxf01  ;read key from keyboard (and poll UART for external control connection)
    3C76 19CD76 _rdkey01  JSR  uart_recv
    3C79 131B   _rdkey08  CMP  #27
    3C7B 169F3C           JPF  _rdkey07
    3C7E 1301             CMP  #CMD_LISTEN1
    3C80 164E77           JPF  _binmode_enter
    3C83 1306             CMP  #CMD_LISTEN2
    3C85 164E77           JPF  _binmode_enter
    3C88 150E             TST
    3C8A 16763C           JPF  _rdkey01 
    3C8D 0605             STA  PAR1
    3C8F 0B05             ROL  PAR1
    3C91 16763C           JPF  _rdkey01
    3C94 137F             CMP  #0x7F
    3C96 17CA3A           JNF  rts_opc
    3C99 0308             LDA  #KCODE_BS
    3C9B 1F               RTS
    3C9C 0319   _rdkey10  LDA  #KCODE_HOME
    3C9E 1F               RTS
    3C9F 19CD76 _rdkey07  JSR  uart_recv
    3CA2 135B             CMP  #'['
    3CA4 17FD3C           JNF  _rdkey02
    3CA7 19CD76           JSR  uart_recv
    3CAA 1331             CMP  #'1'
    3CAC 17DD3C           JNF  _rdkey06
    3CAF 19CD76           JSR  uart_recv
                          ;Accu = 0-9 or A-D or ~
    3CB2 137E             CMP  #0x7E  ; '~'
    3CB4 169C3C           JPF  _rdkey10 ; 1~
    3CB7 0612             STA  R2
    3CB9 03C0             LDA  #0xC0
    3CBB 0D12             AND  R2
    3CBD 150E             TST
    3CBF 17F53C           JNF  _rdkey09  ;jump if A-Z
                          ;is number, receive ~
    3CC2 19CD76           JSR  uart_recv  ;receive (and drop) the ~
    3CC5 0412             LDA  R2
                          ;numbers 1-9 = keys F1-F8
    3CC7 01051F _rdkey12  LD   PAR1,#0x1F
                          ;accu = 0x10 - 0x19, 0x1A - 0x1C
    3CCA 0D05   _rdkey11  AND  PAR1
    3CCC 0105E0           OR   #<tab_vt100keys
    3CCF 0E05   
    3CD1 060C             STA  PTR_L
    3CD3 010D7A           LD   PTR_H,#>tab_vt100keys
    3CD6 05               LAP
    3CD7 150E             TST
    3CD9 16763C           JPF  _rdkey01
    3CDC 1F               RTS
                _rdkey06  ;Accu = 2-4 (folowed by ~) or A-D
    3CDD 0612             STA  R2
    3CDF 03C0             LDA  #0xC0
    3CE1 0D12             AND  R2
    3CE3 150E             TST
    3CE5 17F53C           JNF  _rdkey09  ;jump if A-Z
                          ;is number, receive ~
    3CE8 19CD76           JSR  uart_recv  ;receive (and drop) the ~
    3CEB 0412             LDA  R2
                          ;numbers 2-4 = keys INSERT,DELETE,END
    3CED 010508           AD   #8
    3CF0 2405   
    3CF2 18C73C           JMP  _rdkey12
    3CF5 0412   _rdkey09  LDA  R2
    3CF7 01050F           LD   PAR1,#0x0F
    3CFA 18CA3C           JMP  _rdkey11
                _rdkey02  ;assume we just received "O" as prefix for F1-F4 keys
    3CFD 19CD76           JSR  uart_recv
                          ;receive P-S for F1-F4 key
    3D00 010513           LD   PAR1,#0x13
    3D03 090E             INC
    3D05 18CA3C           JMP  _rdkey11
                
                _cont_readkey:
                          ;continue with reading next key.
                          ;check if FORTH environment must be reset before reading next key.
    3D08 1533             TST  LIB_TFDATA+5
    3D0A 173847           JNF  restart_forth
                          ;check if we should simply return to called after remote string execution
    3D0D 0491             LDA  INPUTDEV
    3D0F 1302             CMP  #INDEV_REMOTE
    3D11 16CA3A           JPF  rts_opc
                          ;check if input is done over uart: if yes, do a clean restart of the input prompt
    3D14 1534             TST  LIB_BIGKEYB
    3D16 169847           JPF  forth_restart_prompt
                          ;loop
    3D19 18553C           JMP  _rkxf00
                
                _rkxf01   ;Read key from UART or keyboard. Wait until a key was pressed.
                          ;1. poll UART
    3D1C 1D               IN
    3D1D 060F             STA  FLAG
    3D1F 170077           JNF  _rkxf02
                          ;2. poll keyboard
    3D22 19C039           JSR  keyb_readkey
    3D25 150E             TST
    3D27 161C3D           JPF  _rkxf01
    3D2A 1F               RTS
                
                test_for_io_activity:
                          ;Test for I/O-activity on UART or keyboard
                          ;returns with FLAG = 0 if there is activity.
                          ;changes ACCU, R0, PTR
    3D2B 1E               PHL
    3D2C 1D               IN
    3D2D 060F             STA  FLAG
    3D2F 17CA3A           JNF  rts_opc
                          ;poll keyboard
    3D32 1534             TST  LIB_BIGKEYB
    3D34 163D3D           JPF  _tfioa01
    3D37 19C039           JSR  keyb_readkey
    3D3A 150E             TST
    3D3C 1F               RTS  ;flag = 0 if there is I/O activity (keyboard or RS232)
    3D3D 011012 _tfioa01  LD   R0,#18
    3D40 1D     _tfioa02  IN
    3D41 060F             STA  FLAG
    3D43 17CA3A           JNF  rts_opc
    3D46 20403D           JLP  _tfioa02
    3D49 1F               RTS  ;flag = 1, no activity
                
                ;------------------------------------------------------
                ;NOTE: This code must be within one 256-byte page !!!!
                transfer_functions Segment Code
                ORG 0x7700
                
                ;UART routines for 8 MHz CPU clock frequency:
                
                _rkxf02   ;low-condition on UART detected. Try to receive a byte.
                          ;1. wait for one bit-time to skip the first zero (if host baud rate is too low)
    7700 0F0E             XOR  ACCU
    7702 0F0E             XOR  ACCU
                          ;2. wait for a high-level on RXD
    7704 1D     _rkxf07   IN
    7705 060F             STA  FLAG
    7707 170477           JNF  _rkxf07
                          ;hopefully we skiped this byte, and the high-level is the stop bit / idle state
                          ;3. wait for a low-level ("start condition") with timeout
    770A 011120           LD   R1,#32
    770D 011000           LD   R0,#0
    7710 1D     _rkxf08   IN
    7711 060F             STA  FLAG
    7713 172977           JNF  _rkxf05
    7716 201077           JLP  _rkxf08
    7719 1D               IN
    771A 060F             STA  FLAG
    771C 172977           JNF  _rkxf05
    771F 0A11             DEC  R1
    7721 1511             TST  R1
    7723 171077           JNF  _rkxf08
                          ;timeout, continue with read
    7726 18083D           JMP  _cont_readkey
                _rkxf05   ;4. receive the byte
                          ;delay
    7729 090E             INC
    772B 090E             INC
    772D 090E             INC
                          ;receive 8 bits
    772F 011008           LD   R0,#8
                _rkxf06   ;delay
    7732 0F0E             XOR  ACCU
    7734 0B0E             ROL
    7736 0B0E             ROL
    7738 0B0E             ROL
                          ;receive next bit
    773A 1D               IN
    773B 060F             STA  FLAG
    773D 0C06             ROR  PAR2
    773F 203277           JLP  _rkxf06
                          ;all bits received
    7742 0406             LDA  PAR2
                          ;check for special codes
    7744 1301             CMP  #CMD_LISTEN1
    7746 164E77           JPF  _binmode_enter
    7749 1306             CMP  #CMD_LISTEN2
    774B 17083D           JNF  _cont_readkey
                
                _binmode_enter:  ;"LISTEN"-command received via UART
                          ;send a reply to the host, showing him that we are in binary mode now.
    774E 0386             LDA  #REP_BINMODE
                _binmode_loop_tx:
    7750 199076           JSR  uart_xmit
                
                _binmode_loop:
                          ;binary mode loop
                          ;wait for a low-level ("start condition") with timeout
    7753 011120           LD   R1,#32
    7756 011000           LD   R0,#0
    7759 1D     _bmlp01   IN
    775A 060F             STA  FLAG
    775C 177277           JNF  _bmlp02
    775F 205977           JLP  _bmlp01
    7762 1D               IN
    7763 060F             STA  FLAG
    7765 177277           JNF  _bmlp02
    7768 0A11             DEC  R1
    776A 1511             TST  R1
    776C 175977           JNF  _bmlp01
                          ;timeout, continue with read
    776F 18083D           JMP  _cont_readkey
                _bmlp02   ;receive the byte
                          ;delay
    7772 090E             INC
    7774 090E             INC
    7776 090E             INC
                          ;receive 8 bits
    7778 011008           LD   R0,#8
                _bmlp03   ;delay
    777B 0F0E             XOR  ACCU
    777D 0B0E             ROL
    777F 0B0E             ROL
    7781 0B0E             ROL
                          ;receive next bit
    7783 1D               IN
    7784 060F             STA  FLAG
    7786 0C06             ROR  PAR2
    7788 207B77           JLP  _bmlp03
                          ;all bits received
    778B 0406             LDA  PAR2
    778D 18703D           JMP  _cmd_decode
                
                _cmds_receive:
                          ;Common code to all commands: receive the command string
                          ;Out: R7 = bytes in the buffer,
                          ;     PTR points to beginning of data
    7790 1E               PHL
    7791 010C31           LD   PTR_L,#<UART_BUFFER
    7794 010D83           LD   PTR_H,#>UART_BUFFER
    7797 0311             LDA  #REP_CONT
    7799 199076           JSR  uart_xmit
                          ;uart receiver loop
    779C 1D     _cmdrx2   IN
    779D 060F             STA  FLAG
    779F 169C77           JPF  _cmdrx2
                          ;delay
    77A2 090E             INC
    77A4 090E             INC
    77A6 090E             INC
    77A8 090E             INC
                          ;receive 8 bits
    77AA 011008           LD   R0,#8
                _cmdrx3   ;delay
    77AD 0F0E             XOR  ACCU
    77AF 0B0E             ROL
    77B1 0B0E             ROL
    77B3 0B0E             ROL
                          ;receive next bit
    77B5 1D               IN
    77B6 060F             STA  FLAG
    77B8 0C06             ROR  PAR2
    77BA 20AD77           JLP  _cmdrx3
                          ;store the received byte
    77BD 0406             LDA  PAR2
    77BF 150E             TST
    77C1 164A3D           JPF  _cmdrx4  ; end of received string
    77C4 07               SAP
    77C5 090C             INC  PTR_L
    77C7 150C             TST  PTR_L
    77C9 17CE77           JNF  _cmdrx1
    77CC 090D             INC  PTR_H
                _cmdrx1   ;wait until RXD is high again
    77CE 1D               IN
    77CF 060F             STA  FLAG
    77D1 17CE77           JNF  _cmdrx1
    77D4 189C77           JMP  _cmdrx2
                
                
                ;------------------------------------------------------------------------------
                
                ;UART routines for 10 MHz CPU clock frequency:
                
                ;------------------------------------------------------------------------------
                
                ;UART routines for 12 MHz CPU clock frequency:
                
                ;------------------------------------------------------------------------------
                
                ;UART routines for 14 MHz CPU clock frequency:
                
                ;----------------------------------------
                ; timing un-critical code follows here:
                _program  Segment Code
                
                
                _cmdrx4   ;finished. check if forth code got overwritten.
    3D4A 040D             LDA  PTR_H
    3D4C 010584           SU   #>FORTH_START
    3D4F 2505   
    3D51 17573D           JNF  _cmdrx5
    3D54 013301           LD   LIB_TFDATA+5,#1  ; set flag that forth code might by overwritten now
                _cmdrx5   ;calculate number of bytes in buffer
    3D57 040C             LDA  PTR_L
    3D59 010531           SU   #<UART_BUFFER
    3D5C 2505   
    3D5E 061A             STA  R7_L
    3D60 040D             LDA  PTR_H
    3D62 010583           SUB  #>UART_BUFFER
    3D65 1105   
    3D67 061B             STA  R7_H
                          ;init buffer pointer
    3D69 010C31           LD   PTR_L,#<UART_BUFFER
    3D6C 010D83           LD   PTR_H,#>UART_BUFFER
    3D6F 1F               RTS
                
                _cmd_decode:
                          ;decode the command
    3D70 1301             CMP  #CMD_LISTEN1
    3D72 164E77           JPF  _binmode_enter
    3D75 1306             CMP  #CMD_LISTEN2
    3D77 164E77           JPF  _binmode_enter
    3D7A 1302             CMP  #CMD_EXECUTE
    3D7C 16933D           JPF  _cmd_exec
    3D7F 1312             CMP  #CMD_READ1K
    3D81 160F3E           JPF  _cmd_read1k
    3D84 1313             CMP  #CMD_WRITE1K
    3D86 16CC3E           JPF  _cmd_write1k
    3D89 150E             TST
    3D8B 165377           JPF  _binmode_loop  ;NOP
                          ;unknown command
    3D8E 030F             LDA  #REP_CERR
    3D90 185077           JMP  _binmode_loop_tx
                
                _cmd_exec:
                          ;execute a text string
    3D93 199077           JSR  _cmds_receive
    3D96 1533             TST  LIB_TFDATA+5
    3D98 16A33D           JPF  _cmdex05
                          ; received string too long, FORTH program memory was overwritten
    3D9B 0304             LDA  #REP_NACK
    3D9D 199076           JSR  uart_xmit
    3DA0 183847           JMP  restart_forth
                _cmdex05  ;get CRC-sum, store it in LIB_TFDATA+2/+3
    3DA3 19F63F           JSR  read_hex4
    3DA6 16B73F           JPF  _cmd_ret_nak
                          ;PTR points to data, R7 = length of data
                          ;calculate the checksum
    3DA9 011400           LD   R4_L,#0     ;checksum
    3DAC 011500           LD   R4_H,#0     ;checksum
    3DAF 02160C           LD   R5_L,PTR_L
    3DB2 02170D           LD   R5_H,PTR_H
                          ;R7 contains the number of received bytes
                _cmdex01  ;loop over all the data
    3DB5 151A             TST  R7_L
    3DB7 17C13D           JNF  _cmdex02
    3DBA 151B             TST  R7_H
    3DBC 16E53D           JPF  _cmdex03
    3DBF 0A1B             DEC  R7_H
    3DC1 0A1A   _cmdex02  DEC  R7_L
                          ;read next byte
    3DC3 19283B           JSR  ld_ptr_r5
    3DC6 05               LAP
    3DC7 0916             INC  R5_L
    3DC9 1516             TST  R5_L
    3DCB 17D03D           JNF  _cmdex04
    3DCE 0917             INC  R5_H
                _cmdex04  ;update the checksum
    3DD0 0F15             XOR  R4_H
    3DD2 060C             STA  PTR_L
    3DD4 010D7E           LD   PTR_H,#>TAB_CRC16HI
    3DD7 05               LAP
    3DD8 0F14             XOR  R4_L
    3DDA 0615             STA  R4_H
    3DDC 010D7F           LD   PTR_H,#>TAB_CRC16LO
    3DDF 05               LAP
    3DE0 0614             STA  R4_L
    3DE2 18B53D           JMP  _cmdex01
                _cmdex03  ;test the checksum
    3DE5 0414             LDA  R4_L
    3DE7 1430             CMP  LIB_TFDATA+2
    3DE9 17B73F           JNF  _cmd_ret_nak
    3DEC 0415             LDA  R4_H
    3DEE 1431             CMP  LIB_TFDATA+3
    3DF0 17B73F           JNF  _cmd_ret_nak
                          ;checksum correct
    3DF3 0305             LDA  #REP_ACK
    3DF5 199076           JSR  uart_xmit
                          ;store terminating zero
    3DF8 19283B           JSR  ld_ptr_r5
    3DFB 0300             LDA  #0
    3DFD 07               SAP
                          ;set pointer to beginning of the buffer
    3DFE 010C35           LD   PTR_L,#<(UART_BUFFER+4)
    3E01 010D83           LD   PTR_H,#>(UART_BUFFER+4)
                          ;execute the string
    3E04 188D47           JMP  execRemoteString
                
                txferr_errorback:
                          ;this function is called from execRemoteString when
                          ;the string execution failed
    3E07 1E               PHL  ;push LR to stack so transfer can RTS to the calling forth module (instead of polling the keyboard)
    3E08 18BA3F           JMP  _cmd_ret_cerr
                
                txferr_okback:
                          ;this function is called from execRemoteString when
                          ;the string execution succeeded
    3E0B 1E               PHL  ;push LR to stack so transfer can RTS to the calling forth module (instead of polling the keyboard)
    3E0C 18B43F           JMP  _cmd_ret_cok
                
                _cmd_read1k:
                          ;read 1kB from EEPROM and transmit it over UART
    3E0F 199077           JSR  _cmds_receive
    3E12 19BF3F           JSR  read_blocknbr
    3E15 165077           JPF  _binmode_loop_tx  ; error, the error-code is in ACCU
                          ;PTR = pointer to next data
                          ;R7 = remaining data length
                          ;R4 = block number
    3E18 041A             LDA  R7_L
    3E1A 0E1B             OR   R7_H
    3E1C 150E             TST
    3E1E 17B73F           JNF  _cmd_ret_nak
                          ;send ACK, command successfully received
    3E21 0305             LDA  #REP_ACK
    3E23 199076           JSR  uart_xmit
                          ;start reading from EEPROM
    3E26 193038           JSR  fblockToEepromAddr
    3E29 16BA3F           JPF  _cmd_ret_cerr
    3E2C 199A38           JSR  eeprom_start_read
    3E2F 16BA3F           JPF  _cmd_ret_cerr
                          ;initialize checksum accu
    3E32 011400           LD   R4_L,#0
    3E35 011500           LD   R4_H,#0
                          ;load counter for 1kB (remaining bytes)
    3E38 0118FF           LD   R6_L,#0xFF
    3E3B 011904           LD   R6_H,#0x04
                          ;send 1023 bytes
    3E3E 011100           LD   R1,#0
    3E41 0A19   _cmdrd02  DEC  R6_H
    3E43 0A18   _cmdrd01  DEC  R6_L
    3E45 192E2E           JSR  i2c_recv
    3E48 196C3E           JSR  _cmdr_snd
    3E4B 1518             TST  R6_L
    3E4D 17433E           JNF  _cmdrd01
    3E50 1519             TST  R6_H
    3E52 17413E           JNF  _cmdrd02
                          ;send last byte
    3E55 011101           LD   R1,#1
    3E58 192E2E           JSR  i2c_recv
    3E5B 196C3E           JSR  _cmdr_snd
                          ;send checksum as hex-16
    3E5E 193440           JSR  send_hex4
                          ;send the terminating zero
    3E61 0300             LDA  #0
    3E63 199076           JSR  uart_xmit
    3E66 19DE2D           JSR  i2c_stop
    3E69 185377           JMP  _binmode_loop
                
                _cmdr_snd ;send one byte
    3E6C 0613             STA  R3
                          ;update the checksum
    3E6E 0F15             XOR  R4_H
    3E70 060C             STA  PTR_L
    3E72 010D7E           LD   PTR_H,#>TAB_CRC16HI
    3E75 05               LAP
    3E76 0F14             XOR  R4_L
    3E78 0615             STA  R4_H
    3E7A 010D7F           LD   PTR_H,#>TAB_CRC16LO
    3E7D 05               LAP
    3E7E 0614             STA  R4_L
                          ;escape the data (which is in R3)
    3E80 0413             LDA  R3
    3E82 0B0E             ROL
    3E84 16A03E           JPF  _cmdrs01
                          ;the value is < 0x80
    3E87 0360             LDA  #0x60
    3E89 0D13             AND  R3
    3E8B 150E             TST
    3E8D 0413             LDA  R3
    3E8F 179076           JNF  uart_xmit  ; no need to escape the data, send it now
                          ;the value is < 0x20
    3E92 1E               PHL
    3E93 0315             LDA  #ESC_00_1F
    3E95 199076           JSR  uart_xmit
    3E98 0340             LDA  #0x40
    3E9A 0E13             OR   R3
    3E9C 199076           JSR  uart_xmit
    3E9F 1F               RTS
                _cmdrs01  ;the value is >= 0x80
    3EA0 1E               PHL
    3EA1 0360             LDA  #0x60
    3EA3 0D13             AND  R3
    3EA5 150E             TST
    3EA7 16BA3E           JPF  _cmdrs02  ;the value is in the range 0x80 - 0x9F
                          ;the value is in the range 0xA0 - 0xFF
    3EAA 0317             LDA  #ESC_A0_FF
    3EAC 199076           JSR  uart_xmit
    3EAF 0413             LDA  R3
    3EB1 0B0E             ROL
    3EB3 23               CLC
    3EB4 0C0E             ROR
    3EB6 199076           JSR  uart_xmit
    3EB9 1F               RTS
    3EBA 0316   _cmdrs02  LDA  #ESC_80_9F
    3EBC 199076           JSR  uart_xmit
    3EBF 031F             LDA  #0x1F
    3EC1 0D13             AND  R3
    3EC3 010540           OR   #0x40
    3EC6 0E05   
    3EC8 199076           JSR  uart_xmit
    3ECB 1F               RTS
                
                _cmd_write1k:
                          ;receive 1kB over UART and write it into the EEPROM
    3ECC 199077           JSR  _cmds_receive
    3ECF 0310             LDA  #REP_BUSY
    3ED1 199076           JSR  uart_xmit
    3ED4 19BF3F           JSR  read_blocknbr
    3ED7 165077           JPF  _binmode_loop_tx  ; error, the error-code is in ACCU
                          ;PTR = pointer to next data
                          ;R7 = remaining data length
                          ;R4 = block number
                          ;Move block number to LIB_TFDATA+0/+1
    3EDA 022E14           LD   LIB_TFDATA+0,R4_L
    3EDD 022F15           LD   LIB_TFDATA+1,R4_H
                          ;get CRC-sum, store it in LIB_TFDATA+2/+3
    3EE0 19F63F           JSR  read_hex4
    3EE3 16B73F           JPF  _cmd_ret_nak
                          ;de-escape the data and calculate the checksum
    3EE6 011400           LD   R4_L,#0     ;checksum
    3EE9 011500           LD   R4_H,#0     ;checksum
    3EEC 02160C           LD   R5_L,PTR_L  ;source ptr
    3EEF 02170D           LD   R5_H,PTR_H  ;source ptr
    3EF2 011831           LD   R6_L,#<UART_BUFFER   ;destination pointer
    3EF5 011983           LD   R6_H,#>UART_BUFFER   ;destination pointer
                          ;R7 contains the number of remaining bytes to decode
                _cmdwr01  ;loop over all the data
    3EF8 151A             TST  R7_L
    3EFA 17043F           JNF  _cmdwr02
    3EFD 151B             TST  R7_H
    3EFF 168F3F           JPF  _cmdwr03
    3F02 0A1B             DEC  R7_H
    3F04 0A1A   _cmdwr02  DEC  R7_L
                          ;read next byte
    3F06 020C16           LD   PTR_L,R5_L
    3F09 020D17           LD   PTR_H,R5_H
    3F0C 05               LAP
    3F0D 0916             INC  R5_L
    3F0F 1516             TST  R5_L
    3F11 17163F           JNF  _cmdwr04
    3F14 0917             INC  R5_H
    3F16 0611   _cmdwr04  STA  R1
    3F18 0360             LDA  #0x60
    3F1A 0D11             AND  R1
    3F1C 150E             TST
    3F1E 17683F           JNF  _cmdwr05
                          ;R1 is a control character, get next byte from buffer
    3F21 151A             TST  R7_L
    3F23 172D3F           JNF  _cmdwr09
    3F26 151B             TST  R7_H
    3F28 16B73F           JPF  _cmd_ret_nak
    3F2B 0A1B             DEC  R7_H
    3F2D 0A1A   _cmdwr09  DEC  R7_L
    3F2F 19283B           JSR  ld_ptr_r5
    3F32 05               LAP
    3F33 0916             INC  R5_L
    3F35 1516             TST  R5_L
    3F37 173C3F           JNF  _cmdwr10
    3F3A 0917             INC  R5_H
    3F3C 0612   _cmdwr10  STA  R2
                          ;decode the control character, the next byte is already in R2.
    3F3E 0411             LDA  R1
    3F40 1317             CMP  #ESC_A0_FF
    3F42 16563F           JPF  _cmdwr07
    3F45 1316             CMP  #ESC_80_9F
    3F47 165D3F           JPF  _cmdwr08
    3F4A 1315             CMP  #ESC_00_1F
    3F4C 17B73F           JNF  _cmd_ret_nak
                          ;the byte value is in the range 0x00-0x1F
    3F4F 031F             LDA  #0x1F
    3F51 0D12             AND  R2
    3F53 186A3F           JMP  _cmdwr11
                _cmdwr07  ;the byte value is in the range 0xA0-0xFF
    3F56 0380             LDA  #0x80
    3F58 0E12             OR   R2
    3F5A 186A3F           JMP  _cmdwr11
                _cmdwr08  ;the byte value is in the range 0x80-0x9F
    3F5D 031F             LDA  #0x1F
    3F5F 0D12             AND  R2
    3F61 010580           OR   #0x80
    3F64 0E05   
    3F66 0611             STA  R1
                _cmdwr05  ;R1 = de-escaped data byte
    3F68 0411             LDA  R1
                _cmdwr11  ;write data in ACCU to RAM
    3F6A 020C18           LD   PTR_L,R6_L
    3F6D 020D19           LD   PTR_H,R6_H
    3F70 07               SAP
    3F71 0918             INC  R6_L
    3F73 1518             TST  R6_L
    3F75 177A3F           JNF  _cmdwr06
    3F78 0919             INC  R6_H
                _cmdwr06  ;update the checksum
    3F7A 0F15             XOR  R4_H
    3F7C 060C             STA  PTR_L
    3F7E 010D7E           LD   PTR_H,#>TAB_CRC16HI
    3F81 05               LAP
    3F82 0F14             XOR  R4_L
    3F84 0615             STA  R4_H
    3F86 010D7F           LD   PTR_H,#>TAB_CRC16LO
    3F89 05               LAP
    3F8A 0614             STA  R4_L
                          ;next byte
    3F8C 18F83E           JMP  _cmdwr01
                
                _cmdwr03  ;test checksum
    3F8F 0414             LDA  R4_L
    3F91 1430             CMP  LIB_TFDATA+2
    3F93 17B73F           JNF  _cmd_ret_nak
    3F96 0415             LDA  R4_H
    3F98 1431             CMP  LIB_TFDATA+3
    3F9A 17B73F           JNF  _cmd_ret_nak
    3F9D 0305             LDA  #REP_ACK
    3F9F 199076           JSR  uart_xmit
                          ;write data to EEPROM
    3FA2 02142E           LD   R4_L,LIB_TFDATA+0
    3FA5 02152F           LD   R4_H,LIB_TFDATA+1
    3FA8 011631           LD   R5_L,#<UART_BUFFER
    3FAB 011783           LD   R5_H,#>UART_BUFFER
    3FAE 192539           JSR  eeprom_write_forth_block
    3FB1 16B73F           JPF  _cmd_ret_nak
                _cmd_ret_cok:
                          ;all ok
    3FB4 030E             LDA  #REP_COK
    3FB6 01               DB   0x01  ; trick: jumps over next two bytes, but overwrites register TEMP5
                _cmd_ret_nak:
    3FB7 0304             LDA  #REP_NACK
    3FB9 01               DB   0x01  ; trick: jumps over next two bytes, but overwrites register TEMP5
                _cmd_ret_cerr:
    3FBA 030F             LDA  #REP_CERR
    3FBC 185077           JMP  _binmode_loop_tx
                
                read_blocknbr:
                          ;Read a hex-coded block number from UART buffer.
                          ;Checks the amount of bytes in the buffer.
                          ;In: PTR = pointer to begin of received data, R7 = number of received bytes
                          ;Out: PTR points behind number, R4 = converted number, FLAG = 0 on success
                          ;     R7 = remaining bytes in the buffer, ACCU = error code if FLAG = 1
                          ;Changes: ACCU, R0, R1
    3FBF 1E               PHL
                          ;read hex value
    3FC0 19F63F           JSR  read_hex4
    3FC3 16F23F           JPF  _rbnbr2
                          ;test checksum
    3FC6 0414             LDA  R4_L
    3FC8 0F15             XOR  R4_H
    3FCA 0606             STA  PAR2
    3FCC 011004           LD   R0,#4
    3FCF 23     _rbnbr1   CLC
    3FD0 0C0E             ROR
    3FD2 20CF3F           JLP  _rbnbr1
    3FD5 0F06             XOR  PAR2
    3FD7 01050F           LD   PAR1,#0x0F
    3FDA 0D05             AND  PAR1
    3FDC 150E             TST
    3FDE 17F23F           JNF  _rbnbr2
    3FE1 0415             LDA  R4_H
    3FE3 0D05             AND  PAR1
    3FE5 0615             STA  R4_H
                          ;check range of block number
    3FE7 0414             LDA  R4_L
    3FE9 254A             SU   LIB_NUMPAGES
    3FEB 0415             LDA  R4_H
    3FED 114B             SUB  LIB_NUMPAGES+1
    3FEF 030F             LDA  #REP_CERR
    3FF1 1F               RTS  ;return FLAG=0 on success, otherwise FLAG=1 and ACCU = error code
    3FF2 0304   _rbnbr2   LDA  #REP_NACK
    3FF4 22               SEC
    3FF5 1F               RTS
                
                read_hex4:
                          ;Convert a 4-character hex-number
                          ;In: PTR = pointer to hex number, R7 = length of input buffer
                          ;Out: PTR points behind number, R4 and LIB_TFDATA+2/3 = converted number,
                          ;     R7 = length - 4 bytes, FLAG = 0 on success
                          ;Changes: ACCU, R0, R1
    3FF6 1E               PHL
    3FF7 041A             LDA  R7_L
    3FF9 010504           SU   #4
    3FFC 2505   
    3FFE 061A             STA  R7_L
    4000 041B             LDA  R7_H
    4002 010500           SUB  #0
    4005 1105   
    4007 061B             STA  R7_H
    4009 17CB3A           JNF  return_flag_1
    400C 011104           LD   R1,#4
    400F 011004 _rdhx0    LD   R0,#4
    4012 23     _rdhx1    CLC
    4013 2114             RWL  R4
    4015 201240           JLP  _rdhx1
    4018 19CE3A           JSR  lap_inc_ptr
    401B 19AB3B           JSR  is_hexchar
    401E 16CA3A           JPF  rts_opc
    4021 0E14             OR   R4_L
    4023 0614             STA  R4_L
    4025 0A11             DEC  R1
    4027 1511             TST  R1
    4029 170F40           JNF  _rdhx0
    402C 023014           LD   LIB_TFDATA+2,R4_L
    402F 023115           LD   LIB_TFDATA+3,R4_H
    4032 23               CLC
    4033 1F               RTS
                
                send_hex4:
                          ;Send a word (16-bit) in hexadecimal over uart
                          ;In: word in R4
                          ;Changes: ACCU
    4034 0415             LDA  R4_H
    4036 1E               PHL
    4037 194040           JSR  _snhxw3
    403A 1C0B             POP  LR_H
    403C 1C0A             POP  LR_L
    403E 0414             LDA  R4_L
    4040 1B0E   _snhxw3   PSH  ACCU
    4042 23               CLC
    4043 0C0E             ROR
    4045 23               CLC
    4046 0C0E             ROR
    4048 23               CLC
    4049 0C0E             ROR
    404B 23               CLC
    404C 0C0E             ROR
    404E 1E               PHL
    404F 195D40           JSR  _snhxw2
    4052 1C0B             POP  LR_H
    4054 1C0A             POP  LR_L
    4056 1C0E             POP  ACCU
    4058 01050F           AND  #0Fh
    405B 0D05   
    405D 01050A _snhxw2   SU   #10
    4060 2505   
    4062 166D40           JPF  _snhxw1
    4065 01053A           ADD  #3Ah
    4068 1005   
    406A 189076           JMP  uart_xmit
    406D 010540 _snhxw1   ADD  #40h
    4070 1005   
    4072 189076           JMP  uart_xmit
                
                
                ;[File: my4th-rom_8MHz.asm]
                ;[File: forth_math.asm]
                ;------------------------------------------------------------------------------
                ; Math functions for Forth
                ;------------------------------------------------------------------------------
                
                negate_r4:  ; Negate the 16-bit number in R4 (two's complement).
                            ; In : R4 = 16-bit signed number
                            ; Out: R4 = negated 16-bit signed number
                            ; Changes: ACCU, R4
    4075 0300               LDA  #0
    4077 2514               SU   R4_L
    4079 0614               STA  R4_L
    407B 0300               LDA  #0
    407D 1115               SUB  R4_H
    407F 0615               STA  R4_H
    4081 1A                 RET
                
                negate_r5:  ; Negate the 16-bit number R5 (two's complement).
                            ; In : R5 = 16-bit signed number
                            ; Out: R5 = negated 16-bit signed number
                            ; Changes: ACCU, R4
    4082 0300               LDA  #0
    4084 2516               SU   R5_L
    4086 0616               STA  R5_L
    4088 0300               LDA  #0
    408A 1117               SUB  R5_H
    408C 0617               STA  R5_H
    408E 1A                 RET
                
                negate_R45:
                            ;negate the 32-bit number in R4 and R5
    408F 1E                 PHL
    4090 19AE40 _negR4R5    JSR  inv_r4
    4093 19BE40             JSR  inv_r5
    4096 0914               INC  R4_L
    4098 1514               TST  R4_L
    409A 17CB3A             JNF  return_flag_1
    409D 0915               INC  R4_H
    409F 1515               TST  R4_H
    40A1 17CB3A             JNF  return_flag_1
    40A4 0916               INC  R5_L
    40A6 1516               TST  R5_L
    40A8 17CB3A             JNF  return_flag_1
    40AB 0917               INC  R5_H
    40AD 1F                 RTS
                
                inv_r4:     ;bit-invert R4
    40AE 0105FF             LD   PAR1,#0xFF
    40B1 0414               LDA  R4_L
    40B3 0F05               XOR  PAR1
    40B5 0614               STA  R4_L
    40B7 0415               LDA  R4_H
    40B9 0F05               XOR  PAR1
    40BB 0615               STA  R4_H
    40BD 1A                 RET
                
                inv_r5:     ;bit-invert R5
    40BE 0105FF             LD   PAR1,#0xFF
    40C1 0416               LDA  R5_L
    40C3 0F05               XOR  PAR1
    40C5 0616               STA  R5_L
    40C7 0417               LDA  R5_H
    40C9 0F05               XOR  PAR1
    40CB 0617               STA  R5_H
    40CD 1A                 RET
                
                inv_r6:     ;bit-invert R6
    40CE 0105FF             LD   PAR1,#0xFF
    40D1 0418               LDA  R6_L
    40D3 0F05               XOR  PAR1
    40D5 0618               STA  R6_L
    40D7 0419               LDA  R6_H
    40D9 0F05               XOR  PAR1
    40DB 0619               STA  R6_H
    40DD 1A                 RET
                
                dec_r4:     ; Decrement R4 register by one
    40DE 1514               TST  R4_L
    40E0 17E540             JNF  _decr41
    40E3 0A15               DEC  R4_H
    40E5 0A14   _decr41     DEC  R4_L
    40E7 1A                 RET
                
                mul10:      ; Multiply an unsigned 16-bit number with 10.
                            ; In : R4 = 16-bit unsigned number
                            ; Out: R4 = R4 * 10, FLAG = 0 (FLAG=1:ERROR)
                            ; Changes: ACCU, R4
    40E8 23                 CLC
    40E9 2114               RWL  R4
    40EB 020514             LD   PAR1,R4_L
    40EE 020615             LD   PAR2,R4_H
    40F1 23                 CLC
    40F2 2114               RWL  R4
    40F4 23                 CLC
    40F5 2114               RWL  R4
    40F7 16CD3A             JPF  ret_opc
    40FA 0414               LDA  R4_L
    40FC 2405               AD   PAR1
    40FE 0614               STA  R4_L
    4100 0415               LDA  R4_H
    4102 1006               ADD  PAR2
    4104 0615               STA  R4_H
    4106 1A                 RET
                
                signprepare:
                            ; Tool function for signed multiplication and division:
                            ; Make parameters unsigned and store sign of result in R1 bit 0
    4107 1E                 PHL
    4108 011100             LD   R1,#0
    410B 0415               LDA  R4_H
    410D 0B0E               ROL
    410F 171741             JNF  _sgprep1
    4112 197540             JSR  negate_r4
    4115 0911               INC  R1
    4117 0417   _sgprep1    LDA  R5_H
    4119 0B0E               ROL
    411B 17CA3A             JNF  return
    411E 198240             JSR  negate_r5
    4121 0911               INC  R1
    4123 1F                 RTS
                
                div_u32u16:
                            ;Divide a 32-bit unsigned number by an 16-bit unsigned number.
                            ;In : R4/R5 = divident, R6 = divisor
                            ;Out: R4/R5 = 32-bit result, R6 = 16-bit reminder
    4124 1519               TST  R6_H
    4126 169741             JPF  _div32_7  ; divisor has only 8 bit
    4129 1516               TST  R5_L
    412B 173341             JNF  _div32_3
    412E 1517               TST  R5_H
    4130 16F341             JPF  _div32_4
    4133 012000 _div32_3    LD   LIB_BUF+0,#0
    4136 012100             LD   LIB_BUF+1,#0
    4139 012200             LD   LIB_BUF+2,#0
    413C 012300             LD   LIB_BUF+3,#0
    413F 011020             LD   R0,#32
                            ;CLC
    4142 2114   _div32_1    RWL  R4
    4144 2116               RWL  R5
    4146 2120               RWL  LIB_BUF+0
    4148 2122               RWL  LIB_BUF+2
    414A 0420               LDA  LIB_BUF+0
    414C 2518               SU   R6_L
    414E 0612               STA  R2
    4150 0421               LDA  LIB_BUF+1
    4152 1119               SUB  R6_H
    4154 0613               STA  R3
    4156 167741             JPF  _div32_5
    4159 020522             LD   PAR1,LIB_BUF+2
    415C 1505               TST  PAR1
    415E 090F               INC  FLAG
    4160 0A05               DEC  PAR1
    4162 167441             JPF  _div32_6
    4165 020623             LD   PAR2,LIB_BUF+3
    4168 1506               TST  PAR2
    416A 090F               INC  FLAG
    416C 0A06               DEC  PAR2
    416E 177D41             JNF  _div32_2
    4171 022306             LD   LIB_BUF+3,PAR2
    4174 022205 _div32_6    LD   LIB_BUF+2,PAR1
    4177 022012 _div32_5    LD   LIB_BUF+0,R2
    417A 022113             LD   LIB_BUF+1,R3
    417D 2124   _div32_2    RWL  LIB_BUF+4
    417F 217E               RWL  MATH_BUF+0
    4181 204241             JLP  _div32_1
    4184 021424             LD   R4_L,LIB_BUF+4
    4187 021525             LD   R4_H,LIB_BUF+5
    418A 02167E             LD   R5_L,MATH_BUF+0
    418D 02177F             LD   R5_H,MATH_BUF+1
    4190 021921             LD   R6_H,LIB_BUF+1
    4193 021820             LD   R6_L,LIB_BUF+0
    4196 1A                 RET
                
                _div32_7    ;check if upper 8 bits of 32-bit word are 0
    4197 1517               TST  R5_H
    4199 173341             JNF  _div32_3  ;no, do usual 32/16 division
                            ;check if uppet 16 bits of 32-bit word are 0
    419C 1516               TST  R5_L
    419E 16F341             JPF  _div32_4  ;yes, do 16-bit division
                
                            ;do 24-bit division with an 8-bit divisor
    41A1 012000             LD   LIB_BUF+0,#0
    41A4 012100             LD   LIB_BUF+1,#0
    41A7 012200             LD   LIB_BUF+2,#0
    41AA 011018             LD   R0,#24
                            ;CLC
    41AD 2114   _div24_1    RWL  R4
    41AF 0B16               ROL  R5_L
    41B1 2120               RWL  LIB_BUF+0
    41B3 0B22               ROL  LIB_BUF+2
    41B5 0420               LDA  LIB_BUF+0
    41B7 2518               SU   R6_L
    41B9 0612               STA  R2
    41BB 16D641             JPF  _div24_3
    41BE 021321             LD   R3,LIB_BUF+1
    41C1 1513               TST  R3
    41C3 090F               INC  FLAG
    41C5 0A13               DEC  R3
    41C7 16D341             JPF  _div24_4
    41CA 1522               TST  LIB_BUF+2
    41CC 090F               INC  FLAG
    41CE 17D941             JNF  _div24_2
    41D1 0A22               DEC  LIB_BUF+2
    41D3 022113 _div24_4    LD   LIB_BUF+1,R3
    41D6 022012 _div24_3    LD   LIB_BUF+0,R2
    41D9 2124   _div24_2    RWL  LIB_BUF+4
    41DB 0B7E               ROL  MATH_BUF+0
    41DD 20AD41             JLP  _div24_1
    41E0 021424             LD   R4_L,LIB_BUF+4
    41E3 021525             LD   R4_H,LIB_BUF+5
    41E6 02167E             LD   R5_L,MATH_BUF+0
    41E9 011700             LD   R5_H,#0
    41EC 021921             LD   R6_H,LIB_BUF+1
    41EF 021820             LD   R6_L,LIB_BUF+0
    41F2 1A                 RET
                
                _div32_4    ;do 16-bit division
    41F3 1E                 PHL
    41F4 021618             LD   R5_L,R6_L
    41F7 021719             LD   R5_H,R6_H
    41FA 194C43             JSR  divide_u
    41FD 021816             LD   R6_L,R5_L
    4200 021917             LD   R6_H,R5_H
    4203 011600             LD   R5_L,#0
    4206 011700             LD   R5_H,#0
    4209 1F                 RTS
                
                div_i32i16:
                            ;Divide a 32-bit signed number by an 16-bit signed number.
                            ;In : R4/R5 = divident, R6 = divisor
                            ;Out: R4/R5 = 32-bit result, R6 = 16-bit reminder (call div_i32_crem to correct the sign)
    420A 1E                 PHL
    420B 011100             LD   R1,#0  ;the final sign of the result
    420E 0417               LDA  R5_H
    4210 0B0E               ROL
    4212 1B0F               PSH  FLAG
    4214 171C42             JNF  _divi32_1
    4217 0911               INC  R1
    4219 198F40             JSR  negate_R45
    421C 0419   _divi32_1   LDA  R6_H
    421E 0B0E               ROL
    4220 172B42             JNF  _divi32_2
    4223 0911               INC  R1
    4225 19CE40             JSR  inv_r6
    4228 190D3B             JSR  inc_r6
    422B 192441 _divi32_2   JSR  div_u32u16
    422E 0C11               ROR  R1
    4230 173642             JNF  _divi32_3
    4233 198F40             JSR  negate_R45
    4236 1C0F   _divi32_3   POP  FLAG
    4238 1F                 RTS
                            ;remember: call div_i32_crem to correct the sign of the reminder
                
                div_i32_crem:
                            ;correct the sign of the reminder in R6
    4239 17CD3A             JNF  ret_opc
    423C 1E                 PHL
    423D 19CE40             JSR  inv_r6
    4240 190D3B             JSR  inc_r6
    4243 1F                 RTS
                
                mul32u: 
                            ; Multiply a 32-bit unsigned number with a 16-bit unsigned number.
                            ; The result is 32-bit wide.
                            ; In : R4,R5 = 32-bit number, R6 = 16-bit number
                            ; Out: R4,R5 = 32-bit result
                            ; Changes: ACCU, R4, R5
    4244 1516               TST  R5_L
    4246 174E42             JNF  _mul32_4
    4249 1517               TST  R5_H
    424B 169742             JPF  _mul32_5
    424E 0300   _mul32_4    LDA  #0
    4250 0620               STA  LIB_BUF+0
    4252 0621               STA  LIB_BUF+1
    4254 0622               STA  LIB_BUF+2
    4256 0623               STA  LIB_BUF+3
    4258 020510             LD   PAR1,R0
    425B 011020             LD   R0,#32
    425E 186542             JMP  _mul32_1
    4261 2120   _mul32_2    RWL  LIB_BUF+0
    4263 2122               RWL  LIB_BUF+2
    4265 2114   _mul32_1    RWL  R4
    4267 2116               RWL  R5
    4269 178442             JNF  _mul32_3
    426C 0420               LDA  LIB_BUF+0
    426E 2418               AD   R6_L
    4270 0620               STA  LIB_BUF+0
    4272 0421               LDA  LIB_BUF+1
    4274 1019               ADD  R6_H
    4276 0621               STA  LIB_BUF+1
    4278 178442             JNF  _mul32_3
    427B 0922               INC  LIB_BUF+2
    427D 1522               TST  LIB_BUF+2
    427F 178442             JNF  _mul32_3
    4282 0923               INC  LIB_BUF+3
    4284 206142 _mul32_3    JLP  _mul32_2
    4287 021005             LD   R0,PAR1
    428A 021420             LD   R4_L,LIB_BUF+0
    428D 021521             LD   R4_H,LIB_BUF+1
    4290 021622             LD   R5_L,LIB_BUF+2
    4293 021723             LD   R5_H,LIB_BUF+3
    4296 1A                 RET
                _mul32_5    ;use 16x16 bit multiplication
    4297 021618             LD   R5_L,R6_L
    429A 021719             LD   R5_H,R6_H
                
                multiply_u: 
                            ; Multiply two 16-bit unsigned numbers. The result is 32-bit wide.
                            ; In : R4, R5 = two 16-bit numbers
                            ; Out: R4, R5 = 32-bit result (R4=bit0-15, R5=bit16-31)
                            ; Changes: ACCU, R4, R5
    429D 020510             LD   PAR1,R0
    42A0 0300               LDA  #0
    42A2 0622               STA  LIB_BUF+2
    42A4 0623               STA  LIB_BUF+3
    42A6 1515               TST  R4_H
    42A8 17B042             JNF  _multp04
    42AB 1517               TST  R5_H
    42AD 16E442             JPF  _multp05   ;do a 8b x 8b = 16b multiplication
    42B0 0620   _multp04    STA  LIB_BUF+0
    42B2 0621               STA  LIB_BUF+1
    42B4 011010             LD   R0,#16
    42B7 18BE42             JMP  _multp01
    42BA 2122   _multp02    RWL  LIB_BUF+2
    42BC 2120               RWL  LIB_BUF+0
    42BE 2114   _multp01    RWL  R4
    42C0 17DB42             JNF  _multp03
    42C3 0422               LDA  LIB_BUF+2
    42C5 2416               AD   R5_L
    42C7 0622               STA  LIB_BUF+2
    42C9 0423               LDA  LIB_BUF+3
    42CB 1017               ADD  R5_H
    42CD 0623               STA  LIB_BUF+3
    42CF 17DB42             JNF  _multp03
    42D2 0920               INC  LIB_BUF+0
    42D4 1520               TST  LIB_BUF+0
    42D6 17DB42             JNF  _multp03
    42D9 0921               INC  LIB_BUF+1
    42DB 20BA42 _multp03    JLP  _multp02
    42DE 021005             LD   R0,PAR1
    42E1 18E343             JMP  _multp06 
                _multp05    ;8x8 multiplication
    42E4 011008             LD   R0,#8
    42E7 18EC42             JMP  _multp09
    42EA 2122   _multp07    RWL  LIB_BUF+2
    42EC 0B14   _multp09    ROL  R4_L
    42EE 17FE42             JNF  _multp08
    42F1 0422               LDA  LIB_BUF+2
    42F3 2416               AD   R5_L
    42F5 0622               STA  LIB_BUF+2
    42F7 17FE42             JNF  _multp08
    42FA 0923               INC  LIB_BUF+3
    42FC 1523               TST  LIB_BUF+3
    42FE 20EA42 _multp08    JLP  _multp07
    4301 021005             LD   R0,PAR1
    4304 011600             LD   R5_L,#0
    4307 18E943             JMP  _multp10
                
                multiply_s:
                            ; Multiply two 16-bit signed numbers. The result is 32-bit wide.
                            ; In : R4, R5 = two 16-bit numbers
                            ; Out: R4, R5 = 32-bit result (R4=bit0-15, R5=bit16-31)
                            ; Changes: ACCU, R4, R5
    430A 1E                 PHL
    430B 1B11               PSH  R1
    430D 190741             JSR  signprepare
    4310 199D42             JSR  multiply_u
    4313 0C11               ROR  R1
    4315 170144             JNF  _divsgn1
    4318 197540             JSR  negate_r4
    431B 198240             JSR  negate_r5
    431E 180144             JMP  _divsgn1
                
                mul32s:
                            ; Multiply a 32-bit signed number with a 16-bit signed number.
                            ; The result is 32-bit wide.
                            ; In : R4,R5 = 32-bit number, R6 = 16-bit number
                            ; Out: R4,R5 = 32-bit result
                            ; Changes: ACCU, R4, R5, R0
    4321 1E                 PHL
    4322 011100             LD   R1,#0
    4325 0417               LDA  R5_H
    4327 0B0E               ROL
    4329 173143             JNF  _mul32s_1
    432C 0911               INC  R1
    432E 198F40             JSR  negate_R45
    4331 0419   _mul32s_1   LDA  R6_H
    4333 0B0E               ROL
    4335 174043             JNF  _mul32s_2
    4338 0911               INC  R1
    433A 19CE40             JSR  inv_r6
    433D 190D3B             JSR  inc_r6
    4340 194442 _mul32s_2   JSR  mul32u
    4343 0C11               ROR  R1
    4345 17CA3A             JNF  return
    4348 198F40             JSR  negate_R45
    434B 1F                 RTS
                
                divide_u:
                            ; Divide a 16-bit unsigned number by an other 16-bit unsigned number.
                            ; In : R4 = divident, R5 = divisor
                            ; Out: R4 = 16-bit result, R5 = 16-bit reminder
                            ; Changes: ACCU, R4, R5
    434C 012000             LD   LIB_BUF+0,#0
    434F 012100             LD   LIB_BUF+1,#0
    4352 1515               TST  R4_H
    4354 168B43             JPF  _divi03
    4357 1B10               PSH  R0
    4359 1517               TST  R5_H
    435B 16BA43             JPF  _divide_16_8_u  ; R5 is only 8 bit, so use a faster division routine (see lib1.3_math.asm)
                            ;16-bit division (FLAG=0 here)
    435E 011010             LD   R0,#16
    4361 2114   _divi01     RWL  R4
    4363 2120               RWL  LIB_BUF+0
    4365 0420               LDA  LIB_BUF+0
    4367 2516               SU   R5_L
    4369 0605               STA  PAR1
    436B 0421               LDA  LIB_BUF+1
    436D 1117               SUB  R5_H
    436F 177743             JNF  _divi02
    4372 022005             LD   LIB_BUF+0,PAR1
    4375 0621               STA  LIB_BUF+1
    4377 2122   _divi02     RWL  LIB_BUF+2
    4379 206143             JLP  _divi01
    437C 1C10               POP  R0
    437E 021422             LD   R4_L,LIB_BUF+2
    4381 021523             LD   R4_H,LIB_BUF+3
    4384 021620             LD   R5_L,LIB_BUF+0
    4387 021721             LD   R5_H,LIB_BUF+1
    438A 1A                 RET
    438B 1517   _divi03     TST  R5_H
    438D 17B043             JNF  _divi08
                            ;8-bit division
    4390 022014             LD   LIB_BUF+0,R4_L
    4393 020610             LD   PAR2,R0
    4396 011008             LD   R0,#8
    4399 2120   _divi05     RWL  LIB_BUF+0
    439B 0421               LDA  LIB_BUF+1
    439D 2516               SU   R5_L
    439F 17A443             JNF  _divi06
    43A2 0621               STA  LIB_BUF+1
    43A4 0B14   _divi06     ROL  R4_L
    43A6 209943             JLP  _divi05
    43A9 021006             LD   R0,PAR2
    43AC 021621             LD   R5_L,LIB_BUF+1
    43AF 1A                 RET
                _divi08     ;return only the reminder
    43B0 011700             LD   R5_H,#0
    43B3 021614             LD   R5_L,R4_L
    43B6 011400             LD   R4_L,#0
    43B9 1A                 RET
                
                _divide_16_8_u:
                            ; Divide a 16-bit unsigned number by an 8-bit unsigned number.
                            ; In : R4 = divident, R5_L = divisor, R0 on stack
                            ; Out: R4 = 16-bit result, R5 = 16-bit reminder
                            ; Changes: ACCU, R4, R5
    43BA 011010             LD   R0,#16
    43BD 2114   _divi11     RWL  R4
    43BF 2120               RWL  LIB_BUF+0
    43C1 0420               LDA  LIB_BUF+0
    43C3 2516               SU   R5_L
    43C5 0605               STA  PAR1
    43C7 16D943             JPF  _divi13
    43CA 020621             LD   PAR2,LIB_BUF+1
    43CD 1506               TST  PAR2
    43CF 0A06               DEC  PAR2
    43D1 090F               INC  FLAG
    43D3 17DC43             JNF  _divi12
    43D6 022106             LD   LIB_BUF+1,PAR2
    43D9 022005 _divi13     LD   LIB_BUF+0,PAR1
    43DC 2122   _divi12     RWL  LIB_BUF+2
    43DE 20BD43             JLP  _divi11
    43E1 1C10               POP  R0
    43E3 021620 _multp06    LD   R5_L,LIB_BUF+0
    43E6 021721             LD   R5_H,LIB_BUF+1
    43E9 021422 _multp10    LD   R4_L,LIB_BUF+2
    43EC 021523             LD   R4_H,LIB_BUF+3
    43EF 1A                 RET
                
                divide_s:
                            ; Divide a 16-bit signed number by an other 16-bit signed number.
                            ; In : R4 = divident, R5 = divisor
                            ; Out: R4 = 16-bit result
                            ; Changes: ACCU, R4, R5
    43F0 1E                 PHL
    43F1 1B11               PSH  R1
    43F3 190741             JSR  signprepare
    43F6 194C43             JSR  divide_u
    43F9 0C11               ROR  R1
    43FB 170144             JNF  _divsgn1
    43FE 197540             JSR  negate_r4
    4401 1C11   _divsgn1    POP  R1
    4403 1F                 RTS
                
                sub32bit:
                            ;32-bit subtraction
    4404 0414               LDA  R4_L
    4406 2520               SU   LIB_BUF+0
    4408 0614               STA  R4_L
    440A 0415               LDA  R4_H
    440C 1121               SUB  LIB_BUF+1
    440E 0615               STA  R4_H
    4410 0416               LDA  R5_L
    4412 1122               SUB  LIB_BUF+2
    4414 0616               STA  R5_L
    4416 0417               LDA  R5_H
    4418 1123               SUB  LIB_BUF+3
    441A 0617               STA  R5_H
    441C 1A                 RET
                ;[File: my4th-rom_8MHz.asm]
                ;[File: forth_stacks.asm]
                ;------------------------------------------------------------------------------
                ; Implementation of the various Forth stacks
                ;------------------------------------------------------------------------------
                
                ;------------------------------------------------------------------------------
                ;  System Data Stack (34 bytes)
                ;------------------------------------------------------------------------------
                
                syss_push:
                            ;Push a byte to the system stack
                            ;Input:   ACCU
                            ;Changes: PTR, ACCU
    441D 020C96             LD   PTR_L,SYSSP
    4420 010DFE             LD   PTR_H,#>SYSDATASTACK
    4423 07                 SAP
    4424 0996               INC  SYSSP
    4426 1A                 RET
                
                syss_pop:
                            ;Pop a byte from the system stack
                            ;Output:  R4
                            ;Changes: PTR, ACCU
    4427 0A96               DEC  SYSSP
    4429 020C96             LD   PTR_L,SYSSP
    442C 010DFE             LD   PTR_H,#>SYSDATASTACK
    442F 05                 LAP
    4430 1A                 RET
                
                ;------------------------------------------------------------------------------
                ;  Return Stack
                ;------------------------------------------------------------------------------
                
                retstk_push:
                            ;Push R4 to the return stack
                            ;The stack grow from bottom to top
                            ;Input:   R4
                            ;Changes: PTR, ACCU
    4431 020C97             LD   PTR_L,RETSP
    4434 010DFF             LD   PTR_H,#>RETURNSTACK
    4437 0414               LDA  R4_L
    4439 07                 SAP
    443A 090C               INC  PTR_L
    443C 0415               LDA  R4_H
    443E 07                 SAP
    443F 090C               INC  PTR_L
    4441 02970C             LD   RETSP,PTR_L
    4444 1A                 RET
                
                retstk_pop:
                            ;Pop R4 from the return stack
                            ;The stack grow from bottom to top
                            ;Input:   R4
                            ;Changes: PTR, ACCU
    4445 020C97             LD   PTR_L,RETSP
    4448 010DFF             LD   PTR_H,#>RETURNSTACK
    444B 0A0C               DEC  PTR_L
    444D 05                 LAP
    444E 0615               STA  R4_H
    4450 0A0C               DEC  PTR_L
    4452 05                 LAP
    4453 0614               STA  R4_L
    4455 02970C             LD   RETSP,PTR_L
    4458 1A                 RET
                
                ;------------------------------------------------------------------------------
                ;  Control Flow Stacks
                ;------------------------------------------------------------------------------
                
                ccfs_push_cp:
                            ;Push current CP value to the control flow stack
    4459 021464             LD  R4_L,CP_L
    445C 021565             LD  R4_H,CP_H
                ccfs_push:
                            ;Push a word to the control flow stack for compiler constructs
                            ;Input:   R4
                            ;Changes: PTR, ACCU
                            ; LDA  #<CCTLFLOWSTACK
                            ; CMP  CCFSP
                            ; JPF  Error_Stack   ; stack overflow  (don't check the lower bound, CMP is too slow)
    445F 020C98             LD   PTR_L,CCFSP
    4462 010DFF             LD   PTR_H,#>CCTLFLOWSTACK
    4465 0A0C               DEC  PTR_L
    4467 0415               LDA  R4_H
    4469 07                 SAP
    446A 0A0C               DEC  PTR_L
    446C 0414               LDA  R4_L
    446E 07                 SAP
    446F 02980C             LD   CCFSP,PTR_L
    4472 1A                 RET
                
                ccfs_pop:
                            ;Pop a word from the control flow stack for compiler constructs
                            ;Output:  R4
                            ;Changes: PTR, ACCU
    4473 03C0               LDA  #<(CCTLFLOWSTACK+CCTLF_STK_SZ)
    4475 1498               CMP  CCFSP
    4477 16294A             JPF  Error_Stack   ; stack underflow
    447A 020C98             LD   PTR_L,CCFSP
    447D 010DFF             LD   PTR_H,#>CCTLFLOWSTACK
    4480 05                 LAP
    4481 090C               INC  PTR_L
    4483 0614               STA  R4_L
    4485 05                 LAP
    4486 090C               INC  PTR_L
    4488 0615               STA  R4_H
    448A 02980C             LD   CCFSP,PTR_L
    448D 1A                 RET
                
                lcfs_push:
                            ;Push a word to the control flow stack for loops
                            ;Input:   R4
                            ;Changes: PTR, ACCU
                            ; LDA  #<LCTLFLOWSTACK
                            ; CMP  LCFSP
                            ; JPF  Error_Stack   ; stack overflow  (don't check the lower bound, CMP is too slow)
    448E 020C99             LD   PTR_L,LCFSP
    4491 010DFF             LD   PTR_H,#>LCTLFLOWSTACK
    4494 0A0C               DEC  PTR_L
    4496 0415               LDA  R4_H
    4498 07                 SAP
    4499 0A0C               DEC  PTR_L
    449B 0414               LDA  R4_L
    449D 07                 SAP
    449E 02990C             LD   LCFSP,PTR_L
    44A1 1A                 RET
                
                lcfs_pop:
                            ;Pop a word from the control flow stack for loops
                            ;Output:  R4
                            ;Changes: PTR, ACCU
    44A2 0300               LDA  #<(LCTLFLOWSTACK+LCTLF_STK_SZ)
    44A4 1499               CMP  LCFSP
    44A6 16294A             JPF  Error_Stack   ; stack underflow
    44A9 020C99             LD   PTR_L,LCFSP
    44AC 010DFF             LD   PTR_H,#>LCTLFLOWSTACK
    44AF 05                 LAP
    44B0 090C               INC  PTR_L
    44B2 0614               STA  R4_L
    44B4 05                 LAP
    44B5 090C               INC  PTR_L
    44B7 0615               STA  R4_H
    44B9 02990C             LD   LCFSP,PTR_L
    44BC 1A                 RET
                
                ;------------------------------------------------------------------------------
                ;  Data Stack
                ;------------------------------------------------------------------------------
                
                push_flag:
    44BD 17C944             JNF  push_data_zero
                
                push_data_ffff:
    44C0 0114FF             LD   R4_L,#0xFF
    44C3 021514             LD   R4_H,R4_L
    44C6 18DB44             JMP  push_data_R4
                
                push_data_zero:
    44C9 011400             LD   R4_L,#0
    44CC 021514 _pushR4LR4L LD   R4_H,R4_L
    44CF 18DB44             JMP  push_data_R4
                
                push_data_accu_ret:
    44D2 0614               STA  R4_L
                push_data_R4L_ret:
    44D4 011500             LD   R4_H,#0
                push_data_R4_ret:
    44D7 1C0B               POP  LR_H
    44D9 1C0A               POP  LR_L
                push_data_R4:
                            ;Push some data to the stack
                            ;Input:   R4 contains the 16-bit data
                            ;Note: An out-of-bounds-check is not done to speed up things a bit!
    44DB 02A307             LD   RSP,SP
    44DE 020795             LD   SP,fPSP
    44E1 1B14               PSH  R4_L
    44E3 1B15               PSH  R4_H
    44E5 029507             LD   fPSP,SP
    44E8 0207A3             LD   SP,RSP
    44EB 1A                 RET
                
                push_data_1:
    44EC 0301               LDA  #1
                push_data_accu:
                            ;Push 8-bit data to the stack
                            ;Input:   ACCU contains the byte
                            ;Note: An out-of-bounds-check is not done to speed up things a bit!
    44EE 0614               STA  R4_L
    44F0 011500             LD   R4_H,#0
    44F3 18DB44             JMP  push_data_R4
                
                push_data_R4_R5_ret:
    44F6 19DB44             JSR  push_data_R4
                push_data_R5_ret:
    44F9 1C0B               POP  LR_H
    44FB 1C0A               POP  LR_L
                push_data_R5:
                            ;Push some data to the stack
                            ;Input:   R5 contains the 16-bit data
                            ;Note: An out-of-bounds-check is not done to speed up things a bit!
    44FD 02A307             LD   RSP,SP
    4500 020795             LD   SP,fPSP
    4503 1B16   _pshr5_1    PSH  R5_L
    4505 1B17               PSH  R5_H
    4507 029507             LD   fPSP,SP
    450A 0207A3             LD   SP,RSP
    450D 1A                 RET
                
                pop_data_R4:
                            ;Pop some data from the stack
                            ;Output:  R4 contains the 16-bit data
    450E 1595               TST  fPSP
    4510 16294A             JPF  Error_Stack  ; stack underflow (check it because otherwise the callstack would be corrupted)
    4513 02A307             LD   RSP,SP
    4516 020795             LD   SP,fPSP
    4519 1C15               POP  R4_H
    451B 1C14               POP  R4_L
    451D 029507             LD   fPSP,SP
    4520 0207A3             LD   SP,RSP
    4523 1A                 RET
                
                pop_data_R5:
                            ;Pop some data from the stack
                            ;Output:  R5 contains the 16-bit data
    4524 1595               TST  fPSP
    4526 16294A             JPF  Error_Stack  ; stack underflow (check it because otherwise the callstack would be corrupted)
    4529 02A307             LD   RSP,SP
    452C 020795             LD   SP,fPSP
    452F 1C17               POP  R5_H
    4531 1C16               POP  R5_L
    4533 029507             LD   fPSP,SP
    4536 0207A3             LD   SP,RSP
    4539 1A                 RET
                
                pop_data_R4_R5:
                            ;Pop R4 and R5 from the data stack (R4 first, then R5)
                            ;Output:  R4 and R5
    453A 1595               TST  fPSP
    453C 16294A             JPF  Error_Stack  ; stack underflow (check it because otherwise the callstack would be corrupted)
    453F 02A307             LD   RSP,SP
    4542 020795             LD   SP,fPSP
    4545 1C15               POP  R4_H
    4547 1C14               POP  R4_L
    4549 1507               TST  SP
    454B 16294A             JPF  Error_Stack  ; stack underflow (check it because otherwise the callstack would be corrupted)
    454E 1C17               POP  R5_H
    4550 1C16               POP  R5_L
    4552 029507             LD   fPSP,SP
    4555 0207A3             LD   SP,RSP
    4558 1A                 RET
                
                pop_data_R5_R4:
                            ;Pop R5 and R4 from the data stack (R5 first, then R4)
                            ;Output:  R4 and R5
    4559 1595               TST  fPSP
    455B 16294A             JPF  Error_Stack  ; stack underflow (check it because otherwise the callstack would be corrupted)
    455E 02A307             LD   RSP,SP
    4561 020795             LD   SP,fPSP
    4564 1C17               POP  R5_H
    4566 1C16               POP  R5_L
    4568 1507               TST  SP
    456A 16294A             JPF  Error_Stack  ; stack underflow (check it because otherwise the callstack would be corrupted)
    456D 1C15               POP  R4_H
    456F 1C14               POP  R4_L
    4571 029507             LD   fPSP,SP
    4574 0207A3             LD   SP,RSP
    4577 1A                 RET
                
                dstack_2rot:
                            ;rotate data stack (Forth 2ROT word)
                            ;( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
    4578 02A307             LD   RSP,SP
    457B 020795             LD   SP,fPSP
    457E 1C20               POP  LIB_BUF+0
    4580 1C21               POP  LIB_BUF+1
    4582 1C22               POP  LIB_BUF+2
    4584 1C23               POP  LIB_BUF+3
    4586 1C24               POP  LIB_BUF+4
    4588 1C25               POP  LIB_BUF+5
    458A 1C7E               POP  MATH_BUF+0
    458C 1C7F               POP  MATH_BUF+1
    458E 1C17               POP  R5_H
    4590 1C16               POP  R5_L
    4592 1C15               POP  R4_H
    4594 1C14               POP  R4_L
    4596 1B7F               PSH  MATH_BUF+1
    4598 1B7E               PSH  MATH_BUF+0
    459A 1B25               PSH  LIB_BUF+5
    459C 1B24               PSH  LIB_BUF+4
    459E 1B23   _dstkpsh8   PSH  LIB_BUF+3   ;x3
    45A0 1B22               PSH  LIB_BUF+2
    45A2 1B21               PSH  LIB_BUF+1   ;x4
    45A4 1B20               PSH  LIB_BUF+0
    45A6 1B14               PSH  R4_L        ;x1
    45A8 1B15               PSH  R4_H
    45AA 180345             JMP  _pshr5_1    ;x2
                
                dstack_2swap:
                            ;2swap ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
    45AD 02A307             LD   RSP,SP
    45B0 020795             LD   SP,fPSP
    45B3 1C20               POP  LIB_BUF+0
    45B5 1C21               POP  LIB_BUF+1
    45B7 1C22               POP  LIB_BUF+2
    45B9 1C23               POP  LIB_BUF+3
    45BB 1C17               POP  R5_H
    45BD 1C16               POP  R5_L
    45BF 1C15               POP  R4_H
    45C1 1C14               POP  R4_L
    45C3 189E45             JMP  _dstkpsh8
                
                push_constant_inline:
                            ;Push a constant value that is inlined to the code to the data stack.
                            ;The caller must do "JSR push_constant_inline" followed by two data bytes (lo/hi)
    45C6 02A307             LD   RSP,SP
    45C9 020795             LD   SP,fPSP
    45CC 020C0A             LD   PTR_L,LR_L
    45CF 020D0B             LD   PTR_H,LR_H
    45D2 05     _pci03      LAP
    45D3 1B0E               PSH
    45D5 090C               INC  PTR_L
    45D7 150C               TST  PTR_L
    45D9 17DE45             JNF  _pci01
    45DC 090D               INC  PTR_H
    45DE 05     _pci01      LAP
    45DF 1B0E               PSH
    45E1 090C               INC  PTR_L
    45E3 150C               TST  PTR_L
    45E5 17EA45             JNF  _pci02
    45E8 090D               INC  PTR_H
    45EA 020A0C _pci02      LD   LR_L,PTR_L
    45ED 020B0D             LD   LR_H,PTR_H
    45F0 029507             LD   fPSP,SP
    45F3 0207A3             LD   SP,RSP
    45F6 1A                 RET
                
                push_2constant_inline:
                            ;Push a constant value that is inlined to the code to the data stack.
                            ;The caller must do "JSR push_constant_inline" followed by two data bytes (lo/hi)
    45F7 02A307             LD   RSP,SP
    45FA 020795             LD   SP,fPSP
    45FD 020C0A             LD   PTR_L,LR_L
    4600 020D0B             LD   PTR_H,LR_H
    4603 05                 LAP
    4604 1B0E               PSH
    4606 090C               INC  PTR_L
    4608 150C               TST  PTR_L
    460A 170F46             JNF  _pci04
    460D 090D               INC  PTR_H
    460F 05     _pci04      LAP
    4610 1B0E               PSH
    4612 090C               INC  PTR_L
    4614 150C               TST  PTR_L
    4616 17D245             JNF  _pci03
    4619 090D               INC  PTR_H
    461B 18D245             JMP  _pci03
                ;[File: my4th-rom_8MHz.asm]
                ;[File: forth_main.asm]
                ;------------------------------------------------------------------------------
                ; This is a simple Forth implementation for My4TH
                ;------------------------------------------------------------------------------
                ; This software is provided "as is". It is licensed to you under the
                ; Creative Commons Attribution-ShareAlike 4.0 International License.
                ; Written in 2022 by Dennis Kuschel, dennis_k@freenet.de, www.mynor.org
                ;------------------------------------------------------------------------------
                
                ;Constants
                
                LPG           SET 0xF000        ; start address of last 4kB memory page
                
                FORTH_START   SET 0x8400        ; Start of forth memory region. The region 0x8400 to 0x842E is used by the Forth binary program header.
                RSVD_BYTE     SET 0x842F        ; 1 unused byte
                HEAP_START    SET 0x8430        ; start of free memory (for the dictionary)
                HEAP_END      SET LPG+0x0CFF    ; last byte of the heap
                STACK_SPLIT   SET 0x80          ; The lower half of the call stack is used for the data stack.
                                                ; That means, the data stack has a size of 128 bytes, like the call stack.
                
                DATA_STACK_SZ SET STACK_SPLIT   ; size of the data stack
                DATA_STACK    SET 0x8100        ; start of the data stack. It grows upwards.
                                                ; the data stack is at 0x8100 - 0x817F, the callstack is at 0x8180 - 0x81FF
                USER_MEMORY   SET LPG+0x0D00    ; 256 bytes of memory for the USER
                EDIT_STRUCT   SET LPG+0x0E00    ; 6 bytes for a data structure used by the EDITor
                SYSDATASTACK  SET LPG+0x0E06    ; 42 bytes for the system data stack
                SYS_BUF       SET LPG+0x0E30    ; 112 bytes for forth system internal use (ACCEPT word and EDITor), also used for NUM_BUF and WORD_BUF
                PAD_MEMORY    SET LPG+0x0EA0    ; 96 bytes for the PAD transient area (must be at least 84 bytes)
                PAD_SIZE      SET 0x60
                EVALUATE_BUF  SET LPG+0x0F00    ; 128 bytes for the EVALUATE word (to store a zero-terminated string)
                CCTLF_STK_SZ  SET 0x40
                CCTLFLOWSTACK SET LPG+0x0F80    ; 32 words for the control flow stack for conditional jumps (allows up to 32 nested IFs or other constructs)
                LCTLF_STK_SZ  SET 0x40
                LCTLFLOWSTACK SET LPG+0x0FC0    ; 32 words for the loop control stack (allows up to 16 nested loops)
                RETURNSTACK   SET CCTLFLOWSTACK ; the return stack shares the space with the control flow stack, but it increases from bottom to top
                
                NUM_BUF       SET SYS_BUF       ; use system buffer also for pictured numeric output string
                NUMBUF_SZ     SET 112           ; size of the system buffer
                
                WORD_BUF      SET SYS_BUF+64    ; transient region for the word "WORD"
                
                FTH_HDR_FLAG  SET 0x14          ; file header flag for FORTH memory images saved via "save-forth"
                BIN_HDR_FLAG  SET 0x1B          ; file header flag for binary driver images
                FL_IMMEDIATE  SET 0x80          ; marks a word as "IMMEDIATE", must be bit 7 so it is faster to evaluate
                
                ;------------------------------------------------------------------------------
                ; The "main program":
                ;------------------------------------------------------------------------------
                
                init_vectors:
                            ;initialize vectors and a first set of Forth variables
                            ;this routine gets called when MyNOR is reset
    461E 0318               LDA  #0x18
    4620 0655               STA  VECT_INPUT+0
    4622 0652               STA  VECT_OUTPUT+0
    4624 0658               STA  VECT_OK+0
    4626 065B               STA  VECT_PROMPT+0
    4628 065E               STA  VECT_INPSTR+0
    462A 0661               STA  VECT_GETNBR+0
    462C 0300               LDA  #0
    462E 0656               STA  VECT_INPUT+1
    4630 0657               STA  VECT_INPUT+2
    4632 0653               STA  VECT_OUTPUT+1
    4634 0654               STA  VECT_OUTPUT+2
    4636 01595E             LD   VECT_OK+1,#<output_ok
    4639 015A4A             LD   VECT_OK+2,#>output_ok
    463C 015C79             LD   VECT_PROMPT+1,#<_prompt
    463F 015D47             LD   VECT_PROMPT+2,#>_prompt
    4642 015F4F             LD   VECT_INPSTR+1,#<input_str_loop
    4645 016035             LD   VECT_INPSTR+2,#>input_str_loop
    4648 016275             LD   VECT_GETNBR+1,#<get_number_fn
    464B 01634A             LD   VECT_GETNBR+2,#>get_number_fn
    464E 1A                 RET
                
                set_vector:
                            ;Set a vector to a new address
                            ;In: accu = vector number, R4 = new address
    464F 1E                 PHL
    4650 196946             JSR  getVectAdr
    4653 0414               LDA  R4_L
    4655 19D93A             JSR  sap_inc_ptr
    4658 0415               LDA  R4_H
    465A 07                 SAP
    465B 1F                 RTS
                
                get_vector:
                            ;Get the current address of a vector
                            ;In: accu = vector number, Out: R4 = address
    465C 1E                 PHL
    465D 196946             JSR  getVectAdr
    4660 19CE3A             JSR  lap_inc_ptr
    4663 0614               STA  R4_L
    4665 05                 LAP
    4666 0615               STA  R4_H
    4668 1F                 RTS
                
                getVectAdr:
    4669 0605               STA  PAR1
    466B 2405               AD   PAR1
    466D 2405               AD   PAR1
    466F 010553             AD   #VECTOR1+1
    4672 2405   
    4674 060C               STA  PTR_L
    4676 010D80             LD   PTR_H,#REGPAGE_HI
    4679 1A                 RET
                
                init_forth_1:
                            ;initialize the Forth system, part 1
    467A 011480             LD   R4_L,#<tab_fthVarInit
    467D 01157C             LD   R4_H,#>tab_fthVarInit
    4680 011664             LD   R5_L,#<VAR_INIT_START
    4683 011780             LD   R5_H,#REGPAGE_HI
    4686 01182F             LD   R6_L,#VAR_INIT_END-VAR_INIT_START
    4689 18804E             JMP  memcpy_short
                
                init_forth_2:
                            ;initialize the Forth system, part 2
    468C 010780             LD   SP,#STACK_SPLIT
    468F 019606             LD   SYSSP,#<SYSDATASTACK                  ; stack grows from bottom to top
    4692 019500             LD   fPSP,#<DATA_STACK                     ; stack grows from bottom to top
    4695 019780             LD   RETSP,#<RETURNSTACK                   ; stack grows from bottom to top
    4698 0198C0             LD   CCFSP,#<(CCTLFLOWSTACK+CCTLF_STK_SZ)  ; stack grows from top to bottom
    469B 019900             LD   LCFSP,#<(LCTLFLOWSTACK+LCTLF_STK_SZ)  ; stack grows from top to bottom
    469E 0300               LDA  #0
    46A0 069A               STA  STATE+0
    46A2 069B               STA  STATE+1
    46A4 068C               STA  NEXTINCHR
    46A6 1A                 RET
                
                forth_start:
                            ;Start the FORTH system (with autostart of a FORTH program)
    46A7 191E46             JSR  init_vectors
    46AA 197A46             JSR  init_forth_1
    46AD 198C46             JSR  init_forth_2
                            ;read screen 0, and get the autostart block number
    46B0 011400             LD   R4_L,#0
    46B3 011500             LD   R4_H,#0
    46B6 193038             JSR  fblockToEepromAddr
    46B9 163847             JPF  _fosta01
    46BC 199A38             JSR  eeprom_start_read
    46BF 163847             JPF  _fosta01
    46C2 011400             LD   R4_L,#0
    46C5 011500             LD   R4_H,#0
    46C8 011205             LD   R2,#5
    46CB 011100 _fosta02    LD   R1,#0
    46CE 192E2E             JSR  i2c_recv
    46D1 196F3B             JSR  is_digit
    46D4 16F446             JPF  _fosta03
    46D7 19E840             JSR  mul10
    46DA 030F               LDA  #0x0F
    46DC 0D10               AND  R0
    46DE 2414               AD   R4_L
    46E0 0614               STA  R4_L
    46E2 17E746             JNF  _fosta04
    46E5 0915               INC  R4_H
    46E7 0A12   _fosta04    DEC  R2
    46E9 1512               TST  R2
    46EB 17CB46             JNF  _fosta02
                            ;number too long
    46EE 199348 _fosta06    JSR  stop_i2cread
    46F1 183847             JMP  _fosta01
                _fosta03    ;finished with reading the autostart block number
    46F4 1320               CMP  #0x20
    46F6 17EE46             JNF  _fosta06
    46F9 199348             JSR  stop_i2cread
    46FC 1514               TST  R4_L
    46FE 170647             JNF  _fosta07
    4701 1515               TST  R4_H
    4703 163847             JPF  _fosta01
                _fosta07    ;print autostart message, wait if user interrupts autostart
                            PRINT text_autostart1
    4706 198633           JSR  printstrm
    4709 53               DB   <text_autostart1
    470A 79               DB   >text_autostart1
    470B 011600             LD   R5_L,#0
    470E 0117FE             LD   R5_H,#254
    4711 192B3D _fosta08    JSR  test_for_io_activity
    4714 173847             JNF  _fosta01
    4717 19033B             JSR  inc_r5
    471A 1516               TST  R5_L
    471C 171147             JNF  _fosta08
    471F 1517               TST  R5_H
    4721 171147             JNF  _fosta08
                            ;load the autostart block
                            PRINT text_autostart2
    4724 198633           JSR  printstrm
    4727 74               DB   <text_autostart2
    4728 79               DB   >text_autostart2
    4729 19DF33             JSR  print_decword
    472C 192233             JSR  print_nl
    472F 19DB44             JSR  push_data_R4
    4732 19E05F             JSR  c_load
    4735 185447             JMP  abort_restart
                _fosta01    ;no autostart configured, start the FORTH prompt
                
                restart_forth:
                            ;this is like a hard-reset of FORTH
    4738 010780             LD   SP,#STACK_SPLIT
    473B 191E46             JSR  init_vectors
                            PRINT text_heading1
    473E 198633           JSR  printstrm
    4741 A8               DB   <text_heading1
    4742 79               DB   >text_heading1
    4743 011408             LD   R4_L,#8
    4746 011500             LD   R4_H,#0
    4749 19DF33             JSR  print_decword
                            PRINT text_heading2
    474C 198633           JSR  printstrm
    474F C2               DB   <text_heading2
    4750 79               DB   >text_heading2
                
                forth_reinit:
    4751 197A46             JSR  init_forth_1
                
                abort_restart:
    4754 199D48             JSR  stop_eeprom_transfer
    4757 198C46             JSR  init_forth_2
    475A 0491               LDA  INPUTDEV
    475C 1302               CMP  #INDEV_REMOTE
    475E 176447             JNF  prompt
    4761 19073E             JSR  txferr_errorback
                
                prompt:     ;this is the input prompt
    4764 019780             LD   RETSP,#<RETURNSTACK
    4767 019100             LD   INPUTDEV,#INDEV_LOCAL ;required because this prevents sending also COK after CERR over UART
    476A 011050             LD   R0,#TIBUF_SZ
    476D 0114A0             LD   R4_L,#<TIBUF
    4770 011582             LD   R4_H,#>TIBUF
    4773 195B80             JSR  PROMPT_VECTOR  ; usually calls _prompt
    4776 186447             JMP  prompt
                _prompt     ;the Forth promt (R0 is the max. length of the input buffer
                            ;including the terminating zero, and R4 points to the input buffer)
    4779 019780             LD   RETSP,#<RETURNSTACK
    477C 193835             JSR  input_string   ; this function may not return, but will jump to execRemoteString directly
    477F 191833             JSR  print_space
    4782 19AF48             JSR  ld_ptr_tibuf
    4785 0300               LDA  #INDEV_LOCAL
    4787 19C348             JSR  input_parser
    478A 186447             JMP  prompt
                
                execRemoteString:
                            ;execute a string that was received via UART
                            ;PTR must point to the string
    478D 010780             LD   SP,#STACK_SPLIT
    4790 0302               LDA  #INDEV_REMOTE
    4792 19C348             JSR  input_parser
    4795 190B3E             JSR  txferr_okback
                forth_restart_prompt:
    4798 010780             LD   SP,#STACK_SPLIT
    479B 186447             JMP  prompt
                
                ;------------------------------------------------------------------------------
                ;  Forth program header in memory at 0x8400 (FORTH_START):
                ;
                ;   0x8400 : 0x14  - marking for Forth program (FTH_HDR_FLAG)
                ;   0x8401 : rver  - ROM version number
                ;   0x8402 : rsvd  - reserved byte
                ;   0x8403 : rsvd  - reserved byte
                ;   0x8404 : 6 system vectors
                ;   0x8416 : here  - pointer (2 bytes)
                ;   0x8418 : 8 word pointers for dictionary
                ;   0x8428 : UP user pointer
                ;   0x842A : BLK structure
                ;   0x8430 : start of dictionary
                ;
                ;------------------------------------------------------------------------------
                
                prepare_forth_program:
                            ;prepare to start a forth program
                            ;returns with FLAG=0 on success
    479E 1E                 PHL
    479F 010C00             LD   PTR_L,#<FORTH_START
    47A2 010D84             LD   PTR_H,#>FORTH_START
    47A5 19CE3A             JSR  lap_inc_ptr
    47A8 1314               CMP  #FTH_HDR_FLAG
    47AA 17CB3A             JNF  return_flag_1
    47AD 05                 LAP
    47AE 1312               CMP  #0x12
    47B0 16BB47             JPF  _fexf02
                _fexf01     ;wrong forth/rom version
                            PRINT text_wrongver
    47B3 198633           JSR  printstrm
    47B6 D7               DB   <text_wrongver
    47B7 78               DB   >text_wrongver
    47B8 18CB3A             JMP  return_flag_1
                _fexf02     ;start the program
    47BB 196A3B             JSR  pop_r7  ;save return address to R7
    47BE 197A46             JSR  init_forth_1
    47C1 198C46             JSR  init_forth_2
    47C4 19513B             JSR  psh_r7
    47C7 011404             LD   R4_L,#<(FORTH_START+4)
    47CA 011584             LD   R4_H,#>(FORTH_START+4)
    47CD 011652             LD   R5_L,#PRGHEADER
    47D0 011780             LD   R5_H,#REGPAGE_HI
    47D3 01182B             LD   R6_L,#PRGHDR_SIZE
    47D6 19804E             JSR  memcpy_short
    47D9 18C93A             JMP  return_flag_0
                
                start_forth_program:
                            ;Start a Forth Program that was already
                            ;loaded from EEPROM into RAM
    47DC 1E                 PHL
    47DD 199E47             JSR  prepare_forth_program
    47E0 16CA3A             JPF  return
                
                do_run:
                            ;find and execute run word
    47E3 01A1D3             LD   INPTR_L,#<text_run
    47E6 01A278             LD   INPTR_H,#>text_run
    47E9 011103             LD   R1,#3
    47EC 19314C             JSR  search_word
    47EF 160048             JPF  _doru01
    47F2 19FA49             JSR  exec_word
    47F5 0364               LDA  #<prompt
    47F7 1B0E               PSH
    47F9 0347               LDA  #>prompt
    47FB 1B0E               PSH
    47FD 187B49             JMP  _retOk
                _doru01     PRINT text_runerr
    4800 198633           JSR  printstrm
    4803 8F               DB   <text_runerr
    4804 78               DB   >text_runerr
    4805 185447             JMP  abort_restart
                
                load_line_into_filebuf:
                            ;load next line from EEPROM into filebuf
                            ;input: BLK = screen number, FILE_LNBR = line number
    4808 1E                 PHL
                load_line_into_filebuf_rts:
    4809 02148D             LD   R4_L,BLK_L
    480C 02158E             LD   R4_H,BLK_H
    480F 19DB44             JSR  push_data_R4
    4812 19AC4F             JSR  prep_eepblk
                            ;R4 += 64 * FILE_LNBR
    4815 021AA9             LD   R7_L,FILE_LNBR
    4818 011B00             LD   R7_H,#0
    481B 011006             LD   R0,#6
    481E 23                 CLC
    481F 211A   _lsf02      RWL  R7_L
    4821 201F48             JLP  _lsf02
    4824 0414               LDA  R4_L
    4826 241A               AD   R7_L
    4828 0614               STA  R4_L
    482A 0415               LDA  R4_H
    482C 101B               ADD  R7_H
    482E 0615               STA  R4_H
                            ;R3 = I2C device address
                            ;R4 = EEPROM memory address
    4830 19C64F             JSR  feep_start_read
                            ; Load a text line (64 bytes) from EEPROM and interpret it
    4833 011640             LD   R5_L,#64
    4836 011700             LD   R5_H,#0
    4839 018B01             LD   EEP_STATE,#1
    483C 19B648             JSR  ld_ptr_filebuf
    483F 0112E0             LD   R2,#0xE0
    4842 011100             LD   R1,#0
    4845 186C48             JMP  _lsf09
                            ;receive a byte
    4848 0A17   _lsf07      DEC  R5_H
    484A 0A16   _lsf01      DEC  R5_L
    484C 1516               TST  R5_L
    484E 175948             JNF  _lsf11
    4851 1517               TST  R5_H
    4853 175948             JNF  _lsf11
    4856 011101             LD   R1,#1
    4859 192E2E _lsf11      JSR  i2c_recv
    485C 0610               STA  R0
    485E 0D12               AND  R2
    4860 150E               TST
    4862 0410               LDA  R0
    4864 176948             JNF  _lsf08
    4867 0320               LDA  #0x20
    4869 19D93A _lsf08      JSR  sap_inc_ptr
    486C 1516   _lsf09      TST  R5_L
    486E 174A48             JNF  _lsf01
    4871 1517               TST  R5_H
    4873 174848             JNF  _lsf07
                            ;end of line / end of file
    4876 0300               LDA  #0
    4878 07                 SAP
    4879 190039             JSR  eeprom_stop
    487C 018B00             LD   EEP_STATE,#0
    487F 1F                 RTS
                
                interpret_filebuf_line:
                            ;parse the line
    4880 1E                 PHL
    4881 19B648             JSR  ld_ptr_filebuf
    4884 19053C             JSR  skip_space
    4887 05                 LAP
    4888 150E               TST
    488A 169248             JPF  _lsf10
    488D 0301               LDA  #INDEV_FILE
    488F 19C348             JSR  input_parser
    4892 1F     _lsf10      RTS
                
                stop_i2cread:   ;stop I2C read transfer
    4893 1E                 PHL
    4894 011101             LD   R1,#1
    4897 192E2E             JSR  i2c_recv
    489A 180339             JMP  eeprom_stop_ret
                
                stop_eeprom_transfer:
    489D 158B               TST  EEP_STATE
    489F 16CD3A             JPF  ret_opc
                recoverI2Cbus:
                            ;recover EEPROM
    48A2 1E                 PHL
                            ;send a pattern that recovers the I2C-bus
    48A3 199348             JSR  stop_i2cread
    48A6 19A72D             JSR  i2c_start
    48A9 018B00             LD   EEP_STATE,#0
    48AC 180339             JMP  eeprom_stop_ret
                
                ld_ptr_tibuf:
    48AF 010CA0             LD   PTR_L,#<TIBUF
    48B2 010D82             LD   PTR_H,#>TIBUF
    48B5 1A                 RET
                
                ld_ptr_filebuf:
    48B6 010CF0             LD   PTR_L,#<FILE_LINEBUF
    48B9 010D82             LD   PTR_H,#>FILE_LINEBUF
    48BC 1A                 RET
                
                ;------------------------------------------------------------------------------
                ;  Input Parser
                ;------------------------------------------------------------------------------
                
                evaluate:   ;Evaluate a zero-terminated string pointed by INPTR.
    48BD 020CA1             LD  PTR_L,INPTR_L
    48C0 020DA2             LD  PTR_H,INPTR_H
                
                input_parser:
                            ;Input:  PTR is the ptr to the input stream buffer.
                            ;        The buffer must be terminated with zero (CR not allowed in the buffer).
                            ;        ACCU must be set to the current input device
    48C3 1E                 PHL
    48C4 0691               STA  INPUTDEV
    48C6 19B149 _itp11      JSR  ld_inptr_ptr
    48C9 019200             LD   REFILL,#0
                itp_loop:
    48CC 1592   _itp01      TST  REFILL  ; quit early when REFILL was flagged for a screen/load
    48CE 176D49             JNF  _itp04
                            ;loop over all words in the input buffer and interpret them
                            ;skip leading space characters
    48D1 199249             JSR  skipSpaces
    48D4 19EB4B             JSR  get_word_len
    48D7 1511               TST  R1
    48D9 166D49             JPF  _itp04
                
                            ;test for special "words" with a length of one character
    48DC 0301               LDA  #1
    48DE 1411               CMP  R1
    48E0 17F148             JNF  _itp06
    48E3 19B849             JSR  ld_ptr_inptr
    48E6 05                 LAP
    48E7 1328               CMP  #'('
    48E9 165A49             JPF  _itp10  ;begin of comment
    48EC 135C               CMP  #'\\'
    48EE 166D49             JPF  _itp04  ;drop the end of the line
                
    48F1 159A   _itp06      TST  STATE
    48F3 171C49             JNF  _itp09  ;compile
                            ;interpret
    48F6 19314C             JSR  search_word
    48F9 171049             JNF  _itp16
                            ;read a number
    48FC 19674A             JSR  get_number
    48FF 16074A             JPF  Error_Word
    4902 19DB44             JSR  push_data_R4
    4905 1513               TST  R3
    4907 16CC48             JPF  _itp01  ;continue with next word
    490A 19FD44             JSR  push_data_R5
    490D 18CC48             JMP  _itp01  ;continue with next word
                            ;execute the word and continue with next word
    4910 02840C _itp16      LD   IPRSPACE+1,PTR_L
    4913 02850D             LD   IPRSPACE+2,PTR_H
    4916 198149             JSR  skipSpace
                            ;execute the word and jump to itp_loop
    4919 188380             JMP  IPRSPACE_JMP
                
    491C 19124A _itp09      JSR  memcheck
                            ;try to find the word in the dictionary
    491F 19314C             JSR  search_word
    4922 163449             JPF  _itp05 ;word not found
                            ;word found, is it marked "immediate"?
    4925 0380               LDA  #FL_IMMEDIATE
    4927 0D12               AND  R2
    4929 150E               TST
    492B 175149             JNF  _itp14
                            ;word found, store a reference to it in memory
    492E 192B4D             JSR  add_word_call
    4931 185449             JMP  _itp02  ;continue with next word
                _itp05      ;try to interpret the input as number
    4934 19674A             JSR  get_number
    4937 16074A             JPF  Error_Word
                            ;number read, store it as code in memory
    493A 1513               TST  R3
    493C 174549             JNF  _itp15
    493F 19AF4D             JSR  add_16bit_literal
    4942 185449             JMP  _itp02  ;continue with next word
    4945 19DB44 _itp15      JSR  push_data_R4
    4948 19FD44             JSR  push_data_R5
    494B 19F24D             JSR  popR4R5_add_32bit_literal
    494E 185449             JMP  _itp02
                
                _itp14      ;execute the "immediate" word
    4951 19FA49             JSR  exec_word
    4954 19124A _itp02      JSR  memcheck
    4957 18CC48             JMP  _itp01  ;continue with next word
                
                _itp10      ;skip comment until next ')' in the input buffer
    495A 19E43A             JSR  inc_ptr_lap
    495D 150E               TST
    495F 16074A             JPF  Error_Word
    4962 1329               CMP  #')'
    4964 175A49             JNF  _itp10
    4967 19DA3A             JSR  inc_ptr
    496A 18C648             JMP  _itp11
                
                _itp04      ;end of buffer reached
    496D 159A               TST  STATE
    496F 167B49             JPF  _retOk
                            ;return with message "compiled"
                            PRINT text_compiled
    4972 198633           JSR  printstrm
    4975 C8               DB   <text_compiled
    4976 78               DB   >text_compiled
    4977 18C93A             JMP  return_flag_0
                printOkStatus:
    497A 1E                 PHL
                _retOk      ;return with status "ok"
    497B 195880             JSR  OK_VECTOR
    497E 18CB3A             JMP  return_flag_1
                
                skipSpace:  ;Skip one space character in the input buffer
    4981 1E                 PHL
    4982 19B849             JSR  ld_ptr_inptr
    4985 05                 LAP
    4986 1320               CMP  #0x20
    4988 17CA3A             JNF  return
    498B 19DA3A             JSR  inc_ptr
    498E 19B149             JSR  ld_inptr_ptr
    4991 1F                 RTS
                
                skipSpaces:
                            ;Skip space characters in the input buffer
                            ;returns: the character that follows the spaces in ACCU,
                            ;         PTR pointing to position after the spaces
    4992 020CA1             LD   PTR_L,INPTR_L
    4995 020DA2             LD   PTR_H,INPTR_H
    4998 05     _sks01      LAP
    4999 1320               CMP  #0x20
    499B 17B149             JNF  ld_inptr_ptr
    499E 090C               INC  PTR_L
    49A0 150C               TST  PTR_L
    49A2 179849             JNF  _sks01
    49A5 090D               INC  PTR_H
    49A7 189849             JMP  _sks01
                
                ld_r4_ptr:  ;load R4 with PTR
    49AA 02140C             LD   R4_L,PTR_L
    49AD 02150D             LD   R4_H,PTR_H
    49B0 1A                 RET
                
                ld_inptr_ptr:
    49B1 02A10C             LD   INPTR_L,PTR_L
    49B4 02A20D             LD   INPTR_H,PTR_H
    49B7 1A                 RET
                
                ld_ptr_inptr:  ;load PTR with INPTR
    49B8 020CA1             LD   PTR_L,INPTR_L
    49BB 020DA2             LD   PTR_H,INPTR_H
    49BE 1A                 RET
                
                push_data_inptr:  ;push INPTR to data stack
    49BF 0214A1             LD   R4_L,INPTR_L
    49C2 0215A2             LD   R4_H,INPTR_H
    49C5 18DB44             JMP  push_data_R4
                
                push_inptr: ;push the input ptr to the system data stack
    49C8 010CA1             LD   PTR_L,#INPTR_L
                
                push_zpvar: ;push zero-page variable to the system data stack
                            ;In: PTR_L pointer to variable
    49CB 1E                 PHL
    49CC 010D80             LD   PTR_H,#REGPAGE_HI
    49CF 05                 LAP
    49D0 0605               STA  PAR1
    49D2 090C               INC  PTR_L
    49D4 05                 LAP
    49D5 191D44             JSR  syss_push
    49D8 0405               LDA  PAR1
    49DA 191D44             JSR  syss_push
    49DD 1F                 RTS
                
                pop_inptr:  ;push the input ptr to the system data stack
    49DE 010CA1             LD   PTR_L,#INPTR_L
                
                pop_zpvar:  ;pop zero-page variable from the system data stack
                            ;In: PTR_L pointer to variable
    49E1 1E                 PHL
                pop_zpvar_rts:
    49E2 1B0C               PSH  PTR_L
    49E4 192744             JSR  syss_pop
    49E7 0605               STA  PAR1
    49E9 192744             JSR  syss_pop
    49EC 1C0C               POP  PTR_L
    49EE 010D80             LD   PTR_H,#REGPAGE_HI
    49F1 090C               INC  PTR_L
    49F3 07                 SAP
    49F4 0A0C               DEC  PTR_L
    49F6 0405               LDA  PAR1
    49F8 07                 SAP
    49F9 1F                 RTS
                
                exec_word:
                            ;execute the word that is referenced by PTR
    49FA 1E                 PHL
    49FB 027E0C             LD   JSRSPACE+1,PTR_L
    49FE 027F0D             LD   JSRSPACE+2,PTR_H
                            ;skip one space character
    4A01 198149             JSR  skipSpace
                            ;execute the word and return
    4A04 187D80             JMP  JSRSPACE_JMP
                
                Error_Word:      ;the word pointed by INPTR is unknown
                            PRINT text_errWord
    4A07 198633           JSR  printstrm
    4A0A 57               DB   <text_errWord
    4A0B 78               DB   >text_errWord
    4A0C 19474A             JSR  printNextWord
    4A0F 18394A             JMP  _err_prnl
                
                memcheck:   ;check if free memory is still available, quit with an error message if not
    4A12 1B0E               PSH
    4A14 03FD               LDA  #>(HEAP_END+1)
    4A16 1465               CMP  CP_H
    4A18 1C0E               POP
    4A1A 17CD3A             JNF  ret_opc
                Error_Mem:       ;out of memory error
    4A1D 0341               LDA  #<text_errMem
    4A1F 01                 DB   0x01  ; trick: jumps over next two bytes, but overwrites register TEMP5
                Error_Number:
    4A20 0368               LDA  #<text_errNumber
    4A22 01                 DB   0x01  ; trick: jumps over next two bytes, but overwrites register TEMP5
                Error_Syntax:    ;wrong syntax
    4A23 030D               LDA  #<text_errSyntax
    4A25 01                 DB   0x01  ; trick: jumps over next two bytes, but overwrites register TEMP5
                Error_Value:     ;value error
    4A26 0317               LDA  #<text_errValue
    4A28 01                 DB   0x01  ; trick: jumps over next two bytes, but overwrites register TEMP5
                Error_Stack:     ;stack over- or underflow
    4A29 0320               LDA  #<text_errStack
    4A2B 01                 DB   0x01  ; trick: jumps over next two bytes, but overwrites register TEMP5
                Error_ToLong:    ;word name too long
    4A2C 0329               LDA  #<text_errTooLong
    4A2E 01                 DB   0x01  ; trick: jumps over next two bytes, but overwrites register TEMP5
                Error_Quote:     ;return with error, the " is missing
    4A2F 0300               LDA  #<text_errQuote
    4A31 060C   _pr_err     STA  PTR_L
    4A33 010D78             LD   PTR_H,#>forth_strings_start
    4A36 194633             JSR  print_str
    4A39 192233 _err_prnl   JSR  print_nl
    4A3C 185447             JMP  abort_restart
                
                Error_InOut:     ;I/O Error
    4A3F 19A248             JSR  recoverI2Cbus
    4A42 0335               LDA  #<text_errInOut
    4A44 18314A             JMP  _pr_err
                
                printNextWord:
                            ;print the next word stored in the input buffer
    4A47 1E                 PHL
    4A48 19EB4B             JSR  get_word_len
    4A4B 19B849             JSR  ld_ptr_inptr
    4A4E 1511   _pnw01      TST  R1
    4A50 16CA3A             JPF  return
    4A53 19CE3A             JSR  lap_inc_ptr
    4A56 192433             JSR  print_char
    4A59 0A11               DEC  R1
    4A5B 184E4A             JMP  _pnw01
                
                output_ok:  ;print the "OK" status
    4A5E 010CEE             LD   PTR_L,#<text_forth_ok
    4A61 010D78             LD   PTR_H,#>text_forth_ok
    4A64 184633             JMP  print_str
                
                ;------------------------------------------------------------------------------
                ;  Read Numbers
                ;------------------------------------------------------------------------------
                
                get_number:
                            ;Tries to read a number from the input buffer.
                            ;Input:   INPTR points to the possible number in the input buffer.
                            ;         R1 must contain the length of the word.
                            ;         The number must be terminated by SPACE, ';' or NULL
                            ;Output:  If a number could be read, FLAG is set to 0
                            ;         R3 is 0 for 16-bit and FF for 32-bit,
                            ;         R4/R5 contains the read 16/32-bit number, and
                            ;         INPTR points behind the word
                            ;Changes: ACCU,R0,R1,R2,R4,R5,PTR,FLAG
    4A67 1E                 PHL
    4A68 19B849             JSR  ld_ptr_inptr
    4A6B 196180             JSR  GETNBR_VECTOR
    4A6E 16CA3A             JPF  return
    4A71 19B149 _rdnb06     JSR  ld_inptr_ptr
    4A74 1F                 RTS
                
                get_number_fn:
    4A75 1E                 PHL
                            ;check if the character after the possible number is a dot (do mark a 32-bit number)
    4A76 193D3B             JSR  psh_ptr
    4A79 0411               LDA  R1
    4A7B 0A0E               DEC
    4A7D 240C               AD   PTR_L
    4A7F 060C               STA  PTR_L
    4A81 17864A             JNF  _rdnb05
    4A84 090D               INC  PTR_H
    4A86 05     _rdnb05     LAP
    4A87 19563B             JSR  pop_ptr
    4A8A 132E               CMP  #'.'
    4A8C 16F74A             JPF  getnum32bit
                            ;check the BASE
    4A8F 030A               LDA  #10
    4A91 1489               CMP  BASE
    4A93 17FF4A             JNF  getnum16bit  ;need slow conversion functions for other base than 10
                            ;get first digit
    4A96 19CE3A             JSR  lap_inc_ptr
    4A99 011200             LD   R2,#0   ; sign
    4A9C 132D               CMP  #'-'
    4A9E 17A84A             JNF  _rdnb03
    4AA1 0912               INC  R2      ; mark number as negative
    4AA3 0A11               DEC  R1
    4AA5 19CE3A             JSR  lap_inc_ptr
    4AA8 196F3B _rdnb03     JSR  is_digit
    4AAB 16CA3A             JPF  return  ; error, not a valid decimal number
    4AAE 01050F             AND  #0x0F
    4AB1 0D05   
    4AB3 0614               STA  R4_L
    4AB5 011500             LD   R4_H,#0
                _rdnb01     ;loop: read more digits
    4AB8 0A11               DEC  R1
    4ABA 1511               TST  R1
    4ABC 16E64A             JPF  _rdnb02 ; jump if end of stream
    4ABF 19CE3A             JSR  lap_inc_ptr
    4AC2 196F3B             JSR  is_digit
    4AC5 16CA3A             JPF  return  ; error, not a valid number
    4AC8 0610               STA  R0
                            ;multiply R4 with 10
    4ACA 19E840             JSR  mul10
    4ACD 16204A             JPF  Error_Number
                            ;add R0 to R4
    4AD0 030F               LDA  #0x0F
    4AD2 0D10               AND  R0
    4AD4 23                 CLC
    4AD5 1014               ADD  R4_L
    4AD7 0614               STA  R4_L
    4AD9 17B84A             JNF  _rdnb01
    4ADC 0915               INC  R4_H
    4ADE 1515               TST  R4_H
    4AE0 17B84A             JNF  _rdnb01
    4AE3 18204A             JMP  Error_Number
                _rdnb02     ;end of stream reached, set sign of the value and return
    4AE6 1512               TST  R2
    4AE8 16F14A             JPF  _rdnb04
    4AEB 19AE40             JSR  inv_r4
    4AEE 19F93A             JSR  inc_r4
    4AF1 011300 _rdnb04     LD   R3,#0  ;flag for 16-bit number
    4AF4 18C93A             JMP  return_flag_0
                
                getnum32bit:
                            ;read a 32-bit number with respect to BASE from the input buffer
    4AF7 0113FF             LD   R3,#0xFF
    4AFA 0A11               DEC  R1  ;remove the dot at the end
    4AFC 18024B             JMP  _gn32b04
                getnum16bit:
                            ;read a 16-bit number with respect to BASE from the input buffer
    4AFF 011300             LD   R3,#0
                _gn32b04    ;get first digit
    4B02 19CE3A             JSR  lap_inc_ptr
    4B05 011200             LD   R2,#0   ; sign
    4B08 132D               CMP  #'-'
    4B0A 17194B             JNF  _gn32b01
    4B0D 0912               INC  R2      ; mark number as negative
    4B0F 0A11               DEC  R1
    4B11 1511               TST  R1
    4B13 16CA3A             JPF  return  ; error, sign but no number
    4B16 19CE3A             JSR  lap_inc_ptr
    4B19 19C34B _gn32b01    JSR  char2binnum
    4B1C 17CB3A             JNF  return_flag_1  ; error, no valid digit for current BASE
    4B1F 0614               STA  R4_L
    4B21 0300               LDA  #0
    4B23 0615               STA  R4_H
    4B25 0616               STA  R5_L
    4B27 0617               STA  R5_H
    4B29 0A11   _gn32b03    DEC  R1
    4B2B 1511               TST  R1
    4B2D 16A34B             JPF  _gn32b02
                            ;multiply number in R4/R5 with BASE
    4B30 0300               LDA  #0
    4B32 0620               STA  LIB_BUF+0
    4B34 0621               STA  LIB_BUF+1
    4B36 0622               STA  LIB_BUF+2
    4B38 0623               STA  LIB_BUF+3
    4B3A 010520             LD   PAR1,#32
    4B3D 18484B             JMP  _mul3201
    4B40 0B20   _mul3202    ROL  LIB_BUF+0
    4B42 0B21               ROL  LIB_BUF+1
    4B44 0B22               ROL  LIB_BUF+2
    4B46 0B23               ROL  LIB_BUF+3
    4B48 0B14   _mul3201    ROL  R4_L
    4B4A 0B15               ROL  R4_H
    4B4C 0B16               ROL  R5_L
    4B4E 0B17               ROL  R5_H
    4B50 176C4B             JNF  _mul3203
    4B53 0420               LDA  LIB_BUF+0
    4B55 2489               AD   BASE
    4B57 0620               STA  LIB_BUF+0
    4B59 176C4B             JNF  _mul3203
    4B5C 0921               INC  LIB_BUF+1
    4B5E 1521               TST  LIB_BUF+1
    4B60 176C4B             JNF  _mul3203
    4B63 0922               INC  LIB_BUF+2
    4B65 1522               TST  LIB_BUF+2
    4B67 176C4B             JNF  _mul3203
    4B6A 0923               INC  LIB_BUF+3
    4B6C 0A05   _mul3203    DEC  PAR1
    4B6E 1505               TST  PAR1
    4B70 17404B             JNF  _mul3202
    4B73 021420             LD   R4_L,LIB_BUF+0
    4B76 021521             LD   R4_H,LIB_BUF+1
    4B79 021622             LD   R5_L,LIB_BUF+2
    4B7C 021723             LD   R5_H,LIB_BUF+3
                            ;add next digit
    4B7F 05                 LAP
    4B80 19C34B             JSR  char2binnum
    4B83 17CB3A             JNF  return_flag_1  ; error, no valid digit for current BASE
    4B86 19DA3A             JSR  inc_ptr
    4B89 2414               AD   R4_L
    4B8B 0614               STA  R4_L
    4B8D 17294B             JNF  _gn32b03
    4B90 0915               INC  R4_H
    4B92 1515               TST  R4_H
    4B94 17294B             JNF  _gn32b03
    4B97 0916               INC  R5_L
    4B99 1516               TST  R5_L
    4B9B 17294B             JNF  _gn32b03
    4B9E 0917               INC  R5_H
    4BA0 18294B             JMP  _gn32b03
                _gn32b02    ;return 32-bit number in R4 and R5
    4BA3 1513               TST  R3
    4BA5 16AE4B             JPF  _gn32b06
    4BA8 19DA3A             JSR  inc_ptr ;skip the dot
    4BAB 18B84B             JMP  _gn32b05
    4BAE 1516   _gn32b06    TST  R5_L
    4BB0 17204A             JNF  Error_Number
    4BB3 1517               TST  R5_H
    4BB5 17204A             JNF  Error_Number
    4BB8 1512   _gn32b05    TST  R2
    4BBA 16C93A             JPF  return_flag_0
    4BBD 198F40             JSR  negate_R45
    4BC0 18C93A             JMP  return_flag_0
                
                char2binnum:
                            ;Convert a character (0-9,A-Z) to a binary number (0-35)
                            ;Input : Accu = character
                            ;Output: Accu = binary number, FLAG=1 on success
    4BC3 1E                 PHL
    4BC4 196F3B             JSR  is_digit
    4BC7 17DD4B             JNF  _ch2binn01
    4BCA 19853B             JSR  is_alpha
    4BCD 16C93A             JPF  return_flag_0  ;FLAG=0, error
    4BD0 01051F             AND  #0x1F
    4BD3 0D05   
    4BD5 010509             ADD  #9
    4BD8 1005   
    4BDA 18E24B             JMP  _ch2binn02
    4BDD 01050F _ch2binn01  AND  #0x0F
    4BE0 0D05   
    4BE2 0610   _ch2binn02  STA  R0
    4BE4 0489               LDA  BASE
                            ;CLC
    4BE6 1110               SUB  R0
    4BE8 0410               LDA  R0
    4BEA 1F                 RTS        ; OK when FLAG = 1
                ;[File: my4th-rom_8MHz.asm]
                ;[File: forth_words.asm]
                ;------------------------------------------------------------------------------
                ;  Forth Dictionary
                ;------------------------------------------------------------------------------
                ;
                ;  A Forth word is formatted like this in memory:
                ;
                ;  +-----------+-----------+------+--------------+
                ;  | next_ptr  | len_flags | name | machine code |
                ;  +-----------+-----------+------+--------------+
                ;
                ;  - next_ptr is 2 bytes and points to the next word in the dictionary.
                ;     It is NULL if this is the last word in the dictionary.
                ;  - len_flags is 1 byte and has the length of the word's name in bits 0-4
                ;    and optional flags in bits 5-7 (e.g. the IMMEDIATE flag)
                ;  - name is n bytes long and is *not* terminated by a zero
                ;  - machine code has a variable length.
                ;     The machine code staRTS always with "PSH LR_L, PSH LR_H" and ends with
                ;     "JMP return". In user defined words it contains mainly JSR calls.
                ;
                ;------------------------------------------------------------------------------
                
                get_word_len:
                            ;Gets the length of a word into R1.
                            ;Input:   INPTR points to the name of the word.
                            ;         The word must be terminated by SPACE or NULL
                            ;Output:  R1 is the length of the word
                            ;Changes: PTR, R1, FLAG
    4BEB 1E                 PHL
    4BEC 19B849             JSR  ld_ptr_inptr
    4BEF 0111FF             LD   R1,#0xFF
    4BF2 0911   _gwl1       INC  R1
    4BF4 19CE3A             JSR  lap_inc_ptr
    4BF7 1320               CMP  #0x20
    4BF9 16CA3A             JPF  return
    4BFC 150E               TST
    4BFE 17F24B             JNF  _gwl1
    4C01 1F                 RTS
                
                chooseDictionary:
                            ;Choose the correct dictionary with the help of the word length.
                            ;Input:   R1 = word length
                            ;Output:  PTR = ptr to the dictionary pointer
    4C02 0307               LDA  #7
    4C04 0D11               AND  R1
    4C06 060C               STA  PTR_L
    4C08 010D7C             LD   PTR_H,#>tab_dict
    4C0B 05                 LAP
    4C0C 060C               STA  PTR_L
    4C0E 010D80             LD   PTR_H,#REGPAGE_HI
    4C11 1A                 RET
                
                search_forth_word:
                            ;Searches for a word in the dictionary, useful to call Forth words from an assembly program.
                            ;Input:   PTR points to the name of the word to search for.
                            ;Output:  If the word was found, FLAG is set to 0
                            ;         PTR points to the code section of the word,
                            ;         INPTR points behind the word
                            ;         and R4 points to the header of the word.
                            ;         R2 contains optional flags for the word (like the IMMEDIATE flag)
                            ;         R1 is the ASCII character length of the word
    4C12 1E                 PHL
    4C13 1BA1               PSH  INPTR_L
    4C15 1BA2               PSH  INPTR_H
    4C17 19B149             JSR  ld_inptr_ptr
    4C1A 19224C             JSR  search_word_ex
    4C1D 1CA2               POP  INPTR_H
    4C1F 1CA1               POP  INPTR_L
    4C21 1F                 RTS
                
                search_word_ex:
                            ;See search_word, but skips spaces and gets word length into R1 first.
    4C22 1E                 PHL
    4C23 199249             JSR  skipSpaces
    4C26 19EB4B             JSR  get_word_len
    4C29 1511               TST  R1
    4C2B 17324C             JNF  _sw01
    4C2E 18234A             JMP  Error_Syntax
                
                search_word:
                            ;Searches for a word in the dictionary
                            ;Input:   INPTR points to the name of the word to search for.
                            ;         R1 must contain the length of the word.
                            ;Output:  If the word was found, FLAG is set to 0
                            ;         PTR points to the code section of the word,
                            ;         INPTR points behind the word
                            ;         and R4 points to the header of the word.
                            ;         R2 contains optional flags for the word (like the IMMEDIATE flag)
                            ;Changes: all registers except R1 which still contains the word length
                
                            ;Walk through the dictionary.
    4C31 1E                 PHL
    4C32 19024C _sw01       JSR  chooseDictionary
    4C35 05                 LAP
    4C36 0618               STA  R6_L
    4C38 090C               INC  PTR_L
    4C3A 05                 LAP
    4C3B 0619               STA  R6_H
                            ;start loop
                            ;R6 points to the header of the current word.
    4C3D 01131F             LD   R3,#0x1F
    4C40 021418 _sw02       LD   R4_L,R6_L
    4C43 021519             LD   R4_H,R6_H
    4C46 020C14             LD   PTR_L,R4_L
    4C49 020D15             LD   PTR_H,R4_H
    4C4C 150D               TST  PTR_H
    4C4E 16CA3A             JPF  return     ;word not found in dictionary, return with FLAG=1
    4C51 19CE3A             JSR  lap_inc_ptr
    4C54 0618               STA  R6_L
    4C56 19CE3A             JSR  lap_inc_ptr
    4C59 0619               STA  R6_H       ;R6: ptr to next entry in the dictionary
    4C5B 19CE3A             JSR  lap_inc_ptr
    4C5E 0612               STA  R2
    4C60 0D13               AND  R3         ;mask out bits 5-7, they are FLAGs for other purposes
    4C62 1411               CMP  R1         ;test the length of the word
    4C64 17404C             JNF  _sw02      ;not equal
                            ;compare character by character
    4C67 0216A1             LD   R5_L,INPTR_L
    4C6A 0217A2             LD   R5_H,INPTR_H
    4C6D 020611             LD   PAR2,R1
    4C70 19CE3A _sw03       JSR  lap_inc_ptr
    4C73 0610               STA  R0
    4C75 021A0C             LD   R7_L,PTR_L
    4C78 021B0D             LD   R7_H,PTR_H
    4C7B 020C16             LD   PTR_L,R5_L
    4C7E 020D17             LD   PTR_H,R5_H
    4C81 19CE3A             JSR  lap_inc_ptr
    4C84 02160C             LD   R5_L,PTR_L
    4C87 02170D             LD   R5_H,PTR_H
                          ;<toLowerCase>
    4C8A 060C               STA  PTR_L
    4C8C 010D7C             LD   PTR_H,#>tab_lowerCase
    4C8F 05                 LAP
                          ;</toLowerCase>
    4C90 1410               CMP  R0
    4C92 17404C             JNF  _sw02  ; not equal
    4C95 020C1A             LD   PTR_L,R7_L
    4C98 020D1B             LD   PTR_H,R7_H
    4C9B 0A06               DEC  PAR2
    4C9D 1506               TST  PAR2
    4C9F 17704C             JNF  _sw03
                            ;found!
    4CA2 02A116             LD   INPTR_L,R5_L
    4CA5 02A217             LD   INPTR_H,R5_H
    4CA8 23                 CLC
    4CA9 1F                 RTS
                
                ;------------------------------------------------------------------------------
                ;  Functions for adding new words to the dictionary
                ;------------------------------------------------------------------------------
                
                start_new_word:
                            ;Start to add a new word to the dictionary (start compilation)
                            ;Input:   INPTR points to the name of the word
                            ;Output:  INPTR points behind the word name
                            ;Changes: R1,R2,R3,R4,R5,PTR,FLAG
                            ;Note:    The word gets not yet added to the words-list.
                            ;         Call the finish_new_word_ret to perform this.
    4CAA 1E                 PHL
    4CAB 19124A             JSR  memcheck
    4CAE 19EB4B             JSR  get_word_len
    4CB1 1511               TST  R1
    4CB3 16234A             JPF  Error_Syntax
                            ;check the length of the word name, it must not be longer than 31 bytes
    4CB6 03E0               LDA  #0xE0
    4CB8 0D11               AND  R1
    4CBA 150E               TST
    4CBC 172C4A             JNF  Error_ToLong
                            ;remember CP
    4CBF 029E64             LD   DICTL_L,CP_L
    4CC2 029F65             LD   DICTL_H,CP_H
                            ;find correct dictionary and store the link to it in memory (begin new word header)
    4CC5 19024C             JSR  chooseDictionary
    4CC8 02A00C             LD   DICTLH,PTR_L
    4CCB 05                 LAP
    4CCC 19134E             JSR  emit_code
    4CCF 090C               INC  PTR_L
    4CD1 05                 LAP
    4CD2 19134E             JSR  emit_code
                            ;load CP into PTR
    4CD5 19374E             JSR  ld_ptr_cp
                            ;store length of the word name
    4CD8 0411               LDA  R1
    4CDA 19D93A             JSR  sap_inc_ptr
                            ;copy the name of the word
    4CDD 02120C _saw1       LD   R2,PTR_L
    4CE0 02130D             LD   R3,PTR_H
    4CE3 19B849             JSR  ld_ptr_inptr
    4CE6 19CE3A             JSR  lap_inc_ptr
    4CE9 19B149             JSR  ld_inptr_ptr
                          ;<toLowerCase>
    4CEC 060C               STA  PTR_L
    4CEE 010D7C             LD   PTR_H,#>tab_lowerCase
    4CF1 05                 LAP
                          ;</toLowerCase>
    4CF2 020C12             LD   PTR_L,R2
    4CF5 020D13             LD   PTR_H,R3
    4CF8 19D93A             JSR  sap_inc_ptr
    4CFB 0A11               DEC  R1
    4CFD 1511               TST  R1
    4CFF 17DD4C             JNF  _saw1
                            ;finished
    4D02 02640C             LD   CP_L,PTR_L
    4D05 02650D             LD   CP_H,PTR_H
    4D08 029C64             LD   CW_L,CP_L
    4D0B 029D65             LD   CW_H,CP_H
    4D0E 1F                 RTS
                
                begin_add_new_word:
                            ;Start to add a new word to the dictionary (start compilation)
                            ;Input:   INPTR points to the name of the word
                            ;Output:  INPTR points behind the word name
                            ;Changes: R1,R2,R3,R4,R5,PTR,FLAG
    4D0F 1E                 PHL
    4D10 19AA4C             JSR  start_new_word
    4D13 03                 DB   0x03  ;skip next byte (PHL instruction)
                finish_new_word:
                            ;finish the compilation of the new word, add word to words-list
    4D14 1E                 PHL
    4D15 020CA0             LD   PTR_L,DICTLH
    4D18 010D80             LD   PTR_H,#REGPAGE_HI
    4D1B 049E               LDA  DICTL_L
    4D1D 19D93A             JSR  sap_inc_ptr
    4D20 049F               LDA  DICTL_H
    4D22 07                 SAP
    4D23 1F                 RTS
                
                add_word_entry_code:
                            ;add function entry code (PSH LR_L, PSH LR_H -> PHL)
    4D24 1E                 PHL
                add_word_entry_code_ret:
    4D25 031E               LDA  #0x1E
                emit_code_ret:
    4D27 19134E             JSR  emit_code
    4D2A 1F                 RTS
                
                add_word_call:
                            ;Add a reference to another word to the currently compiled word
                            ;Input:   PTR points to the code section of the referenced word
    4D2B 0319               LDA  #0x19
                add_JmpOrJsr:
    4D2D 1E                 PHL
                add_JmpOrJsr_ret:
    4D2E 19134E             JSR  emit_code
                emit_PTR_ret:  ;emit PTR to position of CP and return
    4D31 040C               LDA  PTR_L
    4D33 19134E             JSR  emit_code
    4D36 040D               LDA  PTR_H
    4D38 18274D             JMP  emit_code_ret
                
                emit_jsr:   ;emit a JSR instruction
                            ;Input:  R7 = destination address
    4D3B 0319               LDA  #0x19
                emit_opaadr:
                            ;emit OP code and address
                            ;Input:  Accu = OP-Code, R7 = address
    4D3D 1E                 PHL
                emit_opaadr_ret:
    4D3E 19134E             JSR  emit_code
    4D41 041A               LDA  R7_L
    4D43 19134E             JSR  emit_code
    4D46 041B               LDA  R7_H
    4D48 18274D             JMP  emit_code_ret
                
                write_create_code:
                            ;write the body code for CREATE to the position CP
    4D4B 011000             LD   R0,#0  ;dummy flag
    4D4E 030C               LDA  #12
    4D50 18584D             JMP  _wvabdy
                
                write_variable_body:
                            ;write the body code for a variable to the position CP
    4D53 011018             LD   R0,#0x18
    4D56 0309               LDA  #9
    4D58 2464   _wvabdy     AD   CP_L
    4D5A 0614               STA  R4_L
    4D5C 021565             LD   R4_H,CP_H
    4D5F 176A4D             JNF  _ldR4jmp
    4D62 0915               INC  R4_H
    4D64 186A4D             JMP  _ldR4jmp
                
                write_constant_body:
    4D67 011018             LD   R0,#0x18
    4D6A 1E     _ldR4jmp    PHL
    4D6B 19114E             JSR  emit_code_ldi
    4D6E 0314               LDA  #R4_L
    4D70 19134E             JSR  emit_code
    4D73 190C4E             JSR  emit_code_R4L
    4D76 19114E             JSR  emit_code_ldi
    4D79 0315               LDA  #R4_H
    4D7B 19134E             JSR  emit_code
    4D7E 0415               LDA  R4_H
    4D80 19134E             JSR  emit_code
    4D83 0410               LDA  R0
    4D85 1510               TST  R0
    4D87 178C4D             JNF  _addlit01
    4D8A 0319               LDA  #0x19
    4D8C 19134E _addlit01   JSR  emit_code
    4D8F 03DB               LDA  #<push_data_R4
    4D91 19134E             JSR  emit_code
    4D94 0344               LDA  #>push_data_R4
    4D96 19134E             JSR  emit_code
    4D99 1510               TST  R0
    4D9B 17CA3A             JNF  return
                            ;add "JMP return" for special CREATE word
                
                add_JmpReturn_ret:
    4D9E 029364             LD   DOESH_L,CP_L
    4DA1 029465             LD   DOESH_H,CP_H
    4DA4 031F               LDA  #0x1F
    4DA6 19134E             JSR  emit_code
    4DA9 19134E             JSR  emit_code     ; insert two "NOPs": required by DOES> to insert a JMP
    4DAC 18274D             JMP  emit_code_ret ; insert two "NOPs"
                
                add_16bit_literal:
                            ;Push a constant 16-bit value to the data stack (size optimized code)
    4DAF 1E                 PHL
                add_16bit_literal_ret:
    4DB0 1515               TST  R4_H
    4DB2 16C14D             JPF  _add16blit1
    4DB5 011AC6             LD   R7_L,#<push_constant_inline
    4DB8 011B45             LD   R7_H,#>push_constant_inline
    4DBB 193B4D             JSR  emit_jsr
    4DBE 18FD50             JMP  emit_R4_ret
                
    4DC1 1514   _add16blit1 TST  R4_L
    4DC3 16E04D             JPF  _add16blit2
    4DC6 0301               LDA  #1
    4DC8 1414               CMP  R4_L
    4DCA 16E94D             JPF  _add16blit3
    4DCD 0303               LDA  #0x03
    4DCF 19134E             JSR  emit_code
    4DD2 190C4E             JSR  emit_code_R4L
    4DD5 010CEE             LD   PTR_L,#<push_data_accu
    4DD8 010D44             LD   PTR_H,#>push_data_accu
    4DDB 0319   _add16blit4 LDA  #0x19
    4DDD 182E4D             JMP  add_JmpOrJsr_ret
    4DE0 010CC9 _add16blit2 LD   PTR_L,#<push_data_zero
    4DE3 010D44             LD   PTR_H,#>push_data_zero
    4DE6 18DB4D             JMP  _add16blit4
    4DE9 010CEC _add16blit3 LD   PTR_L,#<push_data_1
    4DEC 010D44             LD   PTR_H,#>push_data_1
    4DEF 18DB4D             JMP  _add16blit4
                
                popR4R5_add_32bit_literal:
                            ;Push a constant 32-bit value to the data stack (size optimized code)
    4DF2 1E                 PHL
    4DF3 011AF7             LD   R7_L,#<push_2constant_inline
    4DF6 011B45             LD   R7_H,#>push_2constant_inline
    4DF9 193B4D             JSR  emit_jsr
    4DFC 193A45             JSR  pop_data_R4_R5
    4DFF 0416               LDA  R5_L
    4E01 19134E             JSR  emit_code
    4E04 0417               LDA  R5_H
    4E06 19134E             JSR  emit_code
    4E09 18FD50             JMP  emit_R4_ret
                
                emit_code_R4L:
    4E0C 0414               LDA  R4_L
    4E0E 18134E             JMP  emit_code
                emit_code_ldi:
    4E11 0301               LDA  #0x01
                emit_code:
                            ;write a code byte to current compile address
                            ;and increment the destination pointer
                            ;Input: accu = byte to write
    4E13 1B0C               PSH  PTR_L
    4E15 1B0D               PSH  PTR_H
    4E17 020C64             LD   PTR_L,CP_L
    4E1A 020D65             LD   PTR_H,CP_H
    4E1D 07                 SAP
    4E1E 1C0D               POP  PTR_H
    4E20 1C0C               POP  PTR_L
                inc_cp:     ;increment the CP pointer
    4E22 0964               INC  CP_L
    4E24 1564               TST  CP_L
    4E26 17CD3A             JNF  ret_opc
    4E29 0965               INC  CP_H
    4E2B 1B0E               PSH
    4E2D 03FD               LDA  #>(HEAP_END+1)
    4E2F 1465               CMP  CP_H
    4E31 1C0E               POP
    4E33 161D4A             JPF  Error_Mem
    4E36 1A                 RET
                
                ld_ptr_cp:  ;load CP into PTR
    4E37 020C64             LD   PTR_L,CP_L
    4E3A 020D65             LD   PTR_H,CP_H
    4E3D 1A                 RET
                
                ld_r4_cp:   ;load CP into R4
    4E3E 021464             LD   R4_L,CP_L
    4E41 021565             LD   R4_H,CP_H
    4E44 1A                 RET
                
                ;------------------------------------------------------------------------------
                ;  Library functions used by the implemented words
                ;------------------------------------------------------------------------------
                
                print_unsigned:
                            ;print unsigned integer number on the data stack with the currently set base
    4E45 1E                 PHL
    4E46 190E45             JSR  pop_data_R4
    4E49 18624E             JMP  _pint01
                
                print_integer:
                            ;print integer number on the data stack with the currently set base
    4E4C 1E                 PHL
                print_integer_rts:
    4E4D 190E45             JSR  pop_data_R4
    4E50 0415               LDA  R4_H
    4E52 0B0E               ROL
    4E54 17624E             JNF  _pint01
    4E57 032D               LDA  #'-'
    4E59 192433             JSR  print_char
    4E5C 19AE40             JSR  inv_r4
    4E5F 19F93A             JSR  inc_r4
    4E62 158A   _pint01     TST  BASE+1
    4E64 176E4E             JNF  _pint02
    4E67 0489               LDA  BASE
    4E69 130A               CMP  #10
    4E6B 16E033             JPF  print_decword_rts
    4E6E 19DB44 _pint02     JSR  push_data_R4
    4E71 19C944             JSR  push_data_zero
    4E74 199D55             JSR  c_lns
    4E77 19C255             JSR  c_nss
    4E7A 19A955             JSR  c_nsg
    4E7D 18765D             JMP  _c_type_ret
                
                memcpy_short:
    4E80 011900             LD   R6_H,#0
                memcpy:     ; Copy memory
                            ; In: R4 = source address, R5 = destination address, R6 = length
                            ; Changes: ACCU, PTR, R4, R5, R6
    4E83 1E                 PHL
    4E84 189E4E             JMP  _mcpy01
    4E87 19213B _mcpy02     JSR  ld_ptr_r4
    4E8A 19F93A             JSR  inc_r4
    4E8D 05                 LAP
    4E8E 19283B             JSR  ld_ptr_r5
    4E91 19033B             JSR  inc_r5
    4E94 07                 SAP
    4E95 1518               TST  R6_L
    4E97 179C4E             JNF  _mcpy03
    4E9A 0A19               DEC  R6_H
    4E9C 0A18   _mcpy03     DEC  R6_L
    4E9E 1518   _mcpy01     TST  R6_L
    4EA0 17874E             JNF  _mcpy02
    4EA3 1519               TST  R6_H
    4EA5 17874E             JNF  _mcpy02
    4EA8 1F                 RTS
                
                if_check:   ;called by IF to perform boolean check
                            ;returns with FLAG=1 if the value on top of the stack was zero
    4EA9 1E                 PHL
    4EAA 190E45             JSR  pop_data_R4
    4EAD 1514               TST  R4_L
    4EAF 17CA3A             JNF  return
    4EB2 1515               TST  R4_H
    4EB4 1F                 RTS
                
                of_check:   ;called by OF to perform the check
                            ;returns with FLAG=1 if the value on top of the stack was zero
    4EB5 1E                 PHL
    4EB6 193A45             JSR  pop_data_R4_R5
    4EB9 0414               LDA  R4_L
    4EBB 1416               CMP  R5_L
    4EBD 17C74E             JNF  _ofck01
    4EC0 0415               LDA  R4_H
    4EC2 1417               CMP  R5_H
    4EC4 16C93A             JPF  return_flag_0
    4EC7 19FD44 _ofck01     JSR  push_data_R5
    4ECA 22                 SEC
    4ECB 1F                 RTS
                
                do_code:    ;this code fragment is called when the word DO is executed
    4ECC 1E                 PHL
                            ;get the index start value
    4ECD 190E45             JSR  pop_data_R4
                            ;push the index value to the control flow stack
    4ED0 198E44             JSR  lcfs_push
                            ;get the end value
    4ED3 190E45             JSR  pop_data_R4
                            ;push the end value to the control flow stack
    4ED6 198E44             JSR  lcfs_push
    4ED9 23                 CLC
    4EDA 1F                 RTS  ;return with FLAG=0 : start the loop
                
                qmdo_code:  ;this code fragment is called when the word ?DO is executed
    4EDB 1E                 PHL
                            ;get the index start value
    4EDC 190E45             JSR  pop_data_R4
                            ;get the end value
    4EDF 192445             JSR  pop_data_R5
                            ;compare index and end value
    4EE2 0414               LDA  R4_L
    4EE4 1416               CMP  R5_L
    4EE6 17F04E             JNF  _qmdocd01
    4EE9 0415               LDA  R4_H
    4EEB 1417               CMP  R5_H
    4EED 16CA3A             JPF  return  ;return with FLAG=1 : do not enter the loop
                _qmdocd01   ;push the index value to the control flow stack
    4EF0 198E44             JSR  lcfs_push
    4EF3 021416             LD   R4_L,R5_L
    4EF6 021517             LD   R4_H,R5_H
                            ;push the end value to the control flow stack
    4EF9 198E44             JSR  lcfs_push
    4EFC 23                 CLC
    4EFD 1F                 RTS  ;return with FLAG=0 : start the loop
                
                loop_common:
                            ;common code for loop and +loop
                            ;get the end value from the loop control flow stack
    4EFE 020C99             LD   PTR_L,LCFSP
    4F01 010DFF             LD   PTR_H,#>LCTLFLOWSTACK ; this is a constant
    4F04 05                 LAP
    4F05 090C               INC  PTR_L
    4F07 0618               STA  R6_L
    4F09 05                 LAP
    4F0A 090C               INC  PTR_L
    4F0C 0619               STA  R6_H
                            ;get the index from the control flow stack
    4F0E 05                 LAP
    4F0F 090C               INC  PTR_L
    4F11 0614               STA  R4_L
    4F13 05                 LAP
    4F14 0615               STA  R4_H
    4F16 1A                 RET
                
                loop_code:  ;this code fragment is called when the word LOOP is executed
    4F17 1E                 PHL
    4F18 19FE4E             JSR  loop_common
                            ;increment the index
    4F1B 0914               INC  R4_L
    4F1D 1514               TST  R4_L
    4F1F 17244F             JNF  _loopcd01
    4F22 0915               INC  R4_H
                _loopcd01   ;compare with the limit
    4F24 0414               LDA  R4_L
    4F26 1418               CMP  R6_L
    4F28 17324F             JNF  _loopcd02
    4F2B 0415               LDA  R4_H
    4F2D 1419               CMP  R6_H
    4F2F 16794F             JPF  _loopcd03
                _loopcd02   ;store the updated index value
    4F32 0415               LDA  R4_H
    4F34 07                 SAP
    4F35 0A0C               DEC  PTR_L
    4F37 0414               LDA  R4_L
    4F39 07                 SAP
    4F3A 1F                 RTS  ;flag = 0
                
                ploop_code: ;this code fragment is called when the word +LOOP is executed
    4F3B 1E                 PHL
    4F3C 19FE4E             JSR  loop_common
                            ;add the value on top of the stack to the index counter
    4F3F 192445             JSR  pop_data_R5
                            ;R4 = index, R5 = delta, R6 = limit
                            ;Check if the limit is crossed (idea copied from pforth, which in turn has it from Gforth):
                            ;if ( ((OldDiff ^ (OldDiff + Delta)) & (OldDiff ^ Delta)) < 0 )  { quit loop }
    4F42 0414               LDA  R4_L
    4F44 2518               SU   R6_L
    4F46 061A               STA  R7_L
    4F48 0415               LDA  R4_H
    4F4A 1119               SUB  R6_H
    4F4C 061B               STA  R7_H
    4F4E 041B               LDA  R7_H
    4F50 0F17               XOR  R5_H
    4F52 0613               STA  R3
    4F54 041A               LDA  R7_L
    4F56 2416               AD   R5_L
    4F58 041B               LDA  R7_H
    4F5A 1017               ADD  R5_H
    4F5C 0F1B               XOR  R7_H
    4F5E 0D13               AND  R3
    4F60 0B0E               ROL
    4F62 16794F             JPF  _loopcd03
                            ;calculate and save new index value
    4F65 0414               LDA  R4_L
    4F67 1016               ADD  R5_L
    4F69 0614               STA  R4_L
    4F6B 0415               LDA  R4_H
    4F6D 1017               ADD  R5_H
    4F6F 0615               STA  R4_H
    4F71 07                 SAP
    4F72 0A0C               DEC  PTR_L
    4F74 0414               LDA  R4_L
    4F76 07                 SAP
    4F77 23                 CLC
    4F78 1F                 RTS
                _loopcd03   ;limit reached, drop control data from LCFS and quit the loop
    4F79 090C               INC  PTR_L
    4F7B 02990C             LD   LCFSP,PTR_L
    4F7E 1F                 RTS  ;flag = 1
                
                until_code: ;this code fragment is called when the word UNTIL (or WHILE) is executed
    4F7F 1E                 PHL
    4F80 190E45             JSR  pop_data_R4
    4F83 1514               TST  R4_L
    4F85 17CA3A             JNF  return
    4F88 1515               TST  R4_H
    4F8A 1F                 RTS
                
                abort_code: ;this code fragment is called when the word ABORT" is executed
    4F8B 1E                 PHL
    4F8C 197F4F             JSR  until_code
    4F8F 16CA3A             JPF  return
    4F92 194633             JSR  print_str
    4F95 18D86B             JMP  c_abort
                
                toEEPindex: ;convert R4 to valid EEPROM index number in R0
    4F98 1515               TST  R4_H
    4F9A 17264A             JNF  Error_Value
    4F9D 021014             LD   R0,R4_L
    4FA0 0A10               DEC  R0
    4FA2 03F8               LDA  #0xF8
    4FA4 0D10               AND  R0
    4FA6 150E               TST
    4FA8 17264A             JNF  Error_Value
    4FAB 1A                 RET
                
                prep_eepblk ;prepare loading/saving a block
    4FAC 1E                 PHL
                            ;get screen/block number from stack
    4FAD 190E45             JSR  pop_data_R4
    4FB0 19DB44             JSR  push_data_R4
                            ;translate block number in R4 to EEPROM I2C device address (ACCU) and memory address (R4)
    4FB3 193038             JSR  fblockToEepromAddr
    4FB6 16264A             JPF  Error_Value
    4FB9 0613               STA  R3  ;EEPROM device address
                            ;R4 = memory address
    4FBB 192445             JSR  pop_data_R5  ; get block number into R5
    4FBE 1F                 RTS  ; return with I2C dev in R3, EEPROM addr in R4
                
    4FBF 011600 ld_R5_1024  LD   R5_L,#<1024
    4FC2 011704             LD   R5_H,#>1024
    4FC5 1A                 RET
                
                feep_start_read:
                            ; Start a read-transfer.
                            ; In : R3 : 8-bit I2C-address of the EEPROM
                            ;      R4 : 16-bit EEPROM read address
                            ; Out: FLAG = 0 on success
    4FC6 1E                 PHL
    4FC7 19D84F             JSR  feep_start_write_ackpoll
    4FCA 021013             LD   R0,R3
    4FCD 0910               INC  R0
    4FCF 19F62D             JSR  i2c_start_addr
    4FD2 17CA3A             JNF  return          
    4FD5 183F4A             JMP  Error_InOut
                
                feep_start_write_ackpoll:
                            ; Start a write-transfer, but wait until
                            ; previous write has been completed in the EEPROM.
                            ; In : R3 : 8-bit I2C-address of the EEPROM
                            ;      R4 : 16-bit EEPROM write address
                            ; Out: FLAG = 0 on success
    4FD8 1E                 PHL
    4FD9 011100             LD   R1,#0
    4FDC 19A72D _feepstw0   JSR  i2c_start
    4FDF 173F4A             JNF  Error_InOut
    4FE2 1B11               PSH  R1
    4FE4 021113             LD   R1,R3
    4FE7 19042E             JSR  i2c_send
    4FEA 1C11               POP  R1
    4FEC 176D38             JNF  _eepstw3  ; ok, device is ready again, send address in R4
    4FEF 19DE2D             JSR  i2c_stop
    4FF2 0A11               DEC  R1
    4FF4 1511               TST  R1
    4FF6 163F4A             JPF  Error_InOut
    4FF9 18DC4F             JMP  _feepstw0
                
                test_blk:   ;test if BLK is zero
    4FFC 048D               LDA  BLK_L
    4FFE 0E8E               OR   BLK_H
    5000 150E               TST
    5002 1A                 RET
                
                ;==============================================================================
                ;  Here is a basic set of primitives for the dictionary
                ;  To improve performance, the dictionary is split into 8 parts.
                ;  The correct dictionary is selected by the help of the word length.
                ;==============================================================================
                
                dictionary_1:
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words_basis.asm]
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 1 characters
                ;------------------------------------------------------------------------------
                
                            ; [  Stop compilation
    5003 0B50               DW   e_cstop
    5005 815B               DB   1+FL_IMMEDIATE,"["
    5007 019A00 c_cstop     LD   STATE,#0
    500A 1A                 RET
                e_cstop     ;------------------------------------------------------------------
                
                            ; ]  Restart compilation
    500B 1350               DW   e_cstart
    500D 015D               DB   1,"]"
    500F 019A01 c_cstart    LD   STATE,#1
    5012 1A                 RET
                e_cstart    ;------------------------------------------------------------------
                
                            ; '  Interpret next word and get its code address on the stack
    5013 2450               DW   e_tick
    5015 0127               DB   1,"'"
    5017 1E     c_tick      PHL
    5018 19224C             JSR  search_word_ex
    501B 16074A             JPF  Error_Word ;word not found
    501E 19AA49             JSR  ld_r4_ptr
    5021 18D744             JMP  push_data_R4_ret
                e_tick      ;------------------------------------------------------------------
                
                            ; @  ( addr -- x )  Fetch memory contents at addr
    5024 3A50               DW   e_at
    5026 0140               DB   1,"@"
    5028 1E     c_at        PHL
    5029 190E45 _c_at       JSR  pop_data_R4
    502C 19213B c_at_ldpret JSR  ld_ptr_r4
    502F 19CE3A c_at_ldret  JSR  lap_inc_ptr
    5032 0614               STA  R4_L
    5034 05                 LAP
    5035 0615               STA  R4_H
    5037 18D744             JMP  push_data_R4_ret
                e_at        ;------------------------------------------------------------------
                
                            ; !  ( x addr -- )  Store x at addr
    503A 4E50               DW   e_store
    503C 0121               DB   1,"!"
    503E 1E     c_store     PHL
    503F 195945 _c_store_1  JSR  pop_data_R5_R4
    5042 19283B             JSR  ld_ptr_r5
    5045 0414   _c_store_2  LDA  R4_L
    5047 19D93A             JSR  sap_inc_ptr
    504A 0415               LDA  R4_H
    504C 07                 SAP
    504D 1F                 RTS
                e_store     ;------------------------------------------------------------------
                
                            ; <  ( x y -- flag )  Return true if x is less than y
    504E 6D50               DW   e_lessthan
    5050 013C               DB   1,"<"
    5052 1E     c_lessthan  PHL
    5053 195945 _c_lessthan JSR  pop_data_R5_R4
    5056 0B15   _c_lthan_1  ROL  R4_H
    5058 090F               INC  FLAG
    505A 0C15               ROR  R4_H
    505C 0B17               ROL  R5_H
    505E 090F               INC  FLAG
    5060 0C17               ROR  R5_H
    5062 0414   _c_lthan_2  LDA  R4_L
    5064 2516               SU   R5_L
    5066 0415               LDA  R4_H
    5068 1117               SUB  R5_H
    506A 18B552             JMP  _c_noteq_1
                e_lessthan  ;------------------------------------------------------------------
                
                            ; >  ( x y -- flag )  Return true if x is greater than y
    506D 7850               DW   e_grtrthan
    506F 013E               DB   1,">"
    5071 1E     c_grtrthan  PHL
    5072 193A45             JSR  pop_data_R4_R5
    5075 185650             JMP  _c_lthan_1
                e_grtrthan  ;------------------------------------------------------------------
                
                            ; =  ( x y -- flag )  Return true if x is equal to y
    5078 9450               DW   e_equal
    507A 013D               DB   1,"="
    507C 1E     c_equal     PHL
    507D 193A45             JSR  pop_data_R4_R5
    5080 0414               LDA  R4_L
    5082 1416               CMP  R5_L
    5084 17B852             JNF  ret_false
    5087 0415               LDA  R4_H
    5089 1417   _c_equal_2  CMP  R5_H
    508B 17B852 _c_equal_1  JNF  ret_false
    508E 0114FF ret_true    LD   R4_L,#0xFF
    5091 18BB52             JMP  _rettf
                e_equal     ;------------------------------------------------------------------
                
                            ; +  ( x y -- z )  Sum the two numbers at the top of the stack
    5094 AB50               DW   e_sum16
    5096 012B               DB   1,"+"
    5098 1E     c_sum16     PHL
    5099 193A45 _c_sum16    JSR  pop_data_R4_R5
    509C 0414               LDA  R4_L
    509E 2416               AD   R5_L
    50A0 0614               STA  R4_L
    50A2 0415               LDA  R4_H
    50A4 1017               ADD  R5_H
    50A6 0615               STA  R4_H
    50A8 18D744             JMP  push_data_R4_ret
                e_sum16     ;------------------------------------------------------------------
                
                            ; -  ( x y -- z )  Subtract the two numbers at the top of the stack
    50AB C250               DW   e_sub16
    50AD 012D               DB   1,"-"
    50AF 1E     c_sub16     PHL
    50B0 195945             JSR  pop_data_R5_R4
    50B3 0414               LDA  R4_L
    50B5 2516               SU   R5_L
    50B7 0614               STA  R4_L
    50B9 0415               LDA  R4_H
    50BB 1117               SUB  R5_H
    50BD 0615               STA  R4_H
    50BF 18D744             JMP  push_data_R4_ret
                e_sub16     ;------------------------------------------------------------------
                
                            ; *  ( x y -- z )  Multiply the two numbers at the top of the stack
    50C2 D050               DW   e_mul16
    50C4 012A               DB   1,"*"
    50C6 1E     c_mul16     PHL
    50C7 193A45             JSR  pop_data_R4_R5
    50CA 199D42             JSR  multiply_u
    50CD 18D744             JMP  push_data_R4_ret
                e_mul16     ;------------------------------------------------------------------
                
                            ; /  ( x y -- z )  Divide the two numbers at the top of the stack
    50D0 DE50               DW   e_div16
    50D2 012F               DB   1,"/"
    50D4 1E     c_div16     PHL
    50D5 195945             JSR  pop_data_R5_R4
    50D8 19F043             JSR  divide_s
    50DB 18D744             JMP  push_data_R4_ret
                e_div16     ;------------------------------------------------------------------
                
                            ; .  ( x -- )  Display signed number
    50DE EA50               DW   e_dot
    50E0 012E               DB   1,"."
    50E2 1E     c_dot       PHL
    50E3 194C4E _c_dot      JSR  print_integer
    50E6 191833 p_space_rts JSR  print_space
    50E9 1F                 RTS
                e_dot       ;------------------------------------------------------------------
                
                            ; ?  ( addr -- )  Display content of a cell
    50EA F550               DW   e_qmark
    50EC 013F               DB   1,"?"
    50EE 1E     c_qmark     PHL
    50EF 192850             JSR  c_at
    50F2 18E350             JMP  _c_dot
                e_qmark     ;------------------------------------------------------------------
                
                            ; ,  ( x -- )  Writes the number on stack to the next free memory place
    50F5 0551               DW   e_comma
    50F7 012C               DB   1,","
    50F9 1E     c_comma     PHL
    50FA 190E45             JSR  pop_data_R4
                emit_R4_ret:  ;emit R4 to position of CP and return
    50FD 190C4E             JSR  emit_code_R4L
    5100 0415               LDA  R4_H
    5102 18274D             JMP  emit_code_ret
                e_comma     ;------------------------------------------------------------------
                
                            ; I  ( -- i1 )  Get the loop index of the inner loop
    5105 1F51               DW   e_i
    5107 0169               DB   1,"i"
    5109 1E     c_i         PHL
                            ;get the index from the control flow stack
    510A 020C99             LD   PTR_L,LCFSP
    510D 090C   _c_i_1      INC  PTR_L
    510F 090C               INC  PTR_L
    5111 010DFF             LD   PTR_H,#>LCTLFLOWSTACK
    5114 05                 LAP
    5115 090C               INC  PTR_L
    5117 0614               STA  R4_L
    5119 05                 LAP
    511A 0615               STA  R4_H
    511C 18D744             JMP  push_data_R4_ret
                e_i         ;------------------------------------------------------------------
                
                            ; J  ( -- i2 )  Get the loop index of the outer loop
    511F 3C51               DW   e_j
    5121 016A               DB   1,"j"
                c_j         ;get the index from the control flow stack
    5123 011101             LD   R1,#1
    5126 020C99 _c_j_1      LD   PTR_L,LCFSP
    5129 090C   _c_j_2      INC  PTR_L
    512B 090C               INC  PTR_L
    512D 090C               INC  PTR_L
    512F 090C               INC  PTR_L
    5131 0A11               DEC  R1
    5133 1511               TST  R1
    5135 172951             JNF  _c_j_2
    5138 1E                 PHL
    5139 180D51             JMP  _c_i_1
                e_j         ;------------------------------------------------------------------
                
                            ; K  ( -- i3 )  Get the loop index of the 2nd outer loop
    513C 4651               DW   e_k
    513E 016B               DB   1,"k"
                c_k         ;get the index from the control flow stack
    5140 011102             LD   R1,#2
    5143 182651             JMP  _c_j_1
                e_k         ;------------------------------------------------------------------
                
                            ; L  ( -- i4 )  Get the loop index of the 3rd outer loop
    5146 5051               DW   e_l
    5148 016C               DB   1,"l"
                c_l         ;get the index from the control flow stack
    514A 011103             LD   R1,#3
    514D 182651             JMP  _c_j_1
                e_l         ;------------------------------------------------------------------
                
                            ; #  ( ud1 -- ud2 )  Formatted number output.
    5150 7F51               DW   e_ns
    5152 0123               DB   1,"#"
    5154 1E     c_ns        PHL
    5155 195945             JSR  pop_data_R5_R4
    5158 021889             LD   R6_L,BASE
    515B 02198A             LD   R6_H,BASE+1
    515E 192441             JSR  div_u32u16
    5161 19DB44             JSR  push_data_R4
    5164 19FD44             JSR  push_data_R5
    5167 03C0               LDA  #<tab_num2asc
    5169 0E18               OR   R6_L
    516B 060C               STA  PTR_L
    516D 010D7C             LD   PTR_H,#>tab_num2asc
    5170 05                 LAP
    5171 197551 _c_ns_1     JSR  _outnumchr
    5174 1F                 RTS
    5175 0AA7   _outnumchr  DEC  NB_L
    5177 020CA7             LD   PTR_L,NB_L
    517A 020DA8             LD   PTR_H,NB_H
    517D 07                 SAP
    517E 1A                 RET
                e_ns        ;------------------------------------------------------------------
                
                            ; :  enter compilation mode
    517F 8C51               DW   e_colon
    5181 013A               DB   1,":"
    5183 1E     c_colon     PHL
                            ;TST  STATE
                            ;JNF  Error_Syntax  ; can't happen, because : is not an immediate word
    5184 19AA4C             JSR  start_new_word
    5187 099A               INC  STATE
    5189 18254D             JMP  add_word_entry_code_ret
                e_colon     ;------------------------------------------------------------------
                
                            ; ";"  finish compilation
    518C 9F51               DW   e_semicolon
    518E 813B               DB   1+FL_IMMEDIATE,0x3B
    5190 1E     c_semicolon PHL
    5191 159A               TST  STATE
    5193 16234A             JPF  Error_Syntax
    5196 019A00             LD   STATE,#0
                            ;add word to words list
    5199 19144D             JSR  finish_new_word
                            ;add function exit code (JMP return)
    519C 189E4D             JMP  add_JmpReturn_ret
                e_semicolon ;------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 2 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 3 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 4 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 5 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 6 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 7 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 8 characters
                ;------------------------------------------------------------------------------
                
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 9 characters
                ;------------------------------------------------------------------------------
                
                            ; immediate  ( -- )  Mark last compiled word as "IMMEDIATE" word
    519F C051               DW   e_immediate
    51A1 09696D             DB   9,"immediate"
    51A4 6D6564 
    51A7 696174 
    51AA 65     
    51AB 1E     c_immediate PHL
    51AC 020C9E             LD   PTR_L,DICTL_L
    51AF 020D9F             LD   PTR_H,DICTL_H
    51B2 19DA3A             JSR  inc_ptr
    51B5 19DA3A             JSR  inc_ptr
    51B8 05                 LAP
    51B9 010580             OR   #FL_IMMEDIATE
    51BC 0E05   
    51BE 07                 SAP
    51BF 1F                 RTS
                e_immediate ;------------------------------------------------------------------
                
                            ;2CONSTANT ( d -- )  Creates a new 32-bit constant
    51C0 D951               DW   e_2constant
    51C2 093263             DB   9,"2constant"
    51C5 6F6E73 
    51C8 74616E 
    51CB 74     
    51CC 1E     c_2constant PHL
    51CD 190F4D             JSR  begin_add_new_word
    51D0 19244D             JSR  add_word_entry_code
    51D3 19F24D             JSR  popR4R5_add_32bit_literal
    51D6 189E4D             JMP  add_JmpReturn_ret
                e_2constant ;------------------------------------------------------------------
                
                            ; 2VARIABLE  Creates a new variable with two 16-bit cells
    51D9 EF51               DW   e_2variable
    51DB 093276             DB   9,"2variable"
    51DE 617269 
    51E1 61626C 
    51E4 65     
    51E5 1E     c_2variable PHL
    51E6 010A7B             LD   LR_L,#<_c_var_2em
    51E9 010B74             LD   LR_H,#>_c_var_2em
    51EC 187274             JMP  c_variable
                e_2variable ;------------------------------------------------------------------
                
                            ; ACTION-OF  ( "<spaces>name" -- xt )
    51EF 1052               DW   e_actionof
    51F1 896163             DB   9+FL_IMMEDIATE,"action-of"
    51F4 74696F 
    51F7 6E2D6F 
    51FA 66     
    51FB 1E     c_actionof  PHL
    51FC 191750             JSR  c_tick
    51FF 159A               TST  STATE
    5201 16B471             JPF  _c_deferld  ;interpretation mode
                            ;compilation mode
    5204 195673             JSR  c_literal
    5207 010CB3             LD   PTR_L,#<c_deferld
    520A 010D71             LD   PTR_H,#>c_deferld
    520D 18CE74             JMP  add_word_call_ret
                e_actionof  ;------------------------------------------------------------------
                
                            ; [COMPILE]
    5210 2652               DW   e_compileb
    5212 895B63             DB   9+FL_IMMEDIATE,"[compile]"
    5215 6F6D70 
    5218 696C65 
    521B 5D     
    521C 1E     c_compileb  PHL
    521D 19224C             JSR  search_word_ex
    5220 16074A             JPF  Error_Word ;word not found
    5223 18CE74             JMP  add_word_call_ret
                e_compileb  ;------------------------------------------------------------------
                
                            ; SOURCE-ID  ( -- 0 | -1 ) 
    5226 3C52               DW   e_sourceid
    5228 09736F             DB   9,"source-id"
    522B 757263 
    522E 652D69 
    5231 64     
    5232 04A2   c_sourceid  LDA  INPTR_H
    5234 13FF               CMP  #>EVALUATE_BUF
    5236 16005E             JPF  c_true
    5239 18636B             JMP  c_false
                e_sourceid  ;------------------------------------------------------------------
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_block.asm]
                
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_my4th.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for My4TH
                ;------------------------------------------------------------------------------
                
                ;#ifdef WORDS_LEN_2
                ;            ; ,> ( "hexbytestream" -- )  Compile machine code to currently compiled word
                ;            DW   e_mgt
                ;            DB   2+FL_IMMEDIATE,",>"
                ;c_mgt       PHL
                ;            JSR  ld_ptr_inptr
                ;_c_mgt_1    LAP
                ;            TST
                ;            JPF  _c_mgt_2
                ;            CMP  #0x20
                ;            JPF  _c_mgt_2
                ;            JSR  inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            ROL
                ;            ROL
                ;            ROL
                ;            ROL
                ;            STA  R0
                ;            JSR  lap_inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            OR   R0
                ;            JSR  emit_code
                ;            JMP  _c_mgt_1
                ;_c_mgt_2    JSR  ld_inptr_ptr
                ;            RTS
                ;e_mgt       ;------------------------------------------------------------------
                ;#endif
                
                ;#ifdef WORDS_LEN_3
                ;            ; >SY  Convert index number to system call address
                ;            DW   e_2system
                ;            DB   3,">sy"
                ;c_2system   PHL
                ;            JSR  pop_data_R4
                ;            LDA  #<tab_syscalls
                ;            CLC
                ;            ROL  R4_L
                ;            ADD  R4_L
                ;            STA  PTR_L
                ;            LD   PTR_H,#>tab_syscalls
                ;            JSR  lap_inc_ptr
                ;            STA  R4_L
                ;            LAP
                ;            STA  R4_H
                ;            JMP  push_data_R4_ret
                ;e_2system   ;------------------------------------------------------------------
                ;#endif
                
                
                
                
                            ; I2C-START  ( addr -- ack )  send a start condition
    523C 5B52               DW   e_i2cstart
    523E 096932             DB   9,"i2c-start"
    5241 632D73 
    5244 746172 
    5247 74     
    5248 1E     c_i2cstart  PHL
    5249 190E45             JSR  pop_data_R4
    524C 021014             LD   R0,R4_L
    524F 19F62D             JSR  i2c_start_addr
    5252 174D75             JNF  _ci2csnd01
    5255 19DE2D             JSR  i2c_stop
    5258 18B852             JMP  ret_false
                e_i2cstart  ;------------------------------------------------------------------
                
                
                
                
                
                            ; RUN-IMAGE  ( n -- )
                            ; Usage: To load and run a file from EEPROM block 5 and following blocks, enter:
                            ; 5 run-image
    525B 6C52               DW   e_runimage
    525D 097275             DB   9,"run-image"
    5260 6E2D69 
    5263 6D6167 
    5266 65     
    5267 0301   c_runimage  LDA  #1
    5269 189758             JMP  _ldforth10
                e_runimage  ;------------------------------------------------------------------
                
                
                
                
                
                
                
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_mynor.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for MyNOR
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_bload.asm]
                ;------------------------------------------------------------------------------
                ;  Binary Driver Loader
                ;------------------------------------------------------------------------------
                ;
                ;  This module can load and relocate a binary driver image into RAM memory.
                ;
                ;  The binary driver image must begin with this header:
                ;
                ;    1. byte :  ID 0x1B
                ;    2. byte :  reserved, must be 0
                ;    3. byte :  file size, bits 0-7
                ;    4. byte :  file size, bits 8-15
                ;    5. byte :  module compile address, bits 0-7
                ;    6. byte :  module compile address, bits 8-15
                ;    7. byte :  offset to the startup function, bits 0-7   (can be 0 if not used)
                ;    8. byte :  offset to the startup function, bits 8-15  (can be 0 if not used)
                ;    9. byte :  size of the following data section, bits 0-7
                ;   10. byte :  size of the following data section, bits 8-15
                ;
                ;  This module relocates all address it finds in the code section.
                ;  Data pointers must be written as a pair of " LD PTR_L,# / LD PTR_H,# ",
                ;  otherwise they won't be recognized.
                ;
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_edit.asm]
                
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words.asm]
    526C 000000   DB 0,0,0 ;end-marker
    526F 23       clc
                dictionary_2:
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words_basis.asm]
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 2 characters
                ;------------------------------------------------------------------------------
                
                
                            ; +!  ( x addr -- )  Add the value x to the cell at addr
    5270 8E52               DW   e_plusstore
    5272 022B21             DB   2,"+!"
    5275 1E     c_plusstore PHL
    5276 190E45             JSR  pop_data_R4
    5279 19213B             JSR  ld_ptr_r4
    527C 190E45             JSR  pop_data_R4
    527F 05                 LAP
    5280 2414               AD   R4_L
    5282 07                 SAP
    5283 1B0F               PSH  FLAG
    5285 19E43A             JSR  inc_ptr_lap
    5288 1C0F               POP  FLAG
    528A 1015               ADD  R4_H
    528C 07                 SAP
    528D 1F                 RTS
                e_plusstore ;------------------------------------------------------------------
                
                            ; 0=  ( x -- flag )  -1 if top of stack is 0, 0 otherwise
    528E A152               DW   e_test0
    5290 02303D             DB   2,"0="
    5293 1E     c_test0     PHL
    5294 190E45             JSR  pop_data_R4
    5297 1514   _c_test01   TST  R4_L
    5299 17B852             JNF  ret_false
    529C 1515               TST  R4_H
    529E 188B50             JMP  _c_equal_1
                e_test0     ;------------------------------------------------------------------
                
                            ; <>  ( x1 x2 -- flag )  flag is true if and only if x1 is not bit-for-bit the same as x2.
    52A1 C152               DW   e_noteq
    52A3 023C3E             DB   2,"<>"
    52A6 1E     c_noteq     PHL
    52A7 193A45             JSR  pop_data_R4_R5
    52AA 0414               LDA  R4_L
    52AC 1416               CMP  R5_L
    52AE 178E50             JNF  ret_true
    52B1 0415               LDA  R4_H
    52B3 1417               CMP  R5_H
    52B5 178E50 _c_noteq_1  JNF  ret_true
    52B8 011400 ret_false   LD   R4_L,#0x00
    52BB 021514 _rettf      LD   R4_H,R4_L
    52BE 18D744             JMP  push_data_R4_ret
                e_noteq     ;------------------------------------------------------------------
                
                            ; 0<  ( x -- flag )  test if number is less than zero
    52C1 CF52               DW   e_zeroless
    52C3 02303C             DB   2,"0<"
    52C6 1E     c_zeroless  PHL
    52C7 190E45             JSR  pop_data_R4
    52CA 0B15   c_zeroless1 ROL  R4_H
    52CC 188B50             JMP  _c_equal_1
                e_zeroless  ;------------------------------------------------------------------
                
                            ; 0>  ( x -- flag )  test if number is greater than zero
    52CF E752               DW   e_zerogt
    52D1 02303E             DB   2,"0>"
    52D4 1E     c_zerogt    PHL
    52D5 190E45             JSR  pop_data_R4
    52D8 1514               TST  R4_L
    52DA 17E252             JNF  _c_zerogt_1
    52DD 1515               TST  R4_H
    52DF 16B852             JPF  ret_false
    52E2 0B15   _c_zerogt_1 ROL  R4_H
    52E4 18B552             JMP  _c_noteq_1
                e_zerogt    ;------------------------------------------------------------------
                
                            ; u<  ( x y -- flag )  Return true if x is less than y
    52E7 F352               DW   e_ulessthan
    52E9 02753C             DB   2,"u<"
    52EC 1E     c_ulessthan PHL
    52ED 195945             JSR  pop_data_R5_R4
    52F0 186250             JMP  _c_lthan_2
                e_ulessthan ;------------------------------------------------------------------
                
                            ; u>  ( x y -- flag )  Return true if x is greater than y
    52F3 FF52               DW   e_ugrtrthan
    52F5 02753E             DB   2,"u>"
    52F8 1E     c_ugrtrthan PHL
    52F9 193A45             JSR  pop_data_R4_R5
    52FC 186250             JMP  _c_lthan_2
                e_ugrtrthan ;------------------------------------------------------------------
                
                            ; 1+  ( x -- z )  Add 1 to the value on the stack
    52FF 0E53               DW   e_1plus
    5301 02312B             DB   2,"1+"
    5304 1E     c_1plus     PHL
    5305 190E45             JSR  pop_data_R4
    5308 19F93A             JSR  inc_r4
    530B 18D744             JMP  push_data_R4_ret
                e_1plus     ;------------------------------------------------------------------
                
                            ; 1-  ( x -- z )  Subtract 1 from the value on the stack
    530E 1D53               DW   e_1minus
    5310 02312D             DB   2,"1-"
    5313 1E     c_1minus    PHL
    5314 190E45             JSR  pop_data_R4
    5317 19DE40             JSR  dec_r4
    531A 18D744             JMP  push_data_R4_ret
                e_1minus     ;------------------------------------------------------------------
                
                            ; or  ( x y -- z )  OR the two numbers at the top of the stack
    531D 3353               DW   e_or16
    531F 026F72             DB   2,"or"
    5322 1E     c_or16      PHL
    5323 193A45             JSR  pop_data_R4_R5
    5326 0414               LDA  R4_L
    5328 0E16               OR   R5_L
    532A 0614               STA  R4_L
    532C 0415               LDA  R4_H
    532E 0E17               OR   R5_H
    5330 182B5A             JMP  _c_xor16_1
                e_or16      ;------------------------------------------------------------------
                
                            ; 2*  ( x -- z )  Shift the value on the stack 1 bit left
    5333 4253               DW   e_2star
    5335 02322A             DB   2,"2*"
    5338 1E     c_2star     PHL
    5339 190E45             JSR  pop_data_R4
    533C 23                 CLC
    533D 2114               RWL  R4_L
    533F 18D744             JMP  push_data_R4_ret
                e_2star     ;------------------------------------------------------------------
                
                            ; 2/  ( x -- z )  Divide the value on the stack by 2
    5342 5653               DW   e_2slash
    5344 02322F             DB   2,"2/"
    5347 1E     c_2slash    PHL
    5348 190E45             JSR  pop_data_R4
    534B 0415               LDA  R4_H
    534D 0B0E               ROL
    534F 0C15               ROR  R4_H
    5351 0C14               ROR  R4_L
    5353 18D744             JMP  push_data_R4_ret
                e_2slash    ;------------------------------------------------------------------
                
                            ; u.  ( x -- )  Display unsigned number
    5356 6253               DW   e_udot
    5358 02752E             DB   2,"u."
    535B 1E     c_udot      PHL
    535C 19454E             JSR  print_unsigned
    535F 18E650             JMP  p_space_rts
                e_udot      ;------------------------------------------------------------------
                
                            ; cr ( -- )  Print CR and LF
    5362 6A53               DW   e_cr
    5364 026372             DB   2,"cr"
    5367 182233 c_cr        JMP  print_nl
                e_cr        ;------------------------------------------------------------------
                
                            ; ."  Print a string
    536A DC53               DW   e_prstr
    536C 822E22             DB   2+FL_IMMEDIATE,".",0x22
    536F 011A46 c_prstr     LD   R7_L,#<print_str
    5372 011B33             LD   R7_H,#>print_str
                _prstr_common:  ;common code for storing and printing a string or testing for abort
    5375 1E                 PHL
    5376 1B64               PSH  CP_L
    5378 1B65               PSH  CP_H
    537A 159A               TST  STATE
    537C 168453             JPF  _ccprstr04
    537F 0318               LDA  #0x18
    5381 192D4D             JSR  add_JmpOrJsr
                            ;copy all characters, stop at ["] or [)]
    5384 19B849 _ccprstr04  JSR  ld_ptr_inptr
    5387 195654 _ccprstr01  JSR  lap_incptr_qchk
    538A 1322               CMP  #0x22 ; "
    538C 169553             JPF  _ccprstr03
    538F 19D453             JSR  _cpremit
    5392 188753             JMP  _ccprstr01
                _ccprstr03  ; " found and remove it from the input buffer
    5395 19B149             JSR  ld_inptr_ptr
    5398 19563B             JSR  pop_ptr  ;get CP from stack
                            ;quit here if in interpreter mode
    539B 159A               TST  STATE
    539D 16CA3A             JPF  return
                            ;write terminating zero
    53A0 0300               LDA  #0
    53A2 19134E             JSR  emit_code
                            ;set target address for jmp instruction
    53A5 19DA3A             JSR  inc_ptr
    53A8 0464               LDA  CP_L
    53AA 19D93A             JSR  sap_inc_ptr
    53AD 0465               LDA  CP_H
    53AF 19D93A             JSR  sap_inc_ptr
    53B2 193D3B             JSR  psh_ptr
    53B5 19114E             JSR  emit_code_ldi
    53B8 030D               LDA  #PTR_H
    53BA 19134E             JSR  emit_code
    53BD 1C0E               POP
    53BF 19134E             JSR  emit_code
    53C2 19114E             JSR  emit_code_ldi
    53C5 030C               LDA  #PTR_L
    53C7 19134E             JSR  emit_code
    53CA 1C0E               POP
    53CC 19134E             JSR  emit_code
    53CF 0319               LDA  #0x19
    53D1 183E4D             JMP  emit_opaadr_ret
    53D4 159A   _cpremit    TST  STATE
    53D6 17134E             JNF  emit_code
    53D9 182433             JMP  print_char
                e_prstr     ;------------------------------------------------------------------
                
                            ; .(  Print a string immediately
    53DC ED53               DW   e_dotparen
    53DE 822E28             DB   2+FL_IMMEDIATE,".("
    53E1 1E     c_dotparen  PHL
    53E2 0329               LDA  #')'
    53E4 19EE44             JSR  push_data_accu
    53E7 195B6C             JSR  c_parse
    53EA 18765D             JMP  _c_type_ret
                e_dotparen  ;------------------------------------------------------------------
                
                            ; s"  ( -- addr len )  Insert string and return address and length on stack
    53ED 6054               DW   e_squote
    53EF 827322             DB   2+FL_IMMEDIATE,"s",0x22
    53F2 1E     c_squote    PHL
                            ;emit code that jumps over the string
    53F3 190754             JSR  scquote_cm1
                            ;copy the string into memory
    53F6 192354             JSR  scquote_cm2
                scquote_cm3 ;emit code that pushes the string length to the stack
    53F9 021416             LD   R4_L,R5_L
    53FC 011500             LD   R4_H,#0
    53FF 159A               TST  STATE
    5401 16D744             JPF  push_data_R4_ret   ; in interpreter mode simply put the string length onto the stack
    5404 18B04D             JMP  add_16bit_literal_ret
                scquote_cm1 ;common code1 for c", s" and s\"
    5407 1E                 PHL
    5408 027E64             LD   MATH_BUF+0,CP_L
    540B 027F65             LD   MATH_BUF+1,CP_H
    540E 0318               LDA  #0x18
    5410 19134E             JSR  emit_code
    5413 021864             LD   R6_L,CP_L
    5416 021965             LD   R6_H,CP_H
    5419 19134E             JSR  emit_code
    541C 19134E             JSR  emit_code
    541F 193E4E             JSR  ld_r4_cp
    5422 1F                 RTS
                scquote_cm2 ;common code2 for c" and s"
    5423 1E                 PHL
    5424 011600             LD   R5_L,#0
                            ;copy all characters, stop at ["]
    5427 19B849             JSR  ld_ptr_inptr
    542A 195654 _csqcp01    JSR  lap_incptr_qchk
    542D 1322               CMP  #0x22
    542F 163A54             JPF  scquote_cm4
    5432 19134E             JSR  emit_code
    5435 0916               INC  R5_L
    5437 182A54             JMP  _csqcp01
                scquote_cm4 ; " found and remove it from the input buffer
    543A 19B149             JSR  ld_inptr_ptr
                            ;set jump address
    543D 192F3B             JSR  ld_ptr_r6
    5440 0464               LDA  CP_L
    5442 19D93A             JSR  sap_inc_ptr
    5445 0465               LDA  CP_H
    5447 07                 SAP
                            ;test compilation state, restore CP if in interpreter state and push ptr to string onto stack
    5448 159A               TST  STATE
    544A 17B04D             JNF  add_16bit_literal_ret  ;emit code that pushes the string address to the stack
    544D 02647E             LD   CP_L,MATH_BUF+0
    5450 02657F             LD   CP_H,MATH_BUF+1
    5453 18D744             JMP  push_data_R4_ret
                lap_incptr_qchk:
    5456 1E                 PHL
    5457 19CE3A             JSR  lap_inc_ptr
    545A 150E               TST
    545C 162F4A             JPF  Error_Quote
    545F 1F                 RTS
                e_squote    ;------------------------------------------------------------------
                
                            ; c"  ( -- addr )  Insert a counted string and return address on stack
    5460 7654               DW   e_cquote
    5462 826322             DB   2+FL_IMMEDIATE,"c",0x22
    5465 1E     c_cquote    PHL
                            ;emit code that jumps over the string
    5466 190754             JSR  scquote_cm1
    5469 19134E             JSR  emit_code    ;place holder for string length
                            ;copy the string into memory and do some more, share code with s"
    546C 192354             JSR  scquote_cm2
                            ;store string length
    546F 19213B             JSR  ld_ptr_r4
    5472 0416               LDA  R5_L
    5474 07                 SAP
    5475 1F                 RTS
                e_cquote    ;------------------------------------------------------------------
                
                            ; IF  (x -- )  Begin an IF-ELSE-THEN construct
    5476 9054               DW   e_if
    5478 826966             DB   2+FL_IMMEDIATE,"if"
    547B 011AA9 c_if        LD   R7_L,#<if_check
    547E 011B4E             LD   R7_H,#>if_check
    5481 1E     _c_ifof     PHL
    5482 193B4D             JSR  emit_jsr
    5485 0316               LDA  #0x16
    5487 19134E             JSR  emit_code
    548A 195944             JSR  ccfs_push_cp
    548D 18C354             JMP  _c_do_2
                e_if        ;------------------------------------------------------------------
                
                            ; DO  ( end idx -- )  Start a definite loop
    5490 CA54               DW   e_do
    5492 82646F             DB   2+FL_IMMEDIATE,"do"
    5495 011ACC c_do        LD   R7_L,#<do_code
    5498 011B4E             LD   R7_H,#>do_code
    549B 1E     _c_do_1     PHL
    549C 193B4D             JSR  emit_jsr
    549F 0317               LDA  #0x17  ; insert an conditional jump to the code behind DO
    54A1 19134E             JSR  emit_code
    54A4 0305               LDA  #5
    54A6 2464               AD   CP_L
    54A8 0614               STA  R4_L
    54AA 0300               LDA  #0
    54AC 1065               ADD  CP_H
    54AE 0615               STA  R4_H
    54B0 190C4E             JSR  emit_code_R4L
    54B3 0415               LDA  R4_H
    54B5 19134E             JSR  emit_code
    54B8 0318               LDA  #0x18  ; insert an unconditional jump to the word behind the loop word
    54BA 19134E             JSR  emit_code
    54BD 193E4E             JSR  ld_r4_cp
    54C0 198E44             JSR  lcfs_push
    54C3 19224E _c_do_2     JSR  inc_cp
    54C6 19224E             JSR  inc_cp
    54C9 1F                 RTS
                e_do        ;------------------------------------------------------------------
                
                            ; C!  ( char c-addr -- )  Store one byte ('character') at addr
    54CA DA54               DW   e_cstore
    54CC 026321             DB   2,"c!"
    54CF 1E     c_cstore    PHL
    54D0 195945             JSR  pop_data_R5_R4
    54D3 19283B             JSR  ld_ptr_r5
    54D6 0414               LDA  R4_L
    54D8 07                 SAP
    54D9 1F                 RTS
                e_cstore    ;------------------------------------------------------------------
                
                            ; C,  ( char -- )  Reserve space for one character in the data space and store char in the space.
    54DA E854               DW   e_ccomma
    54DC 02632C             DB   2,"c,"
    54DF 1E     c_ccomma    PHL
    54E0 190E45             JSR  pop_data_R4
    54E3 0414               LDA  R4_L
    54E5 18274D             JMP  emit_code_ret
                e_ccomma    ;------------------------------------------------------------------
                
                            ; C@  ( c-addr -- char )  Fetch the character stored at c-addr.
    54E8 F854               DW   e_c_at
    54EA 026340             DB   2,"c@"
    54ED 1E     c_c_at      PHL
    54EE 190E45             JSR  pop_data_R4
    54F1 19213B             JSR  ld_ptr_r4
    54F4 05                 LAP
    54F5 18D244             JMP  push_data_accu_ret
                e_c_at      ;------------------------------------------------------------------
                
                            ; 2!  ( x1 x2 a-addr -- )   Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next consecutive cell.
    54F8 1755               DW   e_2store
    54FA 023221             DB   2,"2!"
    54FD 1E     c_2store    PHL
    54FE 190E45             JSR  pop_data_R4
    5501 19213B             JSR  ld_ptr_r4
    5504 190E45 _c_2store_1 JSR  pop_data_R4
    5507 0414               LDA  R4_L
    5509 19D93A             JSR  sap_inc_ptr
    550C 0415               LDA  R4_H
    550E 19D93A             JSR  sap_inc_ptr
    5511 190E45 _c_2store_2 JSR  pop_data_R4
    5514 184550             JMP  _c_store_2
                e_2store    ;------------------------------------------------------------------
                
                            ; 2@  ( a-addr -- x1 x2 )  Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at the next consecutive cell. 
    5517 3855               DW   e_2at
    5519 023240             DB   2,"2@"
    551C 1E     c_2at       PHL
    551D 190E45             JSR  pop_data_R4
    5520 19213B _c_2at_1    JSR  ld_ptr_r4
    5523 19CE3A             JSR  lap_inc_ptr
    5526 0616               STA  R5_L
    5528 19CE3A             JSR  lap_inc_ptr
    552B 0617               STA  R5_H
    552D 19CE3A             JSR  lap_inc_ptr
    5530 0614               STA  R4_L
    5532 05                 LAP
    5533 0615               STA  R4_H
    5535 18F644             JMP  push_data_R4_R5_ret
                e_2at       ;------------------------------------------------------------------
                
                            ; */  ( n1 n2 n3 -- n4 )  Multiply n1 by n2 producing the intermediate double-cell result d.
    5538 5355               DW   e_starsl
    553A 022A2F             DB   2,"*/"
    553D 1E     c_starsl    PHL
    553E 190E45             JSR  pop_data_R4
    5541 021814             LD   R6_L,R4_L
    5544 021915             LD   R6_H,R4_H
    5547 193A45             JSR  pop_data_R4_R5
    554A 190A43             JSR  multiply_s
    554D 190A42             JSR  div_i32i16
    5550 18D744             JMP  push_data_R4_ret
                e_starsl    ;------------------------------------------------------------------
                
                            ; M*  ( n1 n2 -- d )
    5553 6255               DW   e_mstar
    5555 026D2A             DB   2,"m*"
    5558 1E     c_mstar     PHL
    5559 193A45             JSR  pop_data_R4_R5
    555C 190A43             JSR  multiply_s
    555F 18F644             JMP  push_data_R4_R5_ret
                e_mstar     ;------------------------------------------------------------------
                
                            ; >R  ( x -- )  ( R:  -- x )  Move x to the return stack.
    5562 6F55               DW   e_tor
    5564 023E72             DB   2,">r"
    5567 1E     c_tor       PHL
    5568 190E45             JSR  pop_data_R4
    556B 193144             JSR  retstk_push
    556E 1F                 RTS
                e_tor       ;------------------------------------------------------------------
                
                            ; R>  ( -- x )  ( R:  x -- )  Move x from the return stack to the data stack.
    556F 7B55               DW   e_rfrom
    5571 02723E             DB   2,"r>"
    5574 1E     c_rfrom     PHL
    5575 194544             JSR  retstk_pop
    5578 18D744             JMP  push_data_R4_ret
                e_rfrom     ;------------------------------------------------------------------
                
                            ; R@  ( -- x )  ( R:  x -- x )  Copy x from the return stack to the data stack.
    557B 8A55               DW   e_rat
    557D 027240             DB   2,"r@"
    5580 1E     c_rat       PHL
    5581 194544             JSR  retstk_pop
    5584 193144             JSR  retstk_push
    5587 18D744             JMP  push_data_R4_ret
                e_rat       ;------------------------------------------------------------------
                
                            ; OF  ( x1 x2 --   | x1 )
    558A 9855               DW   e_of
    558C 826F66             DB   2+FL_IMMEDIATE,"of"
    558F 011AB5 c_of        LD   R7_L,#<of_check
    5592 011B4E             LD   R7_H,#>of_check
    5595 188154             JMP  _c_ifof
                e_of        ;------------------------------------------------------------------
                
                            ; <#
    5598 A455               DW   e_lns
    559A 023C23             DB   2,"<#"
    559D 01A7A0 c_lns       LD   NB_L,#<(NUM_BUF+NUMBUF_SZ)
    55A0 01A8FE             LD   NB_H,#>NUM_BUF
    55A3 1A                 RET
                e_lns       ;------------------------------------------------------------------
                
                            ; #>  ( xd -- c-addr u )
    55A4 BD55               DW   e_nsg
    55A6 02233E             DB   2,"#>"
    55A9 1E     c_nsg       PHL
    55AA 193A45             JSR  pop_data_R4_R5
    55AD 0214A7             LD   R4_L,NB_L
    55B0 0215A8             LD   R4_H,NB_H
    55B3 19DB44             JSR  push_data_R4
    55B6 03A0               LDA  #<(NUM_BUF+NUMBUF_SZ)
    55B8 25A7               SU   NB_L
    55BA 18D244             JMP  push_data_accu_ret
                e_nsg       ;------------------------------------------------------------------
                
                            ; #S  ( ud1 -- ud2 )  Formatted number output.
    55BD F355               DW   e_nss
    55BF 022373             DB   2,"#s"
    55C2 1E     c_nss       PHL
    55C3 195945             JSR  pop_data_R5_R4
    55C6 021889 _c_nss1     LD   R6_L,BASE
    55C9 02198A             LD   R6_H,BASE+1
    55CC 192441             JSR  div_u32u16
    55CF 03C0               LDA  #<tab_num2asc
    55D1 0E18               OR   R6_L
    55D3 060C               STA  PTR_L
    55D5 010D7C             LD   PTR_H,#>tab_num2asc
    55D8 05                 LAP
    55D9 197551             JSR  _outnumchr
    55DC 1514               TST  R4_L
    55DE 17C655             JNF  _c_nss1
    55E1 1515               TST  R4_H
    55E3 17C655             JNF  _c_nss1
    55E6 1516               TST  R5_L
    55E8 17C655             JNF  _c_nss1
    55EB 1517               TST  R5_H
    55ED 17C655             JNF  _c_nss1
    55F0 18F644             JMP  push_data_R4_R5_ret
                e_nss       ;------------------------------------------------------------------
                
                            ; .R  ( n1 n2 -- )  Display n1 right aligned in a field n2 characters wide.
    55F3 1156               DW   e_dotr
    55F5 022E72             DB   2,".r"
    55F8 1E     c_dotr      PHL
    55F9 195945             JSR  pop_data_R5_R4
    55FC 0415               LDA  R4_H ; get the sign
    55FE 0610               STA  R0  
    5600 0B0E               ROL
    5602 170B56             JNF  _c_dotr1
    5605 19AE40             JSR  inv_r4
    5608 19F93A             JSR  inc_r4
    560B 19DB44 _c_dotr1    JSR  push_data_R4
                            ;R5_L = aligned length
                            ;R0.7 = sign
    560E 18105B             JMP  _c_udotri   ;use 2nd half of U.R
                e_dotr      ;------------------------------------------------------------------
                
                            ; D.  ( d -- )  Display d in free field format.
    5611 3256               DW   e_ddot
    5613 02642E             DB   2,"d."
    5616 1E     c_ddot      PHL
                            ;TUCK DABS <#  #S ROT SIGN  #>  TYPE SPACE
    5617 190A5E             JSR  c_tuck
    561A 19885E             JSR  c_dabs
    561D 199D55             JSR  c_lns
    5620 19C255             JSR  c_nss
    5623 19A559             JSR  c_rot
    5626 193E5E             JSR  c_sign
    5629 19A955             JSR  c_nsg
    562C 19755D             JSR  c_type
    562F 18E650             JMP  p_space_rts
                e_ddot      ;------------------------------------------------------------------
                
                            ; D+  ( d1|ud1 d2|ud2 -- d3|ud3 )   Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
    5632 6A56               DW   e_sum32
    5634 02642B             DB   2,"d+"
    5637 1E     c_sum32     PHL
    5638 195656             JSR  _popBufpop
    563B 0420   _c_sum321   LDA  LIB_BUF+0
    563D 2414               AD   R4_L
    563F 0614               STA  R4_L
    5641 0421               LDA  LIB_BUF+1
    5643 1015               ADD  R4_H
    5645 0615               STA  R4_H
    5647 0422               LDA  LIB_BUF+2
    5649 1016               ADD  R5_L
    564B 0616               STA  R5_L
    564D 0423               LDA  LIB_BUF+3
    564F 1017               ADD  R5_H
    5651 0617               STA  R5_H
    5653 18F644             JMP  push_data_R4_R5_ret
    5656 1E     _popBufpop  PHL
    5657 195945             JSR  pop_data_R5_R4
    565A 022014             LD   LIB_BUF+0,R4_L
    565D 022115             LD   LIB_BUF+1,R4_H
    5660 022216             LD   LIB_BUF+2,R5_L
    5663 022317             LD   LIB_BUF+3,R5_H
    5666 195945             JSR  pop_data_R5_R4
    5669 1F                 RTS
                e_sum32     ;------------------------------------------------------------------
                
                            ; M+  ( d1|ud1 n -- d2|ud2 )   Add n to d1|ud1, giving the sum d2|ud2.
    566A 8C56               DW   e_msum32
    566C 026D2B             DB   2,"m+"
    566F 1E     c_msum32    PHL
    5670 190E45             JSR  pop_data_R4
    5673 022014             LD   LIB_BUF+0,R4_L
    5676 022115             LD   LIB_BUF+1,R4_H
    5679 0300               LDA  #0
    567B 0B15               ROL  R4_H
    567D 178256             JNF  _c_msum321
    5680 0A0E               DEC
    5682 0622   _c_msum321  STA  LIB_BUF+2
    5684 0623               STA  LIB_BUF+3
    5686 195945             JSR  pop_data_R5_R4
    5689 183B56             JMP  _c_sum321
                e_msum32    ;------------------------------------------------------------------
                
                            ; D-  ( d1|ud1 d2|ud2 -- d3|ud3 )   Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
    568C C956               DW   e_sub32
    568E 02642D             DB   2,"d-"
    5691 1E     c_sub32     PHL
    5692 011000             LD   R0,#0
    5695 199B56             JSR  _c_sub32
    5698 18F644             JMP  push_data_R4_R5_ret
    569B 1E     _c_sub32    PHL
    569C 195656             JSR  _popBufpop
    569F 1510               TST  R0
    56A1 16B056             JPF  _c_sub321
    56A4 0B23               ROL  LIB_BUF+3
    56A6 090F               INC  FLAG
    56A8 0C23               ROR  LIB_BUF+3
    56AA 0B17               ROL  R5_H
    56AC 090F               INC  FLAG
    56AE 0C17               ROR  R5_H
    56B0 0414   _c_sub321   LDA  R4_L
    56B2 2520               SU   LIB_BUF+0
    56B4 0614               STA  R4_L
    56B6 0415               LDA  R4_H
    56B8 1121               SUB  LIB_BUF+1
    56BA 0615               STA  R4_H
    56BC 0416               LDA  R5_L
    56BE 1122               SUB  LIB_BUF+2
    56C0 0616               STA  R5_L
    56C2 0417               LDA  R5_H
    56C4 1123               SUB  LIB_BUF+3
    56C6 0617               STA  R5_H
    56C8 1F                 RTS
                e_sub32     ;------------------------------------------------------------------
                
                            ; D<  ( d1 d2 -- flag )  flag is true if and only if d1 is less than d2.
    56C9 D856               DW   e_dless
    56CB 02643C             DB   2,"d<"
    56CE 1E     c_dless     PHL
    56CF 011001             LD   R0,#1
    56D2 199B56             JSR  _c_sub32
    56D5 18B552             JMP  _c_noteq_1
                e_dless     ;------------------------------------------------------------------
                
                            ; D=  ( d1 d2 -- flag )  flag is true if and only if d1 is bit-for-bit the same as d2.
    56D8 FB56               DW   e_dequals
    56DA 02643D             DB   2,"d="
    56DD 1E     c_dequals   PHL
    56DE 195656             JSR  _popBufpop
    56E1 0420               LDA  LIB_BUF+0
    56E3 1414               CMP  R4_L
    56E5 17B852             JNF  ret_false
    56E8 0421               LDA  LIB_BUF+1
    56EA 1415               CMP  R4_H
    56EC 17B852             JNF  ret_false
    56EF 0422               LDA  LIB_BUF+2
    56F1 1416               CMP  R5_L
    56F3 17B852             JNF  ret_false
    56F6 0423               LDA  LIB_BUF+3
    56F8 188950             JMP  _c_equal_2
                e_dequals   ;------------------------------------------------------------------
                
                            ; TO  ( x "<spaces>name" -- )
    56FB 3B57               DW   e_to
    56FD 82746F             DB   2+FL_IMMEDIATE,"to"
    5700 1E     c_to        PHL
    5701 191750             JSR  c_tick
    5704 19956C             JSR  c_tobody
    5707 190E45             JSR  pop_data_R4
    570A 19213B             JSR  ld_ptr_r4
    570D 19CE3A             JSR  lap_inc_ptr
    5710 159A               TST  STATE
    5712 163357             JPF  _c_to_1
                            ;compilation mode
    5715 1B0E               PSH
    5717 19AA49             JSR  ld_r4_ptr
    571A 19AF4D             JSR  add_16bit_literal
    571D 1C0E               POP
    571F 010CFD             LD   PTR_L,#<c_2store
    5722 010D54             LD   PTR_H,#>c_2store
    5725 150E               TST
    5727 17CE74             JNF  add_word_call_ret ;store 32-bit value
    572A 010C3E             LD   PTR_L,#<c_store
    572D 010D50             LD   PTR_H,#>c_store
    5730 18CE74             JMP  add_word_call_ret ;store 16-bit value
                _c_to_1     ;interpretation mode
    5733 150E               TST
    5735 170455             JNF  _c_2store_1 ;32-bit value
    5738 181155             JMP  _c_2store_2 ;16-bit value
                e_to        ;------------------------------------------------------------------
                
                            ; IS  ( xt "<spaces>name" -- )
    573B 5557               DW   e_is
    573D 826973             DB   2+FL_IMMEDIATE,"is"
    5740 1E     c_is        PHL
    5741 191750             JSR  c_tick
    5744 159A               TST  STATE
    5746 169E71             JPF  _c_defstor  ;interpretation mode
                            ;compilation mode
    5749 195673             JSR  c_literal
    574C 010C9D             LD   PTR_L,#<c_deferstor
    574F 010D71             LD   PTR_H,#>c_deferstor
    5752 18CE74             JMP  add_word_call_ret
                e_is        ;------------------------------------------------------------------
                
                            ; MS  ( milliseconds -- , delay )   delays for some milliseconds
    5755 7057               DW   e_ms
    5757 026D73             DB   2,"ms"
    575A 1E     c_ms        PHL
    575B 190E45             JSR  pop_data_R4
    575E 0414               LDA  R4_L
    5760 150E               TST
    5762 166857             JPF  _cmsec2
    5765 197076 _cmsec1     JSR  delay_ms
    5768 1515   _cmsec2     TST  R4_H
    576A 0A15               DEC  R4_H
    576C 176557             JNF  _cmsec1
    576F 1F                 RTS
                e_ms        ;------------------------------------------------------------------
                
                            ; UP
    5770 7E57               DW   e_up
    5772 027570             DB   2,"up"
    5775 011476 c_up        LD   R4_L,#UP_L
    5778 011580             LD   R4_H,#REGPAGE_HI
    577B 18DB44             JMP  push_data_R4
                e_up        ;------------------------------------------------------------------
                
                            ; .s  ; print stack content, but leave stack unchanged
    577E BD57               DW   e_dots
    5780 022E73             DB   2,".s"
    5783 1E     c_dots      PHL
    5784 033C               LDA  #'<'
    5786 192433             JSR  print_char
    5789 196E6B             JSR  c_depth
    578C 194C4E             JSR  print_integer
    578F 033E               LDA  #'>'
    5791 192433             JSR  print_char
    5794 010C00             LD   PTR_L,#0
    5797 010D81             LD   PTR_H,#>STACK
    579A 0495   _cdots2     LDA  fPSP
    579C 140C               CMP  PTR_L
    579E 16E650             JPF  p_space_rts
    57A1 19CE3A             JSR  lap_inc_ptr
    57A4 0614               STA  R4_L
    57A6 19CE3A             JSR  lap_inc_ptr
    57A9 0615               STA  R4_H
    57AB 193D3B             JSR  psh_ptr
    57AE 19DB44             JSR  push_data_R4
    57B1 191833             JSR  print_space
    57B4 194C4E             JSR  print_integer
    57B7 19563B             JSR  pop_ptr
    57BA 189A57             JMP  _cdots2
                e_dots      ;------------------------------------------------------------------
                
                            ; BL
    57BD C857               DW   e_bl
    57BF 02626C             DB   2,"bl"
    57C2 1E     c_bl        PHL
    57C3 0320               LDA  #32
    57C5 18D244             JMP  push_data_accu_ret
                e_bl        ;------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 3 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 4 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 5 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 6 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 7 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 8 characters
                ;------------------------------------------------------------------------------
                
                
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 10 characters
                ;------------------------------------------------------------------------------
                
                            ; PARSE-NAME  ( "<spaces>name<space>" -- c-addr u ) Skip leading space delimiters. Parse name delimited by a space. 
    57C8 DC57               DW   e_parsename
    57CA 0A7061             DB   10,"parse-name"
    57CD 727365 
    57D0 2D6E61 
    57D3 6D65   
    57D5 1E     c_parsename PHL
    57D6 19C257             JSR  c_bl
    57D9 185C6C             JMP  _c_parse
                e_parsename ;------------------------------------------------------------------
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_block.asm]
                
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_my4th.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for My4TH
                ;------------------------------------------------------------------------------
                
                ;#ifdef 
                ;            ; ,> ( "hexbytestream" -- )  Compile machine code to currently compiled word
                ;            DW   e_mgt
                ;            DB   2+FL_IMMEDIATE,",>"
                ;c_mgt       PHL
                ;            JSR  ld_ptr_inptr
                ;_c_mgt_1    LAP
                ;            TST
                ;            JPF  _c_mgt_2
                ;            CMP  #0x20
                ;            JPF  _c_mgt_2
                ;            JSR  inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            ROL
                ;            ROL
                ;            ROL
                ;            ROL
                ;            STA  R0
                ;            JSR  lap_inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            OR   R0
                ;            JSR  emit_code
                ;            JMP  _c_mgt_1
                ;_c_mgt_2    JSR  ld_inptr_ptr
                ;            RTS
                ;e_mgt       ;------------------------------------------------------------------
                ;#endif
                
                ;#ifdef WORDS_LEN_3
                ;            ; >SY  Convert index number to system call address
                ;            DW   e_2system
                ;            DB   3,">sy"
                ;c_2system   PHL
                ;            JSR  pop_data_R4
                ;            LDA  #<tab_syscalls
                ;            CLC
                ;            ROL  R4_L
                ;            ADD  R4_L
                ;            STA  PTR_L
                ;            LD   PTR_H,#>tab_syscalls
                ;            JSR  lap_inc_ptr
                ;            STA  R4_L
                ;            LAP
                ;            STA  R4_H
                ;            JMP  push_data_R4_ret
                ;e_2system   ;------------------------------------------------------------------
                ;#endif
                
                
                
                
                
                
                
                
                            ; SAVE-IMAGE  ( n -- )
                            ; Usage: To save a file to EEPROM block 5 and following blocks, enter:
                            ; 5 save-image
    57DC 8858               DW   e_saveimage
    57DE 0A7361             DB   10,"save-image"
    57E1 76652D 
    57E4 696D61 
    57E7 6765   
    57E9 1E     c_saveimage PHL
    57EA 199559             JSR  c_dup  ; make a copy of the block number
                            ;construct the program header
    57ED 010C00             LD   PTR_L,#<FORTH_START
    57F0 010D84             LD   PTR_H,#>FORTH_START
    57F3 0314               LDA  #FTH_HDR_FLAG
    57F5 19D93A             JSR  sap_inc_ptr
    57F8 0312               LDA  #0x12
    57FA 19D93A             JSR  sap_inc_ptr
    57FD 0300               LDA  #0   ; two bytes reserved
    57FF 19D93A             JSR  sap_inc_ptr 
    5802 19D93A             JSR  sap_inc_ptr
    5805 011452             LD   R4_L,#PRGHEADER
    5808 011580             LD   R4_H,#REGPAGE_HI
    580B 011604             LD   R5_L,#<(FORTH_START+4)
    580E 011784             LD   R5_H,#>(FORTH_START+4)
    5811 01182B             LD   R6_L,#PRGHDR_SIZE
    5814 19804E             JSR  memcpy_short
                            ;save all blocks
    5817 010C00             LD   PTR_L,#<FORTH_START
    581A 010D84             LD   PTR_H,#>FORTH_START
    581D 193D3B             JSR  psh_ptr
                _sav4th01   ;get block number from stack, but keep the original on stack
    5820 199559             JSR  c_dup
    5823 190E45             JSR  pop_data_R4
    5826 193038             JSR  fblockToEepromAddr
    5829 16264A             JPF  Error_Value
    582C 011A08             LD   R7_L,#8   ; 8 blocks of 128 bytes = 1024 bytes to write
                            ;R4 = 16-bit EEPROM address
    582F 198438 _sav4th02   JSR  eeprom_start_write_ackpoll
    5832 163F4A             JPF  Error_InOut  ; error
    5835 011280             LD   R2,#128
    5838 19563B             JSR  pop_ptr
    583B 19E438             JSR  eeprom_write_block
    583E 1B0F               PSH  FLAG
    5840 190039             JSR  eeprom_stop
    5843 1C0F               POP  FLAG
    5845 163F4A             JPF  Error_InOut  ; error
                            ;written enough?
    5848 040C               LDA  PTR_L
    584A 2564               SU   CP_L
    584C 040D               LDA  PTR_H
    584E 1165               SUB  CP_H
    5850 166E58             JPF  _sav4th04
    5853 193D3B             JSR  psh_ptr
                            ;write next 128-byte block
    5856 0380               LDA  #128
    5858 2414               AD   R4_L
    585A 0614               STA  R4_L
    585C 176158             JNF  _sav4th03
    585F 0915               INC  R4_H
    5861 0A1A   _sav4th03   DEC  R7_L
    5863 151A               TST  R7_L
    5865 172F58             JNF  _sav4th02
                            ;inc block number
    5868 190453             JSR  c_1plus
                            ;next block
    586B 182058             JMP  _sav4th01
                _sav4th04   ;print message "saved to block x-y"
    586E 19305D             JSR  c_swap
    5871 010C34             LD   PTR_L,#<text_savedto
    5874 010D79             LD   PTR_H,#>text_savedto
    5877 198158             JSR  _sav4th05
    587A 010C46             LD   PTR_L,#<text_to
    587D 010D79             LD   PTR_H,#>text_to
    5880 03                 DB   0x03  ;insert OP-code for "LDA #", so skip following PHL
    5881 1E     _sav4th05   PHL
    5882 194633             JSR  print_str
    5885 184D4E             JMP  print_integer_rts
                e_saveimage ;------------------------------------------------------------------
                
                
                            ; LOAD-IMAGE  ( n -- )
                            ; Usage: To load a file from EEPROM block 5 and following blocks, enter:
                            ; 5 load-image
    5888 5E59               DW   e_loadimage
    588A 0A6C6F             DB   10,"load-image"
    588D 61642D 
    5890 696D61 
    5893 6765   
    5895 0300   c_loadimage LDA  #0
    5897 1E     _ldforth10  PHL
    5898 1B0E               PSH
                            ;get block number from stack, but keep the original on stack
    589A 199559             JSR  c_dup
    589D 190E45             JSR  pop_data_R4
    58A0 193038             JSR  fblockToEepromAddr
    58A3 16264A             JPF  Error_Value
                            ;read first 24 bytes from EEPROM (the beginning of the program header)
    58A6 199A38             JSR  eeprom_start_read
    58A9 163F4A             JPF  Error_InOut
    58AC 011618             LD   R5_L,#24
    58AF 011700             LD   R5_H,#0
    58B2 010CE0             LD   PTR_L,#DRIVER_VARS
    58B5 010D80             LD   PTR_H,#>REGPAGE
    58B8 19AA38             JSR  eeprom_read_block
    58BB 190039             JSR  eeprom_stop
    58BE 04E0               LDA  DRIVER_VARS+0
    58C0 1314               CMP  #FTH_HDR_FLAG
    58C2 17F958             JNF  _c_loadferr
                            ;get the size of the FORTH program image in the EEPROM
    58C5 04F6               LDA  DRIVER_VARS+22
    58C7 010500             SU   #<FORTH_START
    58CA 2505   
    58CC 0618               STA  R6_L
    58CE 04F7               LDA  DRIVER_VARS+23
    58D0 010584             SUB  #>FORTH_START
    58D3 1105   
    58D5 0619               STA  R6_H
    58D7 010C00             LD   PTR_L,#<FORTH_START
    58DA 010D84             LD   PTR_H,#>FORTH_START
                            ;now load the whole program
    58DD 190159             JSR  loadForthBlocksToMemory
    58E0 1C0E               POP
    58E2 150E               TST
    58E4 17F358             JNF  _c_runimage  ;execute the program
    58E7 199E47             JSR  prepare_forth_program
    58EA 16F958             JPF  _c_loadferr
    58ED 197A49             JSR  printOkStatus
    58F0 185447             JMP  abort_restart
    58F3 199E47 _c_runimage JSR  prepare_forth_program
    58F6 17E347             JNF  do_run
                _c_loadferr PRINT text_error
    58F9 198633           JSR  printstrm
    58FC 4B               DB   <text_error
    58FD 79               DB   >text_error
    58FE 185147             JMP  forth_reinit
                
                loadForthBlocksToMemory:
                            ;R6 = remaining number of bytes to load,
                            ;PTR = destination memory pointer
                            ;block number on data stack
    5901 1E                 PHL
    5902 193D3B _ldforth01  JSR  psh_ptr
    5905 194C3B             JSR  psh_r6
    5908 199559             JSR  c_dup
    590B 190E45             JSR  pop_data_R4
    590E 193038             JSR  fblockToEepromAddr
    5911 16264A             JPF  Error_Value
    5914 199A38             JSR  eeprom_start_read
    5917 163F4A             JPF  Error_InOut
    591A 19653B             JSR  pop_r6
    591D 19563B             JSR  pop_ptr
                            ;calculate number of bytes to read, but read no more than 1024 bytes
    5920 0303               LDA  #3
    5922 2519               SU   R6_H
    5924 173059             JNF  _ldforth02
    5927 021618             LD   R5_L,R6_L
    592A 021719             LD   R5_H,R6_H
    592D 183659             JMP  _ldforth03
    5930 011600 _ldforth02  LD   R5_L,#0
    5933 011704             LD   R5_H,#4
    5936 0418   _ldforth03  LDA  R6_L
    5938 2516               SU   R5_L
    593A 0618               STA  R6_L
    593C 0419               LDA  R6_H
    593E 1117               SUB  R5_H
    5940 0619               STA  R6_H
                            ;now read the data (max 1 kB)
    5942 19AA38             JSR  eeprom_read_block
    5945 190039             JSR  eeprom_stop
                            ;print progress
    5948 0323               LDA  #'#'
    594A 192433             JSR  print_char
                            ;load next block
    594D 190453             JSR  c_1plus
    5950 1518               TST  R6_L
    5952 170259             JNF  _ldforth01
    5955 1519               TST  R6_H
    5957 170259             JNF  _ldforth01
                            ;program loaded
    595A 190E45             JSR  pop_data_R4  ; remove block number from data stack
    595D 1F                 RTS
                e_loadimage ;------------------------------------------------------------------
                
                
                
                
                
                
                            ; SX    get x-size (width) of the current display to the stack
    595E 6959               DW   e_sx
    5960 027378             DB   2,"sx"
    5963 1E     c_sx        PHL
    5964 0437               LDA  LIB_DISPMAXX
    5966 18D244             JMP  push_data_accu_ret
                e_sx        ;------------------------------------------------------------------
                
                            ; SY    get y-size (height) of the current display to the stack
    5969 7459               DW   e_sy
    596B 027379             DB   2,"sy"
    596E 1E     c_sy        PHL
    596F 0438               LDA  LIB_DISPMAXY
    5971 18D244             JMP  push_data_accu_ret
                e_sy        ;------------------------------------------------------------------
                
                            ; >=  ( n n -- flag )
    5974 8059               DW   e_greq
    5976 023E3D             DB   2,">="
    5979 1E     c_greq      PHL
    597A 195250             JSR  c_lessthan
    597D 18846F             JMP  _c_invert
                e_greq      ;------------------------------------------------------------------
                
                            ; <=  ( n n -- flag )
    5980 8C59               DW   e_leeq
    5982 023C3D             DB   2,"<="
    5985 1E     c_leeq      PHL
    5986 197150             JSR  c_grtrthan
    5989 18846F             JMP  _c_invert
                e_leeq      ;------------------------------------------------------------------
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_mynor.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for MyNOR
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_bload.asm]
                ;------------------------------------------------------------------------------
                ;  Binary Driver Loader
                ;------------------------------------------------------------------------------
                ;
                ;  This module can load and relocate a binary driver image into RAM memory.
                ;
                ;  The binary driver image must begin with this header:
                ;
                ;    1. byte :  ID 0x1B
                ;    2. byte :  reserved, must be 0
                ;    3. byte :  file size, bits 0-7
                ;    4. byte :  file size, bits 8-15
                ;    5. byte :  module compile address, bits 0-7
                ;    6. byte :  module compile address, bits 8-15
                ;    7. byte :  offset to the startup function, bits 0-7   (can be 0 if not used)
                ;    8. byte :  offset to the startup function, bits 8-15  (can be 0 if not used)
                ;    9. byte :  size of the following data section, bits 0-7
                ;   10. byte :  size of the following data section, bits 8-15
                ;
                ;  This module relocates all address it finds in the code section.
                ;  Data pointers must be written as a pair of " LD PTR_L,# / LD PTR_H,# ",
                ;  otherwise they won't be recognized.
                ;
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_edit.asm]
                
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words.asm]
    598C 000000   DB 0,0,0 ;end-marker
                
                dictionary_3:
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words_basis.asm]
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 2 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 3 characters
                ;------------------------------------------------------------------------------
                
                
                            ; dup ( x -- x x )
    598F 9F59               DW   e_dup
    5991 036475             DB   3,"dup"
    5994 70     
    5995 1E     c_dup       PHL
    5996 190E45             JSR  pop_data_R4
    5999 19DB44 _c_dup_1    JSR  push_data_R4
    599C 18D744             JMP  push_data_R4_ret
                e_dup       ;------------------------------------------------------------------
                
                            ; rot ( x1 x2 x3 -- x2 x3 x1 )
    599F B859               DW   e_rot
    59A1 03726F             DB   3,"rot"
    59A4 74     
    59A5 1E     c_rot       PHL
    59A6 190E45             JSR  pop_data_R4
    59A9 19423B             JSR  psh_r4
    59AC 193A45             JSR  pop_data_R4_R5
    59AF 19DB44             JSR  push_data_R4
    59B2 195B3B             JSR  pop_r4
    59B5 18F644             JMP  push_data_R4_R5_ret
                e_rot       ;------------------------------------------------------------------
                
                            ; 0<>  ( x -- flag )  0 if top of stack is 0, -1 otherwise
    59B8 CC59               DW   e_testn0
    59BA 03303C             DB   3,"0<>"
    59BD 3E     
    59BE 1E     c_testn0    PHL
    59BF 190E45             JSR  pop_data_R4
    59C2 1514               TST  R4_L
    59C4 178E50             JNF  ret_true
    59C7 1515               TST  R4_H
    59C9 18B552             JMP  _c_noteq_1
                e_testn0    ;------------------------------------------------------------------
                
                            ; mod  ( n1 n2 -- n3 )  Divide the two numbers at the top of the stack and return the reminder
    59CC DC59               DW   e_mod16
    59CE 036D6F             DB   3,"mod"
    59D1 64     
    59D2 1E     c_mod16     PHL
    59D3 195945             JSR  pop_data_R5_R4
    59D6 194C43             JSR  divide_u
    59D9 18F944             JMP  push_data_R5_ret
                e_mod16     ;------------------------------------------------------------------
                
                            ; um*  ( u1 u2 -- ud )  Multiply u1 by u2, giving the unsigned double-cell product ud.
    59DC EC59               DW   e_umstar
    59DE 03756D             DB   3,"um*"
    59E1 2A     
    59E2 1E     c_umstar    PHL
    59E3 193A45             JSR  pop_data_R4_R5
    59E6 199D42             JSR  multiply_u
    59E9 18F644             JMP  push_data_R4_R5_ret
                e_umstar    ;------------------------------------------------------------------
                
                            ; abs ( n -- u )  u is the absolute value of n
    59EC 005A               DW   e_abs
    59EE 036162             DB   3,"abs"
    59F1 73     
    59F2 1E     c_abs       PHL
    59F3 190E45             JSR  pop_data_R4
    59F6 0415               LDA  R4_H
    59F8 0B0E               ROL
    59FA 16716F             JPF  _c_negate_1
    59FD 18D744             JMP  push_data_R4_ret
                e_abs       ;------------------------------------------------------------------
                
                            ; and  ( x y -- z )  AND the two numbers at the top of the stack
    5A00 175A               DW   e_and16
    5A02 03616E             DB   3,"and"
    5A05 64     
    5A06 1E     c_and16     PHL
    5A07 193A45             JSR  pop_data_R4_R5
    5A0A 0414               LDA  R4_L
    5A0C 0D16               AND  R5_L
    5A0E 0614               STA  R4_L
    5A10 0415               LDA  R4_H
    5A12 0D17               AND  R5_H
    5A14 182B5A             JMP  _c_xor16_1
                e_and16     ;------------------------------------------------------------------
                
                            ; xor  ( x y -- z )  XOR the two numbers at the top of the stack
    5A17 305A               DW   e_xor16
    5A19 03786F             DB   3,"xor"
    5A1C 72     
    5A1D 1E     c_xor16     PHL
    5A1E 193A45             JSR  pop_data_R4_R5
    5A21 0414               LDA  R4_L
    5A23 0F16               XOR  R5_L
    5A25 0614               STA  R4_L
    5A27 0415               LDA  R4_H
    5A29 0F17               XOR  R5_H
    5A2B 0615   _c_xor16_1  STA  R4_H
    5A2D 18D744             JMP  push_data_R4_ret
                e_xor16     ;------------------------------------------------------------------
                
                            ; key  ( -- x )  Read key stroke as ASCII character
    5A30 4C5A               DW   e_key
    5A32 036B65             DB   3,"key"
    5A35 79     
    5A36 1E     c_key       PHL
    5A37 048C               LDA  NEXTINCHR
    5A39 018C00             LD   NEXTINCHR,#0
    5A3C 150E               TST
    5A3E 17D244             JNF  push_data_accu_ret
    5A41 19A734 _ckey01     JSR  call_vect_input
    5A44 150E               TST
    5A46 16415A             JPF  _ckey01
    5A49 18D244             JMP  push_data_accu_ret
                e_key       ;------------------------------------------------------------------
                
                            ; ?DO  ( end idx -- )  Start a definite loop
    5A4C 5B5A               DW   e_qmdo
    5A4E 833F64             DB   3+FL_IMMEDIATE,"?do"
    5A51 6F     
    5A52 011ADB c_qmdo      LD   R7_L,#<qmdo_code
    5A55 011B4E             LD   R7_H,#>qmdo_code
    5A58 189B54             JMP  _c_do_1      ; share the rest of the code with c_do
                e_qmdo      ;------------------------------------------------------------------
                
                            ; [']  Interpret next word and compile its code address (create a literal)
    5A5B 6E5A               DW   e_brtick
    5A5D 835B27             DB   3+FL_IMMEDIATE,"[']"
    5A60 5D     
    5A61 1E     c_brtick    PHL
    5A62 19224C             JSR  search_word_ex
    5A65 16074A             JPF  Error_Word ;word not found
    5A68 19AA49             JSR  ld_r4_ptr
    5A6B 18B04D             JMP  add_16bit_literal_ret
                e_brtick    ;------------------------------------------------------------------
                
                            ; min  ( n1 n2 -- n3 )
    5A6E 975A               DW   e_min
    5A70 036D69             DB   3,"min"
    5A73 6E     
    5A74 1E     c_min       PHL
    5A75 197E5A             JSR  _mmcompare
    5A78 16F944             JPF  push_data_R5_ret
    5A7B 18D744             JMP  push_data_R4_ret
    5A7E 1E     _mmcompare  PHL
    5A7F 193A45             JSR  pop_data_R4_R5
    5A82 0380               LDA  #0x80
    5A84 0F15               XOR  R4_H
    5A86 0619               STA  R6_H
    5A88 0380               LDA  #0x80
    5A8A 0F17               XOR  R5_H
    5A8C 061B               STA  R7_H
    5A8E 0414               LDA  R4_L
    5A90 2516               SU   R5_L
    5A92 0419               LDA  R6_H
    5A94 111B               SUB  R7_H
    5A96 1F                 RTS
                e_min       ;------------------------------------------------------------------
                
                            ; max  ( n1 n2 -- n3 )
    5A97 A75A               DW   e_max
    5A99 036D61             DB   3,"max"
    5A9C 78     
    5A9D 1E     c_max       PHL
    5A9E 197E5A             JSR  _mmcompare
    5AA1 17F944             JNF  push_data_R5_ret
    5AA4 18D744             JMP  push_data_R4_ret
                e_max       ;------------------------------------------------------------------
                
                            ; S>D  ( n -- d )  Convert the number n to the double-cell number d with the same numerical value.
    5AA7 B95A               DW   e_stod
    5AA9 03733E             DB   3,"s>d"
    5AAC 64     
    5AAD 1E     c_stod      PHL
    5AAE 190E45             JSR  pop_data_R4
    5AB1 19DB44             JSR  push_data_R4
    5AB4 0B15               ROL  R4_H
    5AB6 188B50             JMP  _c_equal_1
                e_stod      ;------------------------------------------------------------------
                
                            ; NIP  ( x1 x2 -- x2 )
    5AB9 C65A               DW   e_nip
    5ABB 036E69             DB   3,"nip"
    5ABE 70     
    5ABF 1E     c_nip       PHL
    5AC0 193A45             JSR  pop_data_R4_R5
    5AC3 18D744             JMP  push_data_R4_ret
                e_nip       ;------------------------------------------------------------------
                
                            ; 2>R  ( x1 x2 -- ) ( R:  -- x1 x2 )  Transfer cell pair x1 x2 to the return stack.
    5AC6 DD5A               DW   e_2tor
    5AC8 03323E             DB   3,"2>r"
    5ACB 72     
    5ACC 1E     c_2tor      PHL
    5ACD 195945 _c_2tor     JSR  pop_data_R5_R4
    5AD0 193144             JSR  retstk_push
    5AD3 021416             LD   R4_L,R5_L
    5AD6 021517             LD   R4_H,R5_H
    5AD9 193144             JSR  retstk_push
    5ADC 1F                 RTS
                e_2tor      ;------------------------------------------------------------------
                
                            ; 2R>  ( -- x1 x2 )  ( R:  x1 x2 -- )  Transfer cell pair x1 x2 from the return stack.
    5ADD F35A               DW   e_2rfrom
    5ADF 033272             DB   3,"2r>"
    5AE2 3E     
    5AE3 1E     c_2rfrom    PHL
    5AE4 194544             JSR  retstk_pop
    5AE7 021614             LD   R5_L,R4_L
    5AEA 021715             LD   R5_H,R4_H
    5AED 194544             JSR  retstk_pop
    5AF0 18F644             JMP  push_data_R4_R5_ret
                e_2rfrom    ;------------------------------------------------------------------
                
                            ; 2R@  ( -- x1 x2 )  ( R:  x1 x2 -- x1 x2 )  Copy cell pair x1 x2 from the return stack.
    5AF3 035B               DW   e_2rat
    5AF5 033272             DB   3,"2r@"
    5AF8 40     
    5AF9 1E     c_2rat      PHL
    5AFA 19E35A             JSR  c_2rfrom
    5AFD 19035D             JSR  c_2dup
    5B00 18CD5A             JMP  _c_2tor
                e_2rat      ;------------------------------------------------------------------
                
                            ; U.R  ( u n -- )  Display u right aligned in a field n characters wide.
    5B03 4D5B               DW   e_udotr
    5B05 03752E             DB   3,"u.r"
    5B08 72     
    5B09 1E     c_udotr     PHL
    5B0A 192445             JSR  pop_data_R5
    5B0D 011000             LD   R0,#0
    5B10 19C944 _c_udotri   JSR  push_data_zero
                            ;R5_L = aligned length
                            ;R0.7 = sign
    5B13 1B16               PSH  R5_L
    5B15 1B10   _c_udotrd   PSH  R0
    5B17 199D55             JSR  c_lns
    5B1A 19C255             JSR  c_nss
    5B1D 1C10               POP  R0
    5B1F 0B10               ROL  R0
    5B21 17295B             JNF  _c_udotr3
    5B24 032D               LDA  #'-'
    5B26 197551             JSR  _outnumchr
    5B29 03A0   _c_udotr3   LDA  #<(NUM_BUF+NUMBUF_SZ)
    5B2B 25A7               SU   NB_L
    5B2D 0610               STA  R0
    5B2F 1C0E               POP
    5B31 2510               SU   R0
    5B33 17475B             JNF  _c_udotr1
    5B36 0610               STA  R0
    5B38 0320               LDA  #0x20
    5B3A 1510   _c_udotr2   TST  R0
    5B3C 16475B             JPF  _c_udotr1
    5B3F 197551             JSR  _outnumchr
    5B42 0A10               DEC  R0
    5B44 183A5B             JMP  _c_udotr2
    5B47 19A955 _c_udotr1   JSR  c_nsg
    5B4A 18765D             JMP  _c_type_ret
                e_udotr     ;------------------------------------------------------------------
                
                            ; D.R  ( d n -- )  Display d right aligned in a field n characters wide.
    5B4D 715B               DW   e_ddotr
    5B4F 03642E             DB   3,"d.r"
    5B52 72     
    5B53 1E     c_ddotr     PHL
    5B54 190E45             JSR  pop_data_R4
    5B57 1B14               PSH  R4_L  ;aligned length on stack
    5B59 195945             JSR  pop_data_R5_R4
    5B5C 0417               LDA  R5_H ; get the sign
    5B5E 0610               STA  R0  
    5B60 0B0E               ROL
    5B62 17685B             JNF  _c_ddotr1
    5B65 198F40             JSR  negate_R45
    5B68 19DB44 _c_ddotr1   JSR  push_data_R4
    5B6B 19FD44             JSR  push_data_R5
                            ;stack = aligned length
                            ;R0.7 = sign
    5B6E 18155B             JMP  _c_udotrd   ;use 2nd half of U.R
                e_ddotr     ;------------------------------------------------------------------
                
                            ; HEX  ( -- ) 
    5B71 7E5B               DW   e_hex
    5B73 036865             DB   3,"hex"
    5B76 78     
    5B77 018910 c_hex       LD   BASE,#16
    5B7A 018A00 _c_hex1     LD   BASE+1,#0
    5B7D 1A                 RET
                e_hex       ;------------------------------------------------------------------
                
                            ; PAD  ( -- c-addr )  c-addr is the address of a transient region for temporary data
    5B7E 8D5B               DW   e_pad
    5B80 037061             DB   3,"pad"
    5B83 64     
    5B84 0114A0 c_pad       LD   R4_L,#<PAD_MEMORY
    5B87 0115FE             LD   R4_H,#>PAD_MEMORY
    5B8A 18DB44             JMP  push_data_R4
                e_pad       ;------------------------------------------------------------------
                
                            ; D0<  ( d -- flag )  flag is true if and only if d is less than zero.
    5B8D 9A5B               DW   e_d0less
    5B8F 036430             DB   3,"d0<"
    5B92 3C     
    5B93 1E     c_d0less    PHL
    5B94 193A45             JSR  pop_data_R4_R5
    5B97 18CA52             JMP  c_zeroless1
                e_d0less    ;------------------------------------------------------------------
                
                            ; D0=  ( d -- flag )  flag is true if and only if d is equal to zero.
    5B9A B15B               DW   e_d0equals
    5B9C 036430             DB   3,"d0="
    5B9F 3D     
    5BA0 1E     c_d0equals  PHL
    5BA1 193A45             JSR  pop_data_R4_R5
    5BA4 1516               TST  R5_L
    5BA6 17B852             JNF  ret_false
    5BA9 1517               TST  R5_H
    5BAB 17B852             JNF  ret_false
    5BAE 189752             JMP  _c_test01
                e_d0equals  ;------------------------------------------------------------------
                
                            ; DU<  ( ud1 ud2 -- flag )  flag is true if and only if ud1 is less than ud2.
    5BB1 C15B               DW   e_duless
    5BB3 036475             DB   3,"du<"
    5BB6 3C     
    5BB7 1E     c_duless    PHL
    5BB8 011000             LD   R0,#0
    5BBB 199B56             JSR  _c_sub32
    5BBE 18B552             JMP  _c_noteq_1
                e_duless    ;------------------------------------------------------------------
                
                            ; D2*  ( xd1 -- xd2 )  multiply xd1 with 2
    5BC1 D75B               DW   e_d2star
    5BC3 036432             DB   3,"d2*"
    5BC6 2A     
    5BC7 1E     c_d2star    PHL
    5BC8 195945             JSR  pop_data_R5_R4
    5BCB 23                 CLC
    5BCC 0B14               ROL  R4_L
    5BCE 0B15               ROL  R4_H
    5BD0 0B16               ROL  R5_L
    5BD2 0B17               ROL  R5_H
    5BD4 18F644             JMP  push_data_R4_R5_ret
                e_d2star    ;------------------------------------------------------------------
                
                            ; D2/  ( xd1 -- xd2 )  divide xd1 by 2
    5BD7 F05B               DW   e_d2slash
    5BD9 036432             DB   3,"d2/"
    5BDC 2F     
    5BDD 1E     c_d2slash   PHL
    5BDE 195945             JSR  pop_data_R5_R4
    5BE1 0417               LDA  R5_H
    5BE3 0B0E               ROL
    5BE5 0C17               ROR  R5_H
    5BE7 0C16               ROR  R5_L
    5BE9 0C15               ROR  R4_H
    5BEB 0C14               ROR  R4_L
    5BED 18F644             JMP  push_data_R4_R5_ret
                e_d2slash   ;------------------------------------------------------------------
                
                            ; M*/  ( d1 n1 n2 -- d2 )   d2 = (d1 * n1) / n2   Warning: the result of (d1 * n1) is only 32 bit!
    5BF0 2C5C               DW   e_mstsl
    5BF2 036D2A             DB   3,"m*/"
    5BF5 2F     
    5BF6 1E     c_mstsl     PHL
    5BF7 195945             JSR  pop_data_R5_R4
    5BFA 1B16               PSH  R5_L
    5BFC 1B17               PSH  R5_H
    5BFE 021814             LD   R6_L,R4_L
    5C01 021915             LD   R6_H,R4_H
    5C04 195945             JSR  pop_data_R5_R4
    5C07 1519               TST  R6_H
    5C09 17135C             JNF  _c_mstsl2
    5C0C 0418               LDA  R6_L
    5C0E 1301               CMP  #1
    5C10 16165C             JPF  _c_mstsl3
    5C13 192143 _c_mstsl2   JSR  mul32s
    5C16 1C19   _c_mstsl3   POP  R6_H
    5C18 1C18               POP  R6_L
    5C1A 1519               TST  R6_H
    5C1C 17265C             JNF  _c_mstsl1
    5C1F 0418               LDA  R6_L
    5C21 1301               CMP  #1
    5C23 16F644             JPF  push_data_R4_R5_ret
    5C26 190A42 _c_mstsl1   JSR  div_i32i16
    5C29 18F644             JMP  push_data_R4_R5_ret
                e_mstsl     ;------------------------------------------------------------------
                
                            ; D>S  ( d -- n )
    5C2C 355C               DW   e_dtos
    5C2E 03643E             DB   3,"d>s"
    5C31 73     
    5C32 180E45 c_dtos      JMP  pop_data_R4
                e_dtos      ;------------------------------------------------------------------
                
                            ; BLK  ( -- addr )
    5C35 415C               DW   e_blk
    5C37 03626C             DB   3,"blk"
    5C3A 6B     
    5C3B 01148D c_blk       LD   R4_L,#BLK
    5C3E 18AD6C             JMP  ret_regadr
                e_blk       ;------------------------------------------------------------------
                
                            ; SCR  ( -- addr )
    5C41 4D5C               DW   e_scr
    5C43 037363             DB   3,"scr"
    5C46 72     
    5C47 01148F c_scr       LD   R4_L,#SCR
    5C4A 18AD6C             JMP  ret_regadr
                e_scr       ;------------------------------------------------------------------
                
                            ; >IN  ( -- addr )
    5C4D 595C               DW   e_toin
    5C4F 033E69             DB   3,">in"
    5C52 6E     
    5C53 0114A1 c_toin      LD   R4_L,#INPTR
    5C56 18AD6C             JMP  ret_regadr
                e_toin      ;------------------------------------------------------------------
                
                            ; s\"  ( -- addr len )  Insert string and return address and length on stack
    5C59 D35C               DW   e_sbsquote
    5C5B 83735C             DB   3+FL_IMMEDIATE,'s',92,34
    5C5E 22     
    5C5F 1E     c_sbsquote  PHL
                            ;emit code that jumps over the string
    5C60 190754             JSR  scquote_cm1
                            ;copy the string into memory
    5C63 19695C             JSR  _sbsquote
                            ;emit code that pushes the string length to the stack
    5C66 18F953             JMP  scquote_cm3
                _sbsquote   ;parse and translate the input string, and emit it to the code section
    5C69 1E                 PHL
    5C6A 011600             LD   R5_L,#0
                            ;copy all characters, stop at ["]
    5C6D 19B849             JSR  ld_ptr_inptr
    5C70 195654 _csbsq01    JSR  lap_incptr_qchk
    5C73 1322               CMP  #0x22
    5C75 163A54             JPF  scquote_cm4
    5C78 135C               CMP  #92
    5C7A 17CB5C             JNF  _csbsq02
                            ;evaluate the escape sequence
    5C7D 195654             JSR  lap_incptr_qchk
    5C80 135C               CMP  #92
    5C82 16CB5C             JPF  _csbsq02
    5C85 1322               CMP  #0x22
    5C87 16CB5C             JPF  _csbsq02
    5C8A 193D3B             JSR  psh_ptr
    5C8D 01051F             AND  #0x1F
    5C90 0D05   
    5C92 0105E0             OR   #<tab_formatstr
    5C95 0E05   
    5C97 060C               STA  PTR_L
    5C99 010D7B             LD   PTR_H,#>tab_formatstr
    5C9C 05                 LAP
    5C9D 19563B             JSR  pop_ptr
    5CA0 136E               CMP  #'n'
    5CA2 17AE5C             JNF  _csbsq03
    5CA5 030D               LDA  #13
    5CA7 19134E             JSR  emit_code
    5CAA 0916               INC  R5_L
    5CAC 030A               LDA  #10
    5CAE 1378   _csbsq03    CMP  #'x'
    5CB0 17CB5C             JNF  _csbsq02
    5CB3 195654             JSR  lap_incptr_qchk
    5CB6 19AB3B             JSR  is_hexchar
    5CB9 0B0E               ROL
    5CBB 0B0E               ROL
    5CBD 0B0E               ROL
    5CBF 0B0E               ROL
    5CC1 0610               STA  R0
    5CC3 195654             JSR  lap_incptr_qchk
    5CC6 19AB3B             JSR  is_hexchar
    5CC9 0E10               OR   R0
                _csbsq02    ;output the character
    5CCB 19134E             JSR  emit_code
    5CCE 0916               INC  R5_L
    5CD0 18705C             JMP  _csbsq01
                e_sbsquote  ;------------------------------------------------------------------
                
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 4 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 5 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 6 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 7 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 8 characters
                ;------------------------------------------------------------------------------
                
                
                
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 11 characters
                ;------------------------------------------------------------------------------
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_block.asm]
                
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_my4th.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for My4TH
                ;------------------------------------------------------------------------------
                
                ;#ifdef WORDS_LEN_2
                ;            ; ,> ( "hexbytestream" -- )  Compile machine code to currently compiled word
                ;            DW   e_mgt
                ;            DB   2+FL_IMMEDIATE,",>"
                ;c_mgt       PHL
                ;            JSR  ld_ptr_inptr
                ;_c_mgt_1    LAP
                ;            TST
                ;            JPF  _c_mgt_2
                ;            CMP  #0x20
                ;            JPF  _c_mgt_2
                ;            JSR  inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            ROL
                ;            ROL
                ;            ROL
                ;            ROL
                ;            STA  R0
                ;            JSR  lap_inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            OR   R0
                ;            JSR  emit_code
                ;            JMP  _c_mgt_1
                ;_c_mgt_2    JSR  ld_inptr_ptr
                ;            RTS
                ;e_mgt       ;------------------------------------------------------------------
                ;#endif
                
                ;#ifdef 
                ;            ; >SY  Convert index number to system call address
                ;            DW   e_2system
                ;            DB   3,">sy"
                ;c_2system   PHL
                ;            JSR  pop_data_R4
                ;            LDA  #<tab_syscalls
                ;            CLC
                ;            ROL  R4_L
                ;            ADD  R4_L
                ;            STA  PTR_L
                ;            LD   PTR_H,#>tab_syscalls
                ;            JSR  lap_inc_ptr
                ;            STA  R4_L
                ;            LAP
                ;            STA  R4_H
                ;            JMP  push_data_R4_ret
                ;e_2system   ;------------------------------------------------------------------
                ;#endif
                
                
                
                
                
                
                
                
                
                
                
                            ; LCD  ( -- )
    5CD3 E15C               DW   e_lcd 
    5CD5 036C63             DB   3,"lcd"
    5CD8 64     
    5CD9 153A   c_lcd       TST  LIB_LCDOUT
    5CDB 17CD3A             JNF  ret_opc
    5CDE 18B275             JMP  init_console
                e_lcd       ;------------------------------------------------------------------
                
                
                
                
                
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_mynor.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for MyNOR
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_bload.asm]
                ;------------------------------------------------------------------------------
                ;  Binary Driver Loader
                ;------------------------------------------------------------------------------
                ;
                ;  This module can load and relocate a binary driver image into RAM memory.
                ;
                ;  The binary driver image must begin with this header:
                ;
                ;    1. byte :  ID 0x1B
                ;    2. byte :  reserved, must be 0
                ;    3. byte :  file size, bits 0-7
                ;    4. byte :  file size, bits 8-15
                ;    5. byte :  module compile address, bits 0-7
                ;    6. byte :  module compile address, bits 8-15
                ;    7. byte :  offset to the startup function, bits 0-7   (can be 0 if not used)
                ;    8. byte :  offset to the startup function, bits 8-15  (can be 0 if not used)
                ;    9. byte :  size of the following data section, bits 0-7
                ;   10. byte :  size of the following data section, bits 8-15
                ;
                ;  This module relocates all address it finds in the code section.
                ;  Data pointers must be written as a pair of " LD PTR_L,# / LD PTR_H,# ",
                ;  otherwise they won't be recognized.
                ;
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_edit.asm]
                
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words.asm]
    5CE1 000000   DB 0,0,0 ;end-marker
                
                dictionary_4:
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words_basis.asm]
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 2 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 3 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 4 characters
                ;------------------------------------------------------------------------------
                
                
                            ; ?dup ( x -- 0 | x x )
    5CE4 FC5C               DW   e_qmdup
    5CE6 043F64             DB   4,"?dup"
    5CE9 7570   
    5CEB 1E     c_qmdup     PHL
    5CEC 190E45             JSR  pop_data_R4
    5CEF 1514               TST  R4_L
    5CF1 179959             JNF  _c_dup_1
    5CF4 1515               TST  R4_H
    5CF6 179959             JNF  _c_dup_1
    5CF9 18D744             JMP  push_data_R4_ret
                e_qmdup     ;------------------------------------------------------------------
                
                            ; 2dup ( x1 x2 -- x1 x2 x1 x2 )
    5CFC 105D               DW   e_2dup
    5CFE 043264             DB   4,"2dup"
    5D01 7570   
    5D03 1E     c_2dup      PHL
    5D04 195945             JSR  pop_data_R5_R4
    5D07 19DB44             JSR  push_data_R4
    5D0A 19FD44             JSR  push_data_R5
    5D0D 18F644             JMP  push_data_R4_R5_ret
                e_2dup      ;------------------------------------------------------------------
                
                            ; over ( x1 x2 -- x1 x2 x1 )
    5D10 295D               DW   e_over
    5D12 046F76             DB   4,"over"
    5D15 6572   
    5D17 1E     c_over      PHL
    5D18 020C95             LD   PTR_L,fPSP
    5D1B 010D81             LD   PTR_H,#>DATA_STACK
    5D1E 0A0C               DEC  PTR_L
    5D20 0A0C               DEC  PTR_L
    5D22 0A0C               DEC  PTR_L
    5D24 0A0C               DEC  PTR_L
    5D26 182F50             JMP  c_at_ldret
                e_over      ;------------------------------------------------------------------
                
                            ; swap ( x1 x2 -- x2 x1 )
    5D29 375D               DW   e_swap
    5D2B 047377             DB   4,"swap"
    5D2E 6170   
    5D30 1E     c_swap      PHL
    5D31 193A45 _c_swap     JSR  pop_data_R4_R5
    5D34 18F644             JMP  push_data_R4_R5_ret
                e_swap      ;------------------------------------------------------------------
                
                            ; drop ( x -- )
    5D37 415D               DW   e_drop
    5D39 046472             DB   4,"drop"
    5D3C 6F70   
    5D3E 180E45 c_drop      JMP  pop_data_R4
                e_drop      ;------------------------------------------------------------------
                
                            ; /mod  ( n1 n2 -- n3 n4 )  Divide the two numbers at the top of the stack with reminder
    5D41 555D               DW   e_dmod16
    5D43 042F6D             DB   4,"/mod"
    5D46 6F64   
    5D48 1E     c_dmod16    PHL
    5D49 195945             JSR  pop_data_R5_R4
    5D4C 194C43             JSR  divide_u
    5D4F 19FD44             JSR  push_data_R5
    5D52 18D744             JMP  push_data_R4_ret
                e_dmod16    ;------------------------------------------------------------------
                
                            ; exit  ( r:addr -- )  Pop return stack and resume execution at addr
    5D55 5D5D               DW   e_exit
    5D57 046578             DB   4,"exit"
    5D5A 6974   
    5D5C 1F     c_exit      RTS
                e_exit      ;------------------------------------------------------------------
                
                            ; emit  ( x -- )  Print low byte of x as an ASCII character
    5D5D 6E5D               DW   e_emit
    5D5F 04656D             DB   4,"emit"
    5D62 6974   
    5D64 1E     c_emit      PHL
    5D65 190E45             JSR  pop_data_R4
    5D68 0414               LDA  R4_L
    5D6A 192433             JSR  print_char
    5D6D 1F                 RTS
                e_emit      ;------------------------------------------------------------------
                
                            ; type  ( addr u -- )  display the character string specified by addr and u.
    5D6E 945D               DW   e_type
    5D70 047479             DB   4,"type"
    5D73 7065   
    5D75 1E     c_type      PHL
    5D76 195945 _c_type_ret JSR  pop_data_R5_R4
    5D79 19213B             JSR  ld_ptr_r4
    5D7C 18895D             JMP  _ctype3
    5D7F 0A17   _ctype2     DEC  R5_H
    5D81 0A16   _ctype1     DEC  R5_L
    5D83 19CE3A             JSR  lap_inc_ptr
    5D86 192433             JSR  print_char
    5D89 1516   _ctype3     TST  R5_L
    5D8B 17815D             JNF  _ctype1
    5D8E 1517               TST  R5_H
    5D90 177F5D             JNF  _ctype2
    5D93 1F                 RTS 
                e_type      ;------------------------------------------------------------------
                
                            ; ELSE  ( -- )  Mid of an IF-ELSE-THEN construct
    5D94 B65D               DW   e_else
    5D96 84656C             DB   4+FL_IMMEDIATE,"else"
    5D99 7365   
    5D9B 1E     c_else      PHL
    5D9C 0318               LDA  #0x18
    5D9E 19134E             JSR  emit_code
    5DA1 197344             JSR  ccfs_pop
    5DA4 19423B             JSR  psh_r4
    5DA7 195944             JSR  ccfs_push_cp
    5DAA 19224E             JSR  inc_cp
    5DAD 19224E             JSR  inc_cp
    5DB0 19563B _c_else1    JSR  pop_ptr
    5DB3 188573             JMP  _c_endcase2
                e_else      ;------------------------------------------------------------------
                
                            ; THEN  ( -- )  End an IF-ELSE-THEN construct
    5DB6 C45D               DW   e_then
    5DB8 847468             DB   4+FL_IMMEDIATE,"then"
    5DBB 656E   
    5DBD 1E     c_then      PHL
    5DBE 197344             JSR  ccfs_pop
    5DC1 188273             JMP  _c_endcase1
                e_then      ;------------------------------------------------------------------
                
                            ; LOOP
    5DC4 F95D               DW   e_loop
    5DC6 846C6F             DB   4+FL_IMMEDIATE,"loop"
    5DC9 6F70   
                c_loop      ;insert code that calls the loop_code routine
    5DCB 011A17             LD   R7_L,#<loop_code
    5DCE 011B4F             LD   R7_H,#>loop_code
    5DD1 1E     _c_loop_1   PHL
    5DD2 193B4D             JSR  emit_jsr
                            ;insert an conditional jump to the DO word, part 1
    5DD5 0317               LDA  #0x17
    5DD7 19134E             JSR  emit_code
                            ;get the pointer to DO from cfs stack
    5DDA 19A244             JSR  lcfs_pop
    5DDD 19213B             JSR  ld_ptr_r4
                            ;patch the DO code, insert a pointer to behind this LOOP word (used for leaving the loop early)
    5DE0 021664             LD   R5_L,CP_L
    5DE3 021765             LD   R5_H,CP_H
    5DE6 19033B             JSR  inc_r5
    5DE9 19033B             JSR  inc_r5
    5DEC 0416               LDA  R5_L
    5DEE 19D93A             JSR  sap_inc_ptr
    5DF1 0417               LDA  R5_H
    5DF3 19D93A             JSR  sap_inc_ptr
                            ;insert an conditional jump to the DO word, part 2
    5DF6 18314D             JMP  emit_PTR_ret
                e_loop      ;------------------------------------------------------------------
                
                            ; TRUE  ( -- true )
    5DF9 035E               DW   e_true
    5DFB 047472             DB   4,"true"
    5DFE 7565   
    5E00 18C044 c_true      JMP  push_data_ffff
                e_true      ;------------------------------------------------------------------
                
                            ; TUCK  ( x1 x2 -- x2 x1 x2 )
    5E03 145E               DW   e_tuck
    5E05 047475             DB   4,"tuck"
    5E08 636B   
    5E0A 1E     c_tuck      PHL
    5E0B 195945             JSR  pop_data_R5_R4
    5E0E 19FD44             JSR  push_data_R5
    5E11 18F644             JMP  push_data_R4_R5_ret
                e_tuck      ;------------------------------------------------------------------
                
                            ; CASE
    5E14 375E               DW   e_case
    5E16 846361             DB   4+FL_IMMEDIATE,"case"
    5E19 7365   
    5E1B 1E     c_case      PHL
    5E1C 0306               LDA  #6
    5E1E 2464               AD   CP_L
    5E20 061A               STA  R7_L
    5E22 021B65             LD   R7_H,CP_H
    5E25 172A5E             JNF  _c_case01
    5E28 091B               INC  R7_H
    5E2A 0318   _c_case01   LDA  #0x18
    5E2C 193D4D             JSR  emit_opaadr  ; insert a JMP that jumps over the next jump
    5E2F 195944             JSR  ccfs_push_cp ; store current code address on control flow stack
    5E32 0318               LDA  #0x18  ; insert a JMP that jumps behind the ENDCASE word
    5E34 183E4D             JMP  emit_opaadr_ret
                e_case      ;------------------------------------------------------------------
                
                            ; SIGN  ( n -- )
    5E37 4C5E               DW   e_sign
    5E39 047369             DB   4,"sign"
    5E3C 676E   
    5E3E 1E     c_sign      PHL
    5E3F 190E45             JSR  pop_data_R4
    5E42 0B15               ROL  R4_H
    5E44 17CA3A             JNF  return
    5E47 032D               LDA  #'-'
    5E49 187151             JMP  _c_ns_1
                e_sign      ;------------------------------------------------------------------
                
                            ; HOLD  ( n -- )
    5E4C 5C5E               DW   e_hold
    5E4E 04686F             DB   4,"hold"
    5E51 6C64   
    5E53 1E     c_hold      PHL
    5E54 190E45             JSR  pop_data_R4
    5E57 0414               LDA  R4_L
    5E59 187151             JMP  _c_ns_1
                e_hold      ;------------------------------------------------------------------
                
                            ; CHAR  ( -- char )  Place char, the value of the first character of name, on the stack.
    5E5C 815E               DW   e_char
    5E5E 046368             DB   4,"char"
    5E61 6172   
    5E63 1E     c_char      PHL
    5E64 199249             JSR  skipSpaces
    5E67 150E               TST
    5E69 16234A             JPF  Error_Syntax
    5E6C 0614               STA  R4_L
    5E6E 19E43A _cchar02    JSR  inc_ptr_lap
    5E71 150E               TST
    5E73 167B5E             JPF  _cchar01
    5E76 1320               CMP  #0x20
    5E78 176E5E             JNF  _cchar02
    5E7B 19B149 _cchar01    JSR  ld_inptr_ptr
    5E7E 18D444             JMP  push_data_R4L_ret
                e_char      ;------------------------------------------------------------------
                
                            ; DABS ( d -- ud )  ud is the absolute value of d
    5E81 9C5E               DW   e_dabs
    5E83 046461             DB   4,"dabs"
    5E86 6273   
    5E88 1E     c_dabs      PHL
    5E89 192445             JSR  pop_data_R5
    5E8C 0417               LDA  R5_H
    5E8E 0B0E               ROL
    5E90 17F944             JNF  push_data_R5_ret
    5E93 190E45 _c_dabs1    JSR  pop_data_R4
    5E96 198F40             JSR  negate_R45
    5E99 18F644             JMP  push_data_R4_R5_ret
                e_dabs      ;------------------------------------------------------------------
                
                            ; 2ROT ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
    5E9C A65E               DW   e_2rot
    5E9E 043272             DB   4,"2rot"
    5EA1 6F74   
    5EA3 187845 c_2rot      JMP  dstack_2rot
                e_2rot      ;------------------------------------------------------------------
                
                            ; FILL  ( c-addr u char -- )
    5EA6 D05E               DW   e_fill
    5EA8 046669             DB   4,"fill"
    5EAB 6C6C   
    5EAD 1E     c_fill      PHL
    5EAE 190E45             JSR  pop_data_R4
    5EB1 1B14               PSH  R4_L            ;char
    5EB3 195945             JSR  pop_data_R5_R4  ;count, addr
    5EB6 1C0E               POP
    5EB8 19213B _c_fill_4   JSR  ld_ptr_r4
    5EBB 18C55E             JMP  _c_fill_3
    5EBE 0A17   _c_fill_2   DEC  R5_H
    5EC0 0A16   _c_fill_1   DEC  R5_L
    5EC2 19D93A             JSR  sap_inc_ptr
    5EC5 1516   _c_fill_3   TST  R5_L
    5EC7 17C05E             JNF  _c_fill_1
    5ECA 1517               TST  R5_H
    5ECC 17BE5E             JNF  _c_fill_2
    5ECF 1F                 RTS
                e_fill      ;------------------------------------------------------------------
                
                            ; MOVE  ( addr1 addr2 u -- )
    5ED0 E85E               DW   e_move
    5ED2 046D6F             DB   4,"move"
    5ED5 7665   
    5ED7 1E     c_move      PHL
    5ED8 190E45             JSR  pop_data_R4
    5EDB 021814             LD   R6_L,R4_L
    5EDE 021915             LD   R6_H,R4_H
    5EE1 195945             JSR  pop_data_R5_R4
    5EE4 19834E             JSR  memcpy
    5EE7 1F                 RTS
                e_move      ;------------------------------------------------------------------
                
                            ; WORD ( char "<chars>ccc<char>" -- c-addr ) 
    5EE8 305F               DW   e_word
    5EEA 04776F             DB   4,"word"
    5EED 7264   
    5EEF 1E     c_word      PHL
    5EF0 192445             JSR  pop_data_R5
    5EF3 011000             LD   R0,#0
    5EF6 011471             LD   R4_L,#<(WORD_BUF+1)
    5EF9 0115FE             LD   R4_H,#>(WORD_BUF+1)
    5EFC 19B849 _cword2     JSR  ld_ptr_inptr
    5EFF 19CE3A             JSR  lap_inc_ptr
    5F02 150E               TST
    5F04 161B5F             JPF  _cword3
    5F07 19B149             JSR  ld_inptr_ptr
    5F0A 1416               CMP  R5_L
    5F0C 161B5F             JPF  _cword3
    5F0F 19213B             JSR  ld_ptr_r4
    5F12 07                 SAP
    5F13 19F93A             JSR  inc_r4
    5F16 0910               INC  R0
    5F18 18FC5E             JMP  _cword2
    5F1B 19213B _cword3     JSR  ld_ptr_r4
    5F1E 0320               LDA  #0x20
    5F20 07                 SAP
    5F21 011470             LD   R4_L,#<WORD_BUF
    5F24 0115FE             LD   R4_H,#>WORD_BUF
    5F27 19213B             JSR  ld_ptr_r4
    5F2A 0410               LDA  R0
    5F2C 07                 SAP
    5F2D 18D744             JMP  push_data_R4_ret
                e_word      ;------------------------------------------------------------------
                
                            ; PICK  ( xu ... x1 x0 u -- xu ... x1 x0 xu )
    5F30 555F               DW   e_pick
    5F32 047069             DB   4,"pick"
    5F35 636B   
    5F37 1E     c_pick      PHL
    5F38 192445             JSR  pop_data_R5
    5F3B 19415F             JSR  _c_pick1
    5F3E 18D744             JMP  push_data_R4_ret  
    5F41 23     _c_pick1    CLC
    5F42 0B16               ROL  R5_L
    5F44 0495               LDA  fPSP
    5F46 2516               SU   R5_L
    5F48 02A307             LD   RSP,SP
    5F4B 0607               STA  SP
    5F4D 1C15               POP  R4_H
    5F4F 1C14               POP  R4_L
    5F51 0207A3             LD   SP,RSP
    5F54 1A                 RET
                e_pick      ;------------------------------------------------------------------
                
                            ; ROLL  ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
    5F55 8D5F               DW   e_roll
    5F57 04726F             DB   4,"roll"
    5F5A 6C6C   
    5F5C 1E     c_roll      PHL
    5F5D 192445             JSR  pop_data_R5
    5F60 19415F             JSR  _c_pick1
    5F63 1516               TST  R5_L ; number of bytes to copy
    5F65 16CA3A             JPF  return
    5F68 0611               STA  R1   ; ptr to source
    5F6A 0A0E               DEC
    5F6C 0A0E               DEC
    5F6E 0612               STA  R2   ; ptr to destination
    5F70 010D81             LD   PTR_H,#>STACK
    5F73 020C11 _c_roll2    LD   PTR_L,R1
    5F76 05                 LAP
    5F77 020C12             LD   PTR_L,R2
    5F7A 07                 SAP
    5F7B 0911               INC  R1
    5F7D 0912               INC  R2
    5F7F 0A16               DEC  R5_L
    5F81 1516   _c_roll1    TST  R5_L
    5F83 17735F             JNF  _c_roll2
    5F86 0A95               DEC  fPSP
    5F88 0A95               DEC  fPSP
    5F8A 18D744             JMP  push_data_R4_ret
                e_roll      ;------------------------------------------------------------------
                
                            ; QUIT
    5F8D 9A5F               DW   e_quit
    5F8F 047175             DB   4,"quit"
    5F92 6974   
    5F94 192233 c_quit      JSR  print_nl
    5F97 185447             JMP  abort_restart
                e_quit      ;------------------------------------------------------------------
                
                            ; KEY?  ( -- flag )  If a character is available, return true.  Otherwise, return false.
    5F9A B45F               DW   e_keyqm
    5F9C 046B65             DB   4,"key?"
    5F9F 793F   
    5FA1 1E     c_keyqm     PHL
    5FA2 158C               TST  NEXTINCHR
    5FA4 178E50             JNF  ret_true
    5FA7 19A734             JSR  call_vect_input
    5FAA 068C               STA  NEXTINCHR
    5FAC 150E               TST
    5FAE 16B852             JPF  ret_false
    5FB1 188E50             JMP  ret_true
                e_keyqm     ;------------------------------------------------------------------
                
                            ; BASE
    5FB4 C15F               DW   e_base
    5FB6 046261             DB   4,"base"
    5FB9 7365   
    5FBB 011489 c_base      LD   R4_L,#<BASE
    5FBE 18AD6C             JMP  ret_regadr
                e_base      ;------------------------------------------------------------------
                
                            ; HERE
    5FC1 CF5F               DW   e_here
    5FC3 046865             DB   4,"here"
    5FC6 7265   
    5FC8 1E     c_here      PHL
    5FC9 193E4E             JSR  ld_r4_cp
    5FCC 18D744             JMP  push_data_R4_ret
                e_here      ;------------------------------------------------------------------
                
                            ; PAGE ( -- )
    5FCF D95F               DW   e_page
    5FD1 047061             DB   4,"page"
    5FD4 6765   
    5FD6 189732 c_page      JMP  display_clear
                e_page      ;------------------------------------------------------------------
                
                            ; LOAD ( n -- )  Load and interpret a "screen" from EEPROM (n = screen number)
    5FD9 3E60               DW   e_load
    5FDB 046C6F             DB   4,"load"
    5FDE 6164   
    5FE0 1E     c_load      PHL
                            ;write yet unsaved blocks to EEPROM
    5FE1 193462             JSR  c_savebuffers
                            ;push current context (BLK, LINE and INPTR) to the system stack
    5FE4 010C8D             LD   PTR_L,#BLK_L
    5FE7 19CB49             JSR  push_zpvar
    5FEA 010CA9             LD   PTR_L,#FILE_LNBR
    5FED 19CB49             JSR  push_zpvar
    5FF0 19C849             JSR  push_inptr
                            ;get block number
    5FF3 190E45             JSR  pop_data_R4
    5FF6 01A900 _ldscr06    LD   FILE_LNBR,#0  ; line number 0 - 15
                _ldscr01    ;loop over all lines in the screen
    5FF9 19423B             JSR  psh_r4
    5FFC 028D14             LD   BLK_L,R4_L
    5FFF 028E15             LD   BLK_H,R4_H
    6002 19FC4F             JSR  test_blk
    6005 16264A             JPF  Error_Value
    6008 190848             JSR  load_line_into_filebuf
    600B 198048             JSR  interpret_filebuf_line
    600E 195B3B             JSR  pop_r4
    6011 1592               TST  REFILL
    6013 161F60             JPF  _ldscr07
                            ; refill flagged, continue at line 0 in next block
    6016 019200             LD   REFILL,#0
    6019 19F93A             JSR  inc_r4
    601C 18F65F             JMP  _ldscr06
                _ldscr07    ;next line
    601F 09A9               INC  FILE_LNBR
    6021 0310               LDA  #16
    6023 14A9               CMP  FILE_LNBR
    6025 17F95F             JNF  _ldscr01
                            ;restore the context, get INPTR, LINE and BLK back from stack
    6028 19DE49             JSR  pop_inptr
    602B 010CA9             LD   PTR_L,#FILE_LNBR
    602E 19E149             JSR  pop_zpvar
    6031 010C8D             LD   PTR_L,#BLK_L
    6034 19E149             JSR  pop_zpvar
                            ;check last context, refill file buffer with old line if required
    6037 19FC4F             JSR  test_blk
    603A 170948             JNF  load_line_into_filebuf_rts
    603D 1F                 RTS
                e_load      ;------------------------------------------------------------------
                
                            ; THRU ( u1 u2 -- )  LOAD the mass storage blocks numbered u1 through u2 in sequence.
    603E 6F60               DW   e_thru
    6040 047468             DB   4,"thru"
    6043 7275   
    6045 1E     c_thru      PHL
    6046 193A45             JSR  pop_data_R4_R5
    6049 19423B _thru01     JSR  psh_r4
    604C 19473B             JSR  psh_r5
    604F 19FD44             JSR  push_data_R5
    6052 19E05F             JSR  c_load
    6055 19603B             JSR  pop_r5
    6058 195B3B             JSR  pop_r4
    605B 0416               LDA  R5_L
    605D 1414               CMP  R4_L
    605F 176960             JNF  _thru02
    6062 0417               LDA  R5_H
    6064 1415               CMP  R4_H
    6066 16CA3A             JPF  rts_opc
    6069 19033B _thru02     JSR  inc_r5
    606C 184960             JMP  _thru01
                e_thru      ;------------------------------------------------------------------
                
                            ; LIST ( n -- )  Display block n in an implementation-defined format. (n = screen number 1 - 63)
    606F CC60               DW   e_list
    6071 046C69             DB   4,"list"
    6074 7374   
    6076 153A   c_list      TST  LIB_LCDOUT
    6078 17F762             JNF  c_edit
    607B 1E                 PHL
    607C 192233             JSR  print_nl
                            ;write yet unsaved blocks to EEPROM
    607F 193462             JSR  c_savebuffers
                            ;prepare loading the block
    6082 19AC4F             JSR  prep_eepblk
    6085 028F16             LD   SCR_L,R5_L
    6088 029017             LD   SCR_H,R5_H
    608B 19C64F             JSR  feep_start_read
                            ;ACCU = line counter (read 16 lines from EEPROM)
    608E 0301               LDA  #1
    6090 1B0E   _ldscr05    PSH
    6092 19B633             JSR  print_hexbyte
    6095 037C               LDA  #'|'
    6097 192433             JSR  print_char
    609A 191833             JSR  print_space
                            ;load 64 characters from EEPROM and print
    609D 011240             LD   R2,#64
    60A0 011100             LD   R1,#0
    60A3 192E2E _ldscr03    JSR  i2c_recv
    60A6 192433             JSR  print_char
    60A9 0A12               DEC  R2
    60AB 1512               TST  R2
    60AD 17A360             JNF  _ldscr03
                            ;next line
    60B0 192233             JSR  print_nl
    60B3 1C0E               POP
    60B5 090E               INC
    60B7 130A               CMP  #0x0A
    60B9 17BE60             JNF  _ldscr04
    60BC 0310               LDA  #0x10
    60BE 1317   _ldscr04    CMP  #0x17
    60C0 179060             JNF  _ldscr05
    60C3 011101             LD   R1,#1
    60C6 192E2E             JSR  i2c_recv
    60C9 180339             JMP  eeprom_stop_ret
                e_list      ;------------------------------------------------------------------
                
                            ;-ROT ( x1 x2 x3 -- x3 x1 x2 )
    60CC E960               DW   e_mrot
    60CE 042D72             DB   4,"-rot"
    60D1 6F74   
    60D3 1E     c_mrot      PHL
    60D4 193A45             JSR  pop_data_R4_R5  ;x3,x2
    60D7 19473B             JSR  psh_r5 ;x2
    60DA 192445             JSR  pop_data_R5  ;x1
    60DD 19DB44             JSR  push_data_R4 ;x3
    60E0 19FD44             JSR  push_data_R5 ;x1
    60E3 19603B             JSR  pop_r5 ;x2
    60E6 18F944             JMP  push_data_R5_ret
                e_mrot      ;------------------------------------------------------------------
                
                            ;CELL ( -- u )  Return the size of one cell
    60E9 F660               DW   e_cell
    60EB 046365             DB   4,"cell"
    60EE 6C6C   
    60F0 1E     c_cell      PHL
    60F1 0302               LDA  #2
    60F3 18D244             JMP  push_data_accu_ret
                e_cell      ;------------------------------------------------------------------
                
                            ;DUMP (addr u -- )  Dump memory to screen
    60F6 4161               DW   e_dump
    60F8 046475             DB   4,"dump"
    60FB 6D70   
    60FD 1E     c_dump      PHL
    60FE 19305D             JSR  c_swap
    6101 193A45             JSR  pop_data_R4_R5
                            ;r5 = u, r4 = addr
    6104 011010 _cdump04    LD   R0,#16
    6107 1516   _cdump01    TST  R5_L
    6109 171361             JNF  _cdump02
    610C 1517               TST  R5_H
    610E 163D61             JPF  printnl_rts
    6111 0A17               DEC  R5_H
    6113 0A16   _cdump02    DEC  R5_L
    6115 0410               LDA  R0
    6117 1310               CMP  #16
    6119 172A61             JNF  _cdump05
    611C 192233             JSR  print_nl
    611F 19D333             JSR  print_hexword
    6122 033A               LDA  #':'
    6124 192433             JSR  print_char
    6127 191833             JSR  print_space
    612A 19213B _cdump05    JSR  ld_ptr_r4
    612D 19F93A             JSR  inc_r4
    6130 05                 LAP
    6131 19B633             JSR  print_hexbyte
    6134 191833             JSR  print_space
    6137 200761             JLP  _cdump01
    613A 180461             JMP  _cdump04
    613D 192233 printnl_rts JSR  print_nl            
    6140 1F                 RTS
                e_dump      ;------------------------------------------------------------------
                
                            ;FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )   Find the definition named in the counted string at c-addr. 
    6141 7E61               DW   e_find
    6143 046669             DB   4,"find"
    6146 6E64   
    6148 1E     c_find      PHL
    6149 19C849             JSR  push_inptr
    614C 190E45             JSR  pop_data_R4
    614F 19DB44             JSR  push_data_R4
    6152 19213B             JSR  ld_ptr_r4
    6155 19CE3A             JSR  lap_inc_ptr
    6158 19B149             JSR  ld_inptr_ptr
    615B 0611               STA  R1
    615D 19314C             JSR  search_word
    6160 176961             JNF  _c_find01
                            ;word not found
    6163 19DE49             JSR  pop_inptr
    6166 18B852             JMP  ret_false   ; word not found, return "c-addr 0"
                _c_find01   ;word found, PTR points to code section and R2 contains flags
    6169 19AA49             JSR  ld_r4_ptr
    616C 192445             JSR  pop_data_R5
    616F 19DB44             JSR  push_data_R4
    6172 19DE49             JSR  pop_inptr
    6175 0B12               ROL  R2
    6177 178E50             JNF  ret_true     ; not an immediate word, return "xt -1"
    617A 19EC44             JSR  push_data_1  ; immediate word, return "xt 1"
    617D 1F                 RTS
                e_find      ;------------------------------------------------------------------
                
                            ; dmin  ( d1 d2 -- d3 )
    617E A561               DW   e_dmin
    6180 04646D             DB   4,"dmin"
    6183 696E   
    6185 011100 c_dmin      LD   R1,#0
    6188 1E     _c_dmin_1   PHL
    6189 19C669             JSR  c_2over
    618C 19C669             JSR  c_2over
    618F 011001             LD   R0,#1
    6192 199B56             JSR  _c_sub32
    6195 040F               LDA  FLAG
    6197 0F11               XOR  R1
    6199 060F               STA  FLAG
    619B 17A161             JNF  _c_dmin_2
    619E 19F569             JSR  c_2swap
    61A1 193A45 _c_dmin_2   JSR  pop_data_R4_R5
    61A4 1F                 RTS
                e_dmin      ;------------------------------------------------------------------
                
                            ; dmax  ( d1 d2 -- d3 )
    61A5 B261               DW   e_dmax
    61A7 04646D             DB   4,"dmax"
    61AA 6178   
    61AC 011101 c_dmax      LD   R1,#1
    61AF 188861             JMP  _c_dmin_1
                e_dmax      ;------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 5 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 6 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 7 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 8 characters
                ;------------------------------------------------------------------------------
                
                
                
                
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 12 characters
                ;------------------------------------------------------------------------------
                
                            ; ENVIRONMENT?  ( c-addr u -- false | x true )
    61B2 2562               DW   e_envqm
    61B4 0C656E             DB   12,"environment?"
    61B7 766972 
    61BA 6F6E6D 
    61BD 656E74 
    61C0 3F     
    61C1 1E     c_envqm     PHL
    61C2 193A45             JSR  pop_data_R4_R5
                            ;R4_L = length of the string
                            ;R5 = ptr to the string
                            ;walk through the table of known strings and find the requested string
    61C5 011828             LD   R6_L,#<tab_envstrings
    61C8 01197B             LD   R6_H,#>tab_envstrings
                _cenv01     ;loop
    61CB 192F3B             JSR  ld_ptr_r6
    61CE 19CE3A             JSR  lap_inc_ptr
    61D1 150E               TST
    61D3 16D244             JPF  push_data_accu_ret  ; return false
    61D6 2418               AD   R6_L
    61D8 0618               STA  R6_L
    61DA 021A16             LD   R7_L,R5_L
    61DD 021B17             LD   R7_H,R5_H
                            ;compare strings
    61E0 021014             LD   R0,R4_L
    61E3 19CE3A _cenv02     JSR  lap_inc_ptr
    61E6 150E               TST
    61E8 16CB61             JPF  _cenv01 ;end of string in ROM, no match
    61EB 0611               STA  R1
    61ED 193D3B             JSR  psh_ptr
    61F0 19363B             JSR  ld_ptr_r7
    61F3 19173B             JSR  inc_r7
    61F6 05                 LAP
    61F7 19563B             JSR  pop_ptr
    61FA 19EB3B             JSR  to_upper
    61FD 1411               CMP  R1
    61FF 17CB61             JNF  _cenv01 ;no match, try next string
    6202 20E361             JLP  _cenv02
                            ;found?
    6205 19CE3A             JSR  lap_inc_ptr
    6208 150E               TST
    620A 17CB61             JNF  _cenv01 ;no match, try next string
                            ;found!
    620D 19CE3A             JSR  lap_inc_ptr
    6210 0610               STA  R0  ;how many parameter words
    6212 19CE3A _cenv03     JSR  lap_inc_ptr
    6215 0614               STA  R4_L
    6217 19CE3A             JSR  lap_inc_ptr
    621A 0615               STA  R4_H
    621C 19DB44             JSR  push_data_R4
    621F 201262             JLP  _cenv03
    6222 188E50             JMP  ret_true
                e_envqm     ;------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_block.asm]
                
                            ; SAVE-BUFFERS  ( -- )  Save the contents of each UPDATEd block buffer to the EEPROM.
    6225 AF62               DW   e_savebuffers
    6227 0C7361             DB   12,"save-buffers"
    622A 76652D 
    622D 627566 
    6230 666572 
    6233 73     
                c_savebuffers
                            ; "blk_struct cell+ cell+ @ if blk_struct cell+ @ blk_struct @ eepsave
                            ;  false blk_struct cell+ cell+ ! then"
    6234 1E                 PHL
                _c_savebuffers
    6235 19D472             JSR  _c_chk_bptr
    6238 157C               TST  BLKSTR_UPD
    623A 16CA3A             JPF  rts_opc
    623D 017C00             LD   BLKSTR_UPD,#0
    6240 047B               LDA  BLKSTR_BLK+1
    6242 13FF               CMP  #0xFF
    6244 16CA3A             JPF  rts_opc
    6247 0615               STA  R4_H
    6249 02147A             LD   R4_L,BLKSTR_BLK+0
    624C 19DB44             JSR  push_data_R4
                            ;prepare writing the block
    624F 19AC4F             JSR  prep_eepblk
                            ;R3 = I2C device addess, R4 = write address
    6252 020C78             LD   PTR_L,BLKSTR_BUF+0
    6255 020D79             LD   PTR_H,BLKSTR_BUF+1
    6258 011808             LD   R6,#8
    625B 19D84F _c_eepsv2   JSR  feep_start_write_ackpoll
    625E 0380               LDA  #0x80
    6260 2414               AD   R4_L
    6262 0614               STA  R4_L
    6264 176962             JNF  _c_eepsv1
    6267 0915               INC  R4_H
                _c_eepsv1   ;write a 128-byte block to EEPROM
    6269 011280             LD   R2,#0x80
    626C 19E438             JSR  eeprom_write_block
    626F 190039             JSR  eeprom_stop
    6272 0A18               DEC  R6
    6274 1518               TST  R6
    6276 175B62             JNF  _c_eepsv2
                            ;finished
    6279 1F                 RTS
                
                _c_blk_free
                            ; try to free the block buffer again
    627A 1E                 PHL
    627B 199572             JSR  _c_bufaddr
    627E 19BF4F             JSR  ld_R5_1024
    6281 19FD44             JSR  push_data_R5
    6284 199850             JSR  c_sum16
    6287 19C85F             JSR  c_here
    628A 197C50             JSR  c_equal
    628D 190E45             JSR  pop_data_R4
    6290 1515               TST  R4_H
    6292 16CA3A             JPF  rts_opc
    6295 0A65               DEC  CP_H
    6297 0A65               DEC  CP_H
    6299 0A65               DEC  CP_H
    629B 0A65               DEC  CP_H
    629D 04                 DB   0x04  ; "jump" over following PHL instruction
                init_blk_struct:
    629E 1E                 PHL
                _cinitblks  ; buffer address := NULL
    629F 017800             LD   BLKSTR_BUF+0,#0
    62A2 017900             LD   BLKSTR_BUF+1,#0
                _empty_blkstruct:
                            ; buffer number := 0xFFFF
    62A5 017AFF             LD   BLKSTR_BLK+0,#0xFF
    62A8 017BFF             LD   BLKSTR_BLK+1,#0xFF
                            ;dirty_flag = 0
    62AB 017C00             LD   BLKSTR_UPD,#0
    62AE 1F                 RTS
                
                e_savebuffers ;----------------------------------------------------------------
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_my4th.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for My4TH
                ;------------------------------------------------------------------------------
                
                ;#ifdef WORDS_LEN_2
                ;            ; ,> ( "hexbytestream" -- )  Compile machine code to currently compiled word
                ;            DW   e_mgt
                ;            DB   2+FL_IMMEDIATE,",>"
                ;c_mgt       PHL
                ;            JSR  ld_ptr_inptr
                ;_c_mgt_1    LAP
                ;            TST
                ;            JPF  _c_mgt_2
                ;            CMP  #0x20
                ;            JPF  _c_mgt_2
                ;            JSR  inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            ROL
                ;            ROL
                ;            ROL
                ;            ROL
                ;            STA  R0
                ;            JSR  lap_inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            OR   R0
                ;            JSR  emit_code
                ;            JMP  _c_mgt_1
                ;_c_mgt_2    JSR  ld_inptr_ptr
                ;            RTS
                ;e_mgt       ;------------------------------------------------------------------
                ;#endif
                
                ;#ifdef WORDS_LEN_3
                ;            ; >SY  Convert index number to system call address
                ;            DW   e_2system
                ;            DB   3,">sy"
                ;c_2system   PHL
                ;            JSR  pop_data_R4
                ;            LDA  #<tab_syscalls
                ;            CLC
                ;            ROL  R4_L
                ;            ADD  R4_L
                ;            STA  PTR_L
                ;            LD   PTR_H,#>tab_syscalls
                ;            JSR  lap_inc_ptr
                ;            STA  R4_L
                ;            LAP
                ;            STA  R4_H
                ;            JMP  push_data_R4_ret
                ;e_2system   ;------------------------------------------------------------------
                ;#endif
                
                            ; RINP  ( -- u )  read input port
    62AF BA62               DW   e_rinp
    62B1 047269             DB   4,"rinp"
    62B4 6E70   
    62B6 1D     c_rinp      IN
                ;            STA  R4_L   -- not needed, removed in v1.1
    62B7 18EE44             JMP  push_data_accu
                e_rinp      ;------------------------------------------------------------------
                
                            ; WOUT  ( u -- )  write to output port
    62BA CB62               DW   e_wout
    62BC 04776F             DB   4,"wout"
    62BF 7574   
    62C1 1E     c_wout      PHL
    62C2 190E45             JSR  pop_data_R4
    62C5 021C14             LD   OUTP,R4_L
    62C8 261C               OUT  OUTP
    62CA 1F                 RTS
                e_wout      ;------------------------------------------------------------------
                
                            ; ROUT  ( -- u )  read current state of output port
    62CB D762               DW   e_rout
    62CD 04726F             DB   4,"rout"
    62D0 7574   
    62D2 041C   c_rout      LDA  OUTP    ; fixed in v1.1, was "LD R4_L,OUTP" in v1.0
    62D4 18EE44             JMP  push_data_accu
                e_rout      ;------------------------------------------------------------------
                
                
                
                
                
                
                
                
                
                
                            ; SYSV  ( u -- addr )   return a pointer to the vector address of system vector u
    62D7 F062               DW   e_sysv
    62D9 047379             DB   4,"sysv"
    62DC 7376   
    62DE 1E     c_sysv      PHL
    62DF 190E45             JSR  pop_data_R4
    62E2 0414               LDA  R4_L
    62E4 196946             JSR  getVectAdr
    62E7 02140C             LD   R4_L,PTR_L
    62EA 02150D             LD   R4_H,PTR_H
    62ED 18D744             JMP  push_data_R4_ret
                e_sysv      ;------------------------------------------------------------------
                
                
                
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_mynor.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for MyNOR
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_bload.asm]
                ;------------------------------------------------------------------------------
                ;  Binary Driver Loader
                ;------------------------------------------------------------------------------
                ;
                ;  This module can load and relocate a binary driver image into RAM memory.
                ;
                ;  The binary driver image must begin with this header:
                ;
                ;    1. byte :  ID 0x1B
                ;    2. byte :  reserved, must be 0
                ;    3. byte :  file size, bits 0-7
                ;    4. byte :  file size, bits 8-15
                ;    5. byte :  module compile address, bits 0-7
                ;    6. byte :  module compile address, bits 8-15
                ;    7. byte :  offset to the startup function, bits 0-7   (can be 0 if not used)
                ;    8. byte :  offset to the startup function, bits 8-15  (can be 0 if not used)
                ;    9. byte :  size of the following data section, bits 0-7
                ;   10. byte :  size of the following data section, bits 8-15
                ;
                ;  This module relocates all address it finds in the code section.
                ;  Data pointers must be written as a pair of " LD PTR_L,# / LD PTR_H,# ",
                ;  otherwise they won't be recognized.
                ;
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_edit.asm]
                
                            ; EDIT  ( u -- )  Edit a SCREEN
    62F0 BB69               DW   e_edit
    62F2 046564             DB   4,"edit"
    62F5 6974   
    62F7 1E     c_edit      PHL
                            PRINT text_loading
    62F8 198633           JSR  printstrm
    62FB FF               DB   <text_loading
    62FC 78               DB   >text_loading
    62FD 19666D             JSR  c_emptybuffers
    6300 19BB5F             JSR  c_base
    6303 192850             JSR  c_at
    6306 19305D             JSR  c_swap
    6309 199559             JSR  c_dup
    630C 192E6D             JSR  c_block
    630F 199559             JSR  c_dup
    6312 198369             JSR  c_mkpr
    6315 199873             JSR  c_decimal
                            ;on stack: oldbase, blocknmbr, buffer
                
    6318 153A               TST  LIB_LCDOUT
    631A 172166             JNF  _ceditlcd
                ;[File: forth_words_edit-term.asm]
                ;------------------------------------------------------------------------------
                ;  EDIT word to edit a SCREEN on a serial terminal via RS232
                ;------------------------------------------------------------------------------
                ;
                ; This file implements this FORTH code:
                ;
                ;
                ; hex
                ; : strbuf up @ 40 + ;  ( -- bufaddr : 64 bytes are save to use )
                ; 
                ; \ implement a routine to edit a Forth code line:
                ; : editline dup strbuf _edln strbuf swap 40 move ;
                ; 
                ; decimal
                ; 0 value scrnum
                ; 0 value scrbuf
                ; 0 value inpcnt
                ; 
                ; : hline 0 do [char] - emit loop ;  ( n -- )
                ; : prscrln dup 0 swap at-xy   ( line -- )
                ;     dup s>d <# # # #> type [char] | emit space
                ;     1- 64 * scrbuf + 64 type space [char] | emit cr ;
                ; : printscr page 29 hline ." [Screen " scrnum s>d <# # # # #>
                ;     type [char] ] emit 29 hline 17 1 do i prscrln loop 70 hline
                ;     cr ." Enter line number to edit, or enter:" cr
                ;     ." S = save, Q = quit (lose changes), W = save and quit, "
                ;     ." C = clear screen" ;
                ; 
                ; : printpmpt 0 20 at-xy ." >" 66 0 do space loop 2 20 at-xy ;
                ; : input2 begin strbuf 2 accept dup to inpcnt until ;
                ; : isdigit 48 58 within ;  ( n -- flag )
                ; : isnum  -1 >r inpcnt 0 do strbuf i + c@ isdigit
                ;     r> and >r loop r> ;  ( -- flag )
                ; : getnum 0 >r inpcnt 0 do r> 10 * strbuf i + c@ 48 - + >r
                ;     loop r> ;  ( -- number )
                ; : getcmd  0 >r inpcnt 0 do r> 8 LSHIFT strbuf i + c@ + >r
                ;     loop r> ;  ( -- number )
                ; : getinp isnum if getnum dup 1 17 within if 1 else drop 0 0 then
                ;     else getcmd 0 then ;  ( -- num 1  [or]  -- cmd 0 )
                ; : toupper dup 97 123 within if 32 - then ;  ( char -- CHAR )
                ; : delay 0 do loop ;  ( n -- )
                ; : savescr space space ." saving..." save-buffers ;  ( -- )
                ; 
                ; : evalinp ( -- )  getinp
                ;     if  \ number entered
                ;       0 20 at-xy dup s>d <# # # #> type ." >"
                ;       dup 1- 64 * scrbuf + editline prscrln update
                ;     else  \ command entered
                ;       toupper case
                ;         [char] Q of  cr ." Quit" cr empty-buffers quit endof
                ;         [char] S of  savescr endof
                ;         [char] W of  savescr cr ." Quit" cr quit endof
                ;         [char] C of  scrbuf 1024 32 fill printscr update endof
                ;         space ." ? Unknown command" 500 delay
                ;       endcase
                ;     then ;
                ; 
                ; : menuloop begin printpmpt input2 evalinp again ; 
                ; : edit cr ." loading screen..." dup to scrnum
                ;     block dup to scrbuf _mkpr printscr menuloop ;
                ;
                ;------------------------------------------------------------------------------
                
                            ;edit on a serial terminal
                            ;on stack: blocknbr, buffer
    631D 193B63             JSR _c_val_scrbuf
    6320 193E50             JSR  c_store
    6323 193863             JSR _c_val_scrnum
    6326 193E50             JSR  c_store
    6329 19DB63             JSR _c_printscr
                
                ; : menuloop begin printpmpt input2 evalinp again ; 
    632C 199964 _c_mloop    JSR _c_printpmpt
    632F 19BC64             JSR _c_input2
    6332 198F65             JSR _c_evalinp
    6335 182C63             JMP _c_mloop
                
                ; 0 value scrnum
                _c_val_scrnum
    6338 0300               LDA  #<(EDIT_STRUCT+0)
    633A 01                 DB   0x01  ; trick: jumps over next two bytes, but overwrites register TEMP5
                ; 0 value scrbuf
                _c_val_scrbuf
    633B 0302               LDA  #<(EDIT_STRUCT+2)
    633D 01                 DB   0x01  ; trick: jumps over next two bytes, but overwrites register TEMP5
                ; 0 value inpcnt
                _c_val_inpcnt
    633E 0304               LDA  #<(EDIT_STRUCT+4)
    6340 0614               STA  R4_L
    6342 0115FE             LD   R4_H,#>(EDIT_STRUCT+0)
    6345 18DB44             JMP  push_data_R4
                
                ; : strbuf up @ 0x40 + ;  -- here implemented by using SYS_BUF instead
                MEM_STRBUF  SET  SYS_BUF
                _c_strbuf   
    6348 011430             LD   R4_L,#<MEM_STRBUF
    634B 0115FE             LD   R4_H,#>MEM_STRBUF
    634E 18DB44             JMP  push_data_R4
                
                ; : editline dup strbuf _edln strbuf swap 0x40 move ;
                _c_editline 
    6351 1E                 PHL
    6352 199559             JSR  c_dup
    6355 194863             JSR _c_strbuf
    6358 193A45             JSR  pop_data_R4_R5
    635B 011041             LD   R0,#0x41
    635E 19D934             JSR  forth_edlin
    6361 194863             JSR _c_strbuf
    6364 19305D             JSR  c_swap
    6367 011440             LD   R4_L,#64
    636A 011500             LD   R4_H,#0
    636D 19DB44             JSR  push_data_R4
    6370 19D75E             JSR  c_move
    6373 1F                 RTS
                
                ; : hline 0 do [char] - emit loop ;  ( n -- )
                _c_hline    ; parameter in ACCU, not on data stack
    6374 1E                 PHL
    6375 0610               STA  R0
    6377 032D   _chline01   LDA  #'-'
    6379 192433             JSR  print_char
    637C 207763             JLP  _chline01
    637F 1F                 RTS
                
                ; : prscrln dup 0 swap at-xy   ( line -- )
                ;     dup s>d <# # # #> type [char] | emit space
                ;     1- 64 * scrbuf + 64 type space [char] | emit cr ;
                _c_prscrln
    6380 1E                 PHL
    6381 199559             JSR  c_dup
    6384 19C944             JSR  push_data_zero
    6387 19305D             JSR  c_swap
    638A 19D76C             JSR  c_at_xy
    638D 19C063             JSR  _cprscr01
    6390 037C               LDA  #'|'
    6392 192433             JSR  print_char
    6395 190B6A             JSR  c_space
    6398 191353             JSR  c_1minus
    639B 0340               LDA  #64
    639D 19EE44             JSR  push_data_accu
    63A0 19C650             JSR  c_mul16
    63A3 193B63             JSR _c_val_scrbuf
    63A6 192850             JSR  c_at
    63A9 199850             JSR  c_sum16
    63AC 0340               LDA  #64
    63AE 19EE44             JSR  push_data_accu
    63B1 19755D             JSR  c_type
    63B4 190B6A             JSR  c_space
    63B7 037C               LDA  #'|'
    63B9 192433             JSR  print_char
    63BC 196753             JSR  c_cr
    63BF 1F                 RTS
    63C0 1E     _cprscr01   PHL
    63C1 199559             JSR  c_dup
    63C4 19AD5A             JSR  c_stod
    63C7 199D55             JSR  c_lns
    63CA 195451 _cprscr03   JSR  c_ns
    63CD 195451             JSR  c_ns
    63D0 19A955             JSR  c_nsg
    63D3 19755D             JSR  c_type
    63D6 1F                 RTS
    63D7 1E     _cprscr02   PHL
    63D8 18CA63             JMP  _cprscr03
                
                ; : printscr page 29 hline ." [Screen " scrnum s>d <# # # # #>
                ;     type [char] ] emit 29 hline 17 1 do i prscrln loop 70 hline
                ;     cr ." Enter line number to edit, or enter:" cr
                ;     ." S = save, Q = quit (lose changes), W = save and quit, "
                ;     ." C = clear screen" ;
                _c_printscr
    63DB 1E                 PHL
                            ;page 29 hline ." [Screen "
    63DC 19D65F             JSR  c_page
    63DF 031D               LDA  #29
    63E1 197463             JSR _c_hline
                            PRINT _cprscrT1
    63E4 198633           JSR  printstrm
    63E7 23               DB   <_cprscrT1
    63E8 64               DB   >_cprscrT1
                            ;scrnum s>d <# # # # #>
    63E9 193863             JSR _c_val_scrnum
    63EC 192850             JSR  c_at
    63EF 19AD5A             JSR  c_stod
    63F2 199D55             JSR  c_lns
    63F5 195451             JSR  c_ns
    63F8 19D763             JSR  _cprscr02 ;re-use code from c_prscrln
                            ;type [char] ] emit 29 hline
    63FB 035D               LDA  #']'
    63FD 192433             JSR  print_char
    6400 031D               LDA  #29
    6402 197463             JSR _c_hline
                            ;17 1 do i prscrln loop
    6405 0301               LDA  #1
    6407 1B0E   _cprtscr01  PSH
    6409 19EE44             JSR  push_data_accu
    640C 198063             JSR _c_prscrln
    640F 1C0E               POP
    6411 090E               INC
    6413 1311               CMP  #17
    6415 170764             JNF  _cprtscr01
                            ;70 hline
    6418 0346               LDA  #70
    641A 197463             JSR _c_hline
                            ;     cr ." Enter line number to edit, or enter:" cr
                            ;     ." S = save, Q = quit (lose changes), W = save and quit, "
                            ;     ." C = clear screen" ;
                            PRINT _cprscrT2
    641D 198633           JSR  printstrm
    6420 2C               DB   <_cprscrT2
    6421 64               DB   >_cprscrT2
    6422 1F                 RTS
    6423 5B5363 _cprscrT1   DB   "[Screen ",0
    6426 726565 
    6429 6E2000 
    642C 0A456E _cprscrT2   DB   "\nEnter line number to edit, or enter:\n"
    642F 746572 
    6432 206C69 
    6435 6E6520 
    6438 6E756D 
    643B 626572 
    643E 20746F 
    6441 206564 
    6444 69742C 
    6447 206F72 
    644A 20656E 
    644D 746572 
    6450 3A0A   
    6452 53203D             DB   "S = save, Q = quit (lose changes), W = save and quit, "
    6455 207361 
    6458 76652C 
    645B 205120 
    645E 3D2071 
    6461 756974 
    6464 20286C 
    6467 6F7365 
    646A 206368 
    646D 616E67 
    6470 657329 
    6473 2C2057 
    6476 203D20 
    6479 736176 
    647C 652061 
    647F 6E6420 
    6482 717569 
    6485 742C20 
    6488 43203D             DB   "C = clear screen",0
    648B 20636C 
    648E 656172 
    6491 207363 
    6494 726565 
    6497 6E00   
                
                ; : printpmpt 0 20 at-xy ." >" 66 0 do space loop 2 20 at-xy ;
                _c_printpmpt
    6499 1E                 PHL
                            ;0 20 at-xy ." >"
    649A 011000             LD   R0,#0
    649D 011114             LD   R1,#20
    64A0 19BF32             JSR  display_gotoxy
    64A3 033E               LDA  #'>'
    64A5 192433             JSR  print_char
                            ;67 0 do space loop
    64A8 011043             LD   R0,#67
    64AB 0320   _cprpmpt01  LDA  #' '
    64AD 192433             JSR  print_char
    64B0 20AB64             JLP  _cprpmpt01
                            ;2 20 at-xy
    64B3 011002             LD   R0,#2
    64B6 011114             LD   R1,#20
    64B9 18E16C             JMP  _c_atxy_rts
                
                ; : input2 begin strbuf 2 accept dup to inpcnt until ;
                _c_input2
    64BC 1E                 PHL
    64BD 194863 _cinp201    JSR _c_strbuf
    64C0 0302               LDA  #2
    64C2 19EE44             JSR  push_data_accu
    64C5 19C070             JSR  c_accept
    64C8 199559             JSR  c_dup
    64CB 193E63             JSR _c_val_inpcnt
    64CE 193E50             JSR  c_store
    64D1 190E45             JSR  pop_data_R4
    64D4 1514               TST  R4_L
    64D6 16BD64             JPF  _cinp201
    64D9 1F                 RTS
                
                ; : isnum  -1 >r inpcnt 0 do strbuf i + c@ isdigit
                ;     r> and >r loop r> ;  ( -- flag )
                ; optimized implementation:
                _c_isnum
    64DA 1E                 PHL
    64DB 19F464             JSR  _cisnum03
    64DE 0114FF             LD   R4_L,#0xFF  ;flag: initialize with TRUE
    64E1 19CE3A _cisnum02   JSR  lap_inc_ptr
    64E4 196F3B             JSR  is_digit
    64E7 17ED64             JNF  _cisnum01
    64EA 011400             LD   R4_L,#0     ;set flag to false
    64ED 20E164 _cisnum01   JLP  _cisnum02
    64F0 19CC44             JSR  _pushR4LR4L ;push flag to data stack
    64F3 1F                 RTS
    64F4 1E     _cisnum03   PHL
    64F5 193E63             JSR _c_val_inpcnt
    64F8 192850             JSR  c_at
    64FB 190E45             JSR  pop_data_R4
    64FE 021014             LD   R0,R4_L
    6501 010C30             LD   PTR_L,#<MEM_STRBUF
    6504 010DFE             LD   PTR_H,#>MEM_STRBUF
    6507 1F                 RTS
                
                ; : getnum 0 >r inpcnt 0 do r> 10 * strbuf i + c@ 48 - + >r
                ;     loop r> ;  ( -- number )
                ; optimized implementation, reads only numbers 0-255:
                _c_getnum
    6508 1E                 PHL
    6509 19F464             JSR  _cisnum03  ;re-use code from _c_isnum
    650C 011400             LD   R4_L,#0
    650F 011500             LD   R4_H,#0
    6512 19E840 _cgetnm01   JSR  mul10
    6515 19CE3A             JSR  lap_inc_ptr
    6518 01050F             AND  #0x0F
    651B 0D05   
    651D 2414               AD   R4_L
    651F 0614               STA  R4_L
    6521 201265             JLP  _cgetnm01
    6524 18D744             JMP  push_data_R4_ret
                
                ; : getcmd  0 >r inpcnt 0 do r> 8 LSHIFT strbuf i + c@ + >r
                ;     loop r> ;  ( -- number )
                ; optimized implementation:
                _c_getcmd
    6527 1E                 PHL
    6528 19F464             JSR  _cisnum03  ;re-use code from _c_isnum
    652B 011400             LD   R4_L,#0
    652E 021514 _cgetcm01   LD   R4_H,R4_L
    6531 19CE3A             JSR  lap_inc_ptr
    6534 0614               STA  R4_L
    6536 202E65             JLP  _cgetcm01
    6539 18D744             JMP  push_data_R4_ret
                
                ; : getinp isnum if getnum dup 1 17 within if 1 else drop 0 0 then
                ;     else getcmd 0 then ;  ( -- num 1  [or]  -- cmd 0 )
                _c_getinp
    653C 1E                 PHL
    653D 19DA64             JSR _c_isnum
    6540 190E45             JSR  pop_data_R4
    6543 1514               TST  R4_L
    6545 166B65             JPF  _cgetin01
    6548 190865             JSR _c_getnum
    654B 199559             JSR  c_dup
    654E 190E45             JSR  pop_data_R4
    6551 0A14               DEC  R4_L
    6553 03F0               LDA  #0xF0
    6555 0D14               AND  R4_L
    6557 150E               TST
    6559 176265             JNF  _cgetin02
    655C 0301               LDA  #1
    655E 19EE44             JSR  push_data_accu
    6561 1F                 RTS
    6562 193E5D _cgetin02   JSR  c_drop
    6565 19C944             JSR  push_data_zero
    6568 186E65             JMP  _cgetin03
    656B 192765 _cgetin01   JSR _c_getcmd
    656E 19C944 _cgetin03   JSR  push_data_zero
    6571 1F                 RTS
                
                ;; : toupper dup 97 123 within if 32 - then ;  ( char -- CHAR )
                ;_c_toupper
                ;            PHL
                ;            JSR  pop_data_R4
                ;            LDA  R4_L
                ;            JSR  to_upper
                ;            STA  R4_L
                ;            JMP  push_data_R4_ret
                
                ; : delay 0 do loop ;  ( n -- )
                ;_c_delay
                ;            PHL
                ;            JSR  pop_data_R4
                ;_cdelay01   TST  R4_L
                ;            JNF  _cdelay02
                ;            TST  R4_H
                ;            JPF  rts_opc
                ;            DEC  R4_H
                ;_cdelay02   DEC  R4_L
                ;            LD   R0,#30
                ;_cdelay03   JLP  _cdelay03
                ;            JMP  _cdelay01
                
                ; : savescr space space ." saving..." save-buffers ;  ( -- )
                _c_savescr
    6572 1E                 PHL
                _c_savescr1
                            PRINT text_saving1
    6573 198633           JSR  printstrm
    6576 F3               DB   <text_saving1
    6577 78               DB   >text_saving1
    6578 193462             JSR  c_savebuffers
    657B 1F                 RTS
                
                _c_clearScreen
                            ;fill 1kB memory with spaces
                            ;( addr -- )
    657C 1E                 PHL
    657D 011400             LD   R4_L,#0
    6580 011504             LD   R4_H,#4
    6583 19DB44             JSR  push_data_R4
    6586 0320               LDA  #32
    6588 19EE44             JSR  push_data_accu
    658B 19AD5E             JSR  c_fill
    658E 1F                 RTS
                
                ; : evalinp ( -- )  getinp
                ;     if  \ number entered
                ;       0 20 at-xy dup s>d <# # # #> type ." >"
                ;       dup 1- 64 * scrbuf + editline prscrln update
                ;     else  \ command entered
                ;       toupper case
                ;         [char] Q of  cr ." Quit" cr empty-buffers quit endof
                ;         [char] S of  savescr endof
                ;         [char] W of  savescr cr ." Quit" cr quit endof
                ;         [char] C of  scrbuf 1024 32 fill printscr update endof
                ;         space ." ? Unknown command" 500 delay
                ;       endcase
                ;     then ;
                _c_evalinp
    658F 1E                 PHL
    6590 193C65             JSR _c_getinp
    6593 190E45             JSR  pop_data_R4
    6596 1514               TST  R4_L
    6598 16CD65             JPF  _cevali01
                            ;number entered
    659B 011000             LD   R0,#0
    659E 011114             LD   R1,#20
    65A1 19BF32             JSR  display_gotoxy
    65A4 19C063             JSR  _cprscr01  ;re-use code from _c_prscrln to print the number
    65A7 033E               LDA  #'>'
    65A9 192433             JSR  print_char
    65AC 199559             JSR  c_dup
    65AF 191353             JSR  c_1minus
    65B2 0340               LDA  #64
    65B4 19EE44             JSR  push_data_accu
    65B7 19C650             JSR  c_mul16
    65BA 193B63             JSR _c_val_scrbuf
    65BD 192850             JSR  c_at
    65C0 199850             JSR  c_sum16
    65C3 195163             JSR _c_editline
    65C6 198063             JSR _c_prscrln
    65C9 19F072             JSR  c_update
    65CC 1F                 RTS
                _cevali01   ;command entered
    65CD 190E45             JSR  pop_data_R4
    65D0 1515               TST  R4_H
    65D2 17FE65             JNF  _cevali05
    65D5 0414               LDA  R4_L
    65D7 19EB3B             JSR  to_upper
    65DA 1351               CMP  #'Q'
    65DC 161766             JPF  _cevali06
    65DF 1353   _cevali02   CMP  #'S'
    65E1 167365             JPF  _c_savescr1
    65E4 1357   _cevali03   CMP  #'W'
    65E6 161466             JPF  _cevali04
    65E9 1343               CMP  #'C'
    65EB 17FE65             JNF  _cevali05
                            ;case C
    65EE 193B63             JSR _c_val_scrbuf
    65F1 192850             JSR  c_at
    65F4 197C65             JSR _c_clearScreen
    65F7 19DB63             JSR _c_printscr
    65FA 19F072             JSR  c_update
    65FD 1F                 RTS
                _cevali05   ;unknown command
                            PRINT text_errCmd
    65FE 198633           JSR  printstrm
    6601 7C               DB   <text_errCmd
    6602 78               DB   >text_errCmd
    6603 011196             LD   R1,#150
    6606 011000             LD   R0,#0
    6609 200966 _cevali07   JLP  _cevali07
    660C 0A11               DEC  R1
    660E 1511               TST  R1
    6610 170966             JNF  _cevali07
    6613 1F                 RTS
                
                _cevali04   ;case W
    6614 197265             JSR _c_savescr
                _cevali06   ;case Q
    6617 192233             JSR  print_nl
                            ;return to Forth, break the menu loop
    661A 1C0E               POP
    661C 1C0E               POP
                
                            ;end of editor code, program execution continues in file forth_words_edit.asm
                ;[File: forth_words_edit.asm]
    661E 187A69             JMP  _ceditend
                _ceditlcd
                ;[File: forth_words_edit-lcd.asm]
                ;------------------------------------------------------------------------------
                ;  EDIT word to edit a SCREEN on a 40x4 LCD
                ;------------------------------------------------------------------------------
                
                ED2_WINX    SET LIB_BUF+0  ; first row of a line shown on the LCD (0-26) (LCD window top-left X-coordinate)
                ED2_WINY    SET LIB_BUF+1  ; first line shown on the LCD (0 - 17) (LCD window top-left Y-coordinate)
                ED2_LINE    SET LIB_BUF+2  ; current line, can be 0 - 17, 0 and 17 = head and bottom line, others = screen line
                ED2_XPOS    SET LIB_BUF+3  ; position within a line (0 to 63, or 0 to 3 in head and bottom line)
                ED2_SCRNUM  SET LIB_BUF+4  ; block/screen number (2 bytes)
                ED2_SCRBUF  SET LIB_BUF+6  ; ptr to block buffer (2 bytes)
                ED2_SXPOS   SET LIB_BUF+8  ; saved value of ED2_XPOS before activation of the menu line
                ED2_LCDUPD  SET LIB_BUF+9  ; LCD update flag: 0=set only cursor, 0x80=update current line, others: update whole display,
                ED2_TOUCH   SET LIB_BUF+10 ; Flag: nonzero when screen was modified
                
                CHAR_NBR10  SET 2
                CHAR_ALEFT  SET 3
                CHAR_ARIGHT SET 4
                
                            ;LCD editor
                            ;on stack: blocknbr, buffer
    6621 190E45             JSR  pop_data_R4
    6624 022614             LD   ED2_SCRBUF+0,R4_L
    6627 022715             LD   ED2_SCRBUF+1,R4_H
    662A 190E45             JSR  pop_data_R4
    662D 022414             LD   ED2_SCRNUM+0,R4_L
    6630 022515             LD   ED2_SCRNUM+1,R4_H
                
                            ;initialize the LCD
    6633 010CC8             LD   PTR_L,#<ed2_chars
    6636 010D7D             LD   PTR_H,#>ed2_chars
    6639 011002             LD   R0,#CHAR_NBR10
    663C 011103             LD   R1,#3
    663F 193F32             JSR  lcd_load_charset
    6642 19A52F             JSR  lcd_clear
                
                            ;make string from screen number
    6645 021424             LD   R4_L,ED2_SCRNUM+0
    6648 021525             LD   R4_H,ED2_SCRNUM+1
    664B 191D34             JSR  convert_16bit_to_decimal
    664E 010C30             LD   PTR_L,#<NUM_BUF
    6651 010DFE             LD   PTR_H,#>NUM_BUF
    6654 0353               LDA  #'S'
    6656 19D93A             JSR  sap_inc_ptr
    6659 0343               LDA  #'C'
    665B 19D93A             JSR  sap_inc_ptr
    665E 0352               LDA  #'R'
    6660 19D93A             JSR  sap_inc_ptr
    6663 0422               LDA  LIB_BUF+2
    6665 19D93A             JSR  sap_inc_ptr
    6668 0423               LDA  LIB_BUF+3
    666A 19D93A             JSR  sap_inc_ptr
    666D 0424               LDA  LIB_BUF+4
    666F 19D93A             JSR  sap_inc_ptr
    6672 0320               LDA  #' '
    6674 19D93A             JSR  sap_inc_ptr
    6677 0300               LDA  #0
    6679 07                 SAP
                
                            ;initialize the editor
                            ;LDA  #0  -> accu is already 0
    667A 0620               STA  ED2_WINX
    667C 0621               STA  ED2_WINY
    667E 0623               STA  ED2_XPOS
    6680 062A               STA  ED2_TOUCH
    6682 0301               LDA  #1
    6684 0622               STA  ED2_LINE
    6686 0629               STA  ED2_LCDUPD
                
                            ;Main loop
                            ;update display and set the cursor
                            ;depending on the state of the ED2_LCDUPD-flag
    6688 0929   _cedit201   INC  ED2_LCDUPD
    668A 1529   _cedit200   TST  ED2_LCDUPD
    668C 16A866             JPF  _cedit219
    668F 0429               LDA  ED2_LCDUPD
    6691 1380               CMP  #0x80
    6693 17A266             JNF  _cedit218
    6696 021022             LD   R0,ED2_LINE
    6699 02113F             LD   R1,LIB_LCDPOSY
    669C 19AF68             JSR  _c_ed2_prline
    669F 18A566             JMP  _cedit229
    66A2 196868 _cedit218   JSR  _c_ed2_updDisplay
    66A5 012900 _cedit229   LD   ED2_LCDUPD,#0
    66A8 194568 _cedit219   JSR  _c_ed2_setCursor
                _cedit202   ;wait for keypress and get the key code
    66AB 19AC34             JSR  inp_readkey
    66AE 0613               STA  R3 ;save a copy of the key code in R3
    66B0 131F               CMP  #KCODE_LEFT
    66B2 168C67             JPF  _cedit203
    66B5 131E               CMP  #KCODE_RIGHT
    66B7 16A567             JPF  _cedit204
    66BA 131C               CMP  #KCODE_UP
    66BC 16D467             JPF  _cedit205
    66BF 131D               CMP  #KCODE_DOWN
    66C1 161868             JPF  _cedit206
    66C4 198468             JSR  _c_ed2_isMenuLine
    66C7 0413               LDA  R3
    66C9 160E67             JPF  _cedit217
    66CC 130D               CMP  #13
    66CE 160B68             JPF  _cedit215
    66D1 1308               CMP  #8
    66D3 165367             JPF  _cedit222
                
                            ;check if character is printable
    66D6 03E0               LDA  #0xE0
    66D8 0D13               AND  R3
    66DA 150E               TST
    66DC 16AB66             JPF  _cedit202
                            ;print it
                            ;1. check if there is "space" at the end of the line
    66DF 01113F             LD   R1,#63
    66E2 198E68             JSR  _c_ed_calcCurMemLinePtr
    66E5 05                 LAP
    66E6 1320               CMP  #0x20
    66E8 17AB66             JNF  _cedit202  ;no space, ignore this keypress
    66EB 0C2A               ROR  ED2_TOUCH  ;set flag
                            ;2. move rest of the line to the right to insert space for the new character
    66ED 033F               LDA  #63
    66EF 2523               SU   ED2_XPOS
    66F1 150E               TST
    66F3 160567             JPF  _cedit220
    66F6 0610               STA  R0
    66F8 19EF3A _cedit221   JSR  dec_ptr
    66FB 19CE3A             JSR  lap_inc_ptr
    66FE 07                 SAP
    66FF 19EF3A             JSR  dec_ptr
    6702 20F866             JLP  _cedit221
                            ;3. write character into memory
    6705 0413   _cedit220   LDA  R3
    6707 07                 SAP
                            ;update at least the current line in the display
    6708 012980             LD   ED2_LCDUPD,#0x80
                            ;move cursor to the right
    670B 18A567             JMP  _cedit204
                
                _cedit217   ;handle the MENU
    670E 130D               CMP  #13
    6710 17AB66             JNF  _cedit202
    6713 0423               LDA  ED2_XPOS
    6715 150E               TST
    6717 163567             JPF  _cedit225
    671A 1301               CMP  #1
    671C 163B67             JPF  _cedit226
    671F 1302               CMP  #2
    6721 167769             JPF  _cedit227
                
                            ;clear screen
    6724 021426             LD   R4_L,ED2_SCRBUF+0
    6727 021527             LD   R4_H,ED2_SCRBUF+1
    672A 19DB44             JSR  push_data_R4
    672D 197C65             JSR _c_clearScreen
    6730 092A               INC  ED2_TOUCH
    6732 18A266             JMP  _cedit218
                
                _cedit225   ;save
    6735 194167             JSR  _cedit228
    6738 18A266             JMP  _cedit218
                
                _cedit226   ;save + quit
    673B 194167             JSR  _cedit228
    673E 187A69             JMP  _cedit300
                
                _cedit228   ;save screen and return
    6741 1E                 PHL
    6742 199732             JSR  display_clear
                            PRINT text_saving2
    6745 198633           JSR  printstrm
    6748 F5               DB   <text_saving2
    6749 78               DB   >text_saving2
    674A 192233             JSR  print_nl
    674D 19F072             JSR  c_update
    6750 183562             JMP _c_savebuffers
                
                _cedit222   ;handle deletion of a character
    6753 1523               TST  ED2_XPOS
    6755 16AB66             JPF  _cedit202  ;nothing to delete, ignore this keypress
    6758 012980             LD   ED2_LCDUPD,#0x80
    675B 021123             LD   R1,ED2_XPOS
    675E 198E68             JSR  _c_ed_calcCurMemLinePtr
    6761 033F               LDA  #63
    6763 062A               STA  ED2_TOUCH
    6765 2523               SU   ED2_XPOS
    6767 0610               STA  R0
    6769 1510               TST  R0
    676B 0910               INC  R0
    676D 177F67             JNF  _cedit224
    6770 05                 LAP
    6771 1320               CMP  #0x20
    6773 167F67             JPF  _cedit224
    6776 0320               LDA  #0x20
    6778 07                 SAP
    6779 188A66             JMP  _cedit200
    677C 19DA3A _cedit223   JSR  inc_ptr
    677F 05     _cedit224   LAP
    6780 19EF3A             JSR  dec_ptr
    6783 19D93A             JSR  sap_inc_ptr
    6786 207C67             JLP  _cedit223
    6789 0320               LDA  #0x20
    678B 07                 SAP
                
                _cedit203   ;cursor left
    678C 1523               TST  ED2_XPOS
    678E 16AB66             JPF  _cedit202
    6791 198468             JSR  _c_ed2_isMenuLine
    6794 0423               LDA  ED2_XPOS
    6796 0A23               DEC  ED2_XPOS
    6798 168866             JPF  _cedit201
    679B 1420               CMP  ED2_WINX
    679D 178A66             JNF  _cedit200
    67A0 0A20               DEC  ED2_WINX
    67A2 188866             JMP  _cedit201
                
                _cedit204   ;cursor right
    67A5 198468             JSR  _c_ed2_isMenuLine
    67A8 0423               LDA  ED2_XPOS
    67AA 17B767             JNF  _cedit209
    67AD 1303               CMP  #3
    67AF 16AB66             JPF  _cedit202
    67B2 0923               INC  ED2_XPOS
    67B4 188866             JMP  _cedit201
    67B7 133F   _cedit209   CMP  #63
    67B9 168A66             JPF  _cedit200 ;print entered character without scrolling to the right
    67BC 0923               INC  ED2_XPOS
    67BE 0423               LDA  ED2_XPOS
    67C0 010524             SU   #36
    67C3 2505   
    67C5 178A66             JNF  _cedit200
    67C8 0920               INC  ED2_WINX
    67CA 1420               CMP  ED2_WINX
    67CC 168866             JPF  _cedit201
    67CF 0A20               DEC  ED2_WINX
    67D1 188A66             JMP  _cedit200
                
                _cedit205   ;cursor up
    67D4 1522               TST  ED2_LINE
    67D6 16AB66             JPF  _cedit202
    67D9 198468             JSR  _c_ed2_isMenuLine
    67DC 0422               LDA  ED2_LINE
    67DE 0A22               DEC  ED2_LINE
    67E0 17E967             JNF  _cedit212
    67E3 022328 _cedit213   LD   ED2_XPOS,ED2_SXPOS
    67E6 188866             JMP  _cedit201
    67E9 1421   _cedit212   CMP  ED2_WINY
    67EB 173C68             JNF  _cedit230 ;_cedit200
    67EE 0A21               DEC  ED2_WINY
    67F0 19F667 _cedit211   JSR  _cedit214
    67F3 188866             JMP  _cedit201
                
                _cedit214   ;enter menu-line, return with FLAG=1 when display must be updated
    67F6 1E                 PHL
    67F7 198468             JSR  _c_ed2_isMenuLine
    67FA 17CA3A             JNF  rts_opc
    67FD 022823             LD   ED2_SXPOS,ED2_XPOS
    6800 012301             LD   ED2_XPOS,#1
    6803 152A               TST  ED2_TOUCH
    6805 17CB3A             JNF  return_flag_1
    6808 0923               INC  ED2_XPOS
    680A 1F                 RTS
                
                _cedit215   ;return
    680B 012300             LD   ED2_XPOS,#0
    680E 012000             LD   ED2_WINX,#0
    6811 0422               LDA  ED2_LINE
    6813 1310               CMP  #16
    6815 168866             JPF  _cedit201
                
                _cedit206   ;cursor down
    6818 0422               LDA  ED2_LINE
    681A 1311               CMP  #17
    681C 16AB66             JPF  _cedit202
    681F 1522               TST  ED2_LINE
    6821 0922               INC  ED2_LINE
    6823 16E367             JPF  _cedit213
    6826 010503             SU   #3
    6829 2505   
    682B 1421               CMP  ED2_WINY
    682D 173568             JNF  _cedit216
    6830 0921               INC  ED2_WINY
    6832 18F067             JMP  _cedit211
    6835 030D   _cedit216   LDA  #13
    6837 1413               CMP  R3
    6839 16F067             JPF  _cedit211
    683C 19F667 _cedit230   JSR  _cedit214
    683F 168866             JPF  _cedit201
    6842 188A66             JMP  _cedit200
                
                _c_ed2_setCursor:
                            ;set cursor to current position
    6845 1E                 PHL
    6846 198468             JSR  _c_ed2_isMenuLine
    6849 175468             JNF  _ced2sc01
    684C 021014             LD   R0,R4_L
    684F 0910               INC  R0
    6851 185E68             JMP  _ced2sc02
    6854 0423   _ced2sc01   LDA  ED2_XPOS
    6856 2520               SU   ED2_WINX
    6858 090E               INC
    685A 090E               INC
    685C 0610               STA  R0
    685E 0422   _ced2sc02   LDA  ED2_LINE
    6860 2521               SU   ED2_WINY
    6862 0611               STA  R1
    6864 19B631             JSR  lcd_gotoxy
    6867 1F                 RTS
                
                _c_ed2_updDisplay:
                            ;update the display, print out all lines
    6868 1E                 PHL
    6869 011600             LD   R5_L,#0
    686C 021721             LD   R5_H,ED2_WINY
    686F 021116 _ced2upd01  LD   R1,R5_L
    6872 021017             LD   R0,R5_H
    6875 19AF68             JSR  _c_ed2_prline
    6878 0917               INC  R5_H
    687A 0916               INC  R5_L
    687C 0416               LDA  R5_L
    687E 1304               CMP  #4
    6880 176F68             JNF  _ced2upd01
    6883 1F                 RTS
                
                _c_ed2_isMenuLine:
    6884 0422               LDA  ED2_LINE
                _c_ed2_isMLaccu:
                            ;Check if the line numbe in ACCU is line 0 or line 17.
    6886 150E               TST
    6888 16CD3A             JPF  ret_opc
    688B 1311               CMP  #17
    688D 1A                 RET
                
                _c_ed_calcCurMemLinePtr:
    688E 0422               LDA  ED2_LINE
                _c_ed_calcMemLinePtr:  ;shared code
    6890 0A0E               DEC
    6892 060C               STA  PTR_L
    6894 010D00             LD   PTR_H,#0
    6897 011006             LD   R0,#6
    689A 23                 CLC
    689B 210C   _ced2pl16   RWL  PTR_L
    689D 209B68             JLP  _ced2pl16
    68A0 0411               LDA  R1
    68A2 240C               AD   PTR_L
    68A4 2426               AD   ED2_SCRBUF+0
    68A6 060C               STA  PTR_L
    68A8 040D               LDA  PTR_H
    68AA 1027               ADD  ED2_SCRBUF+1
    68AC 060D               STA  PTR_H
    68AE 1A                 RET
                
                _c_ed2_prline:
                            ;Print a text line to the screen
                            ;In: R0 = line 0-17, R1 = LCD Y-position 0-3
                            ;Out: In line 0 and line 17, R4_L is the position of the selected '<'
    68AF 1E                 PHL
    68B0 021210             LD   R2,R0
    68B3 011000             LD   R0,#0
    68B6 19B631             JSR  lcd_gotoxy
    68B9 0412               LDA  R2
    68BB 198668             JSR  _c_ed2_isMLaccu
    68BE 161869             JPF  _ced2pl01
                            ;print text line
                            ;1. print line number (hex 0x1-0x10)
    68C1 0309               LDA  #9
    68C3 2512               SU   R2
    68C5 17CF68             JNF  _ced2pl11
    68C8 0330               LDA  #0x30
    68CA 0E12               OR   R2
    68CC 18DF68             JMP  _ced2pl10
    68CF 030F   _ced2pl11   LDA  #15
    68D1 2512               SU   R2
    68D3 17DD68             JNF  _ced2pl12
    68D6 0337               LDA  #'A'-10
    68D8 2412               AD   R2
    68DA 18DF68             JMP  _ced2pl10
    68DD 0302   _ced2pl12   LDA  #CHAR_NBR10 ;special character "10"
    68DF 196F31 _ced2pl10   JSR  lcd_out_fch
                            ;2. print | or <-
    68E2 037C               LDA  #'|'
    68E4 1520               TST  ED2_WINX
    68E6 16EB68             JPF  _ced2pl13
    68E9 0303               LDA  #CHAR_ALEFT
    68EB 196F31 _ced2pl13   JSR  lcd_out_fch
                            ;3. print the line
    68EE 0412               LDA  R2
    68F0 021120             LD   R1,ED2_WINX
    68F3 199068             JSR  _c_ed_calcMemLinePtr
    68F6 011025             LD   R0,#37
    68F9 05     _ced2pl17   LAP
    68FA 090C               INC  PTR_L
    68FC 150C               TST  PTR_L
    68FE 170369             JNF  _ced2pl18
    6901 090D               INC  PTR_H
    6903 196F31 _ced2pl18   JSR  lcd_out_fch
    6906 20F968             JLP  _ced2pl17
                            ;print last character '->' only if required 
    6909 031B               LDA  #27
    690B 1420               CMP  ED2_WINX
    690D 037C               LDA  #'|'
    690F 161469             JPF  _ced2pl15
    6912 0304               LDA  #CHAR_ARIGHT
    6914 196F31 _ced2pl15   JSR  lcd_out_fch
    6917 1F                 RTS
                _ced2pl01   ;print head/bottom-line
    6918 011307             LD   R3,#7
    691B 021223             LD   R2,ED2_XPOS
    691E 198468             JSR  _c_ed2_isMenuLine
    6921 162769             JPF  _ced2pl09
    6924 011280             LD   R2,#0x80
    6927 010C30 _ced2pl09   LD   PTR_L,#<NUM_BUF
    692A 010DFE             LD   PTR_H,#>NUM_BUF
    692D 194633             JSR  print_str
    6930 010C12             LD   PTR_L,#<text_ed_headln
    6933 010D79             LD   PTR_H,#>text_ed_headln
    6936 19CE3A _ced2pl02   JSR  lap_inc_ptr
    6939 150E               TST
    693B 16CA3A             JPF  rts_opc
    693E 1512               TST  R2
    6940 176869             JNF  _ced2pl03
    6943 19853B             JSR  is_alpha
    6946 176369             JNF  _ced2pl05  ;convert abc to ABC
    6949 135B               CMP  #'['
    694B 165869             JPF  _ced2pl08
    694E 135D               CMP  #']'
    6950 176F69             JNF  _ced2pl06
    6953 0A12               DEC  R2
    6955 185B69             JMP  _ced2pl07
    6958 021413 _ced2pl08   LD   R4_L,R3
    695B 01051F _ced2pl07   SU   #0x1F      ;convert [/] to </>
    695E 2505   
    6960 186869             JMP  _ced2pl03
    6963 0105DF _ced2pl05   AND  #0xDF
    6966 0D05   
    6968 135D   _ced2pl03   CMP  #']'
    696A 176F69             JNF  _ced2pl06
    696D 0A12               DEC  R2
    696F 196F31 _ced2pl06   JSR  lcd_out_fch
    6972 0913               INC  R3
    6974 183669             JMP  _ced2pl02
                
                _cedit227   ;quit
    6977 199732             JSR  display_clear
                _cedit300
                            ;end of editor code, program execution continues in file forth_words_edit.asm
                ;[File: forth_words_edit.asm]
    697A 19BB5F _ceditend   JSR  c_base
    697D 193E50             JSR  c_store
    6980 18676D             JMP  _c_emptybuffers
                
                ; convert non-printable characters to '?'
                c_mkpr      ;input: buffer-ptr on stack
    6983 1E                 PHL
    6984 190E45             JSR  pop_data_R4
    6987 19213B             JSR  ld_ptr_r4
    698A 011104             LD   R1,#4
    698D 011000             LD   R0,#0
    6990 010620             LD   PAR2,#0x20
    6993 05     _mkpr01     LAP
    6994 090E               INC
    6996 0612               STA  R2
    6998 0B0E               ROL
    699A 16A469             JPF  _mkpr03
    699D 0412               LDA  R2
    699F 1106               SUB  PAR2
    69A1 16A769             JPF  _mkpr04
    69A4 033F   _mkpr03     LDA  #'?'
    69A6 07                 SAP
    69A7 090C   _mkpr04     INC  PTR_L
    69A9 150C               TST  PTR_L
    69AB 17B069             JNF  _mkpr02
    69AE 090D               INC  PTR_H
    69B0 209369 _mkpr02     JLP  _mkpr01
    69B3 0A11               DEC  R1
    69B5 1511               TST  R1
    69B7 179369             JNF  _mkpr01
    69BA 1F                 RTS
                e_edit      ;---------------------------------------------------------------...
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words.asm]
    69BB 000000   DB 0,0,0 ;end-marker
                
                dictionary_5:
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words_basis.asm]
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 2 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 3 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 4 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 5 characters
                ;------------------------------------------------------------------------------
                
                
                            ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
    69BE ED69               DW   e_2over
    69C0 05326F             DB   5,"2over"
    69C3 766572 
    69C6 1E     c_2over     PHL
    69C7 020C95             LD   PTR_L,fPSP
    69CA 010D81             LD   PTR_H,#>DATA_STACK
    69CD 0A0C               DEC  PTR_L
    69CF 0A0C               DEC  PTR_L
    69D1 0A0C               DEC  PTR_L
    69D3 0A0C               DEC  PTR_L
    69D5 0A0C               DEC  PTR_L
    69D7 0A0C               DEC  PTR_L
    69D9 0A0C               DEC  PTR_L
    69DB 0A0C               DEC  PTR_L
    69DD 19CE3A             JSR  lap_inc_ptr
    69E0 0614               STA  R4_L
    69E2 19CE3A             JSR  lap_inc_ptr
    69E5 0615               STA  R4_H
    69E7 19DB44             JSR  push_data_R4
    69EA 182F50             JMP  c_at_ldret
                e_2over     ;------------------------------------------------------------------
                
                            ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
    69ED F869               DW   e_2swap
    69EF 053273             DB   5,"2swap"
    69F2 776170 
    69F5 18AD45 c_2swap     JMP  dstack_2swap
                e_2swap     ;------------------------------------------------------------------
                
                            ; 2DROP ( x1 x2 -- )
    69F8 036A               DW   e_2drop
    69FA 053264             DB   5,"2drop"
    69FD 726F70 
    6A00 183A45 c_2drop     JMP  pop_data_R4_R5
                e_2drop     ;------------------------------------------------------------------
                
                            ; SPACE ( -- )  Print a space character
    6A03 0E6A               DW   e_space
    6A05 057370             DB   5,"space"
    6A08 616365 
    6A0B 181833 c_space     JMP  print_space
                e_space     ;------------------------------------------------------------------
                
                            ; CELL+  ( x -- z )  Advance the address x by the size of one cell
    6A0E 236A               DW   e_cellplus
    6A10 056365             DB   5,"cell+"
    6A13 6C6C2B 
    6A16 1E     c_cellplus  PHL
    6A17 190E45             JSR  pop_data_R4
    6A1A 19F93A             JSR  inc_r4
    6A1D 19F93A             JSR  inc_r4
    6A20 18D744             JMP  push_data_R4_ret
                e_cellplus  ;------------------------------------------------------------------
                
                            ; CELLS  ( x -- z )  Get storage size of x cells
    6A23 2E6A               DW   e_cells
    6A25 056365             DB   5,"cells"
    6A28 6C6C73 
    6A2B 183853 c_cells     JMP  c_2star
                e_cells     ;------------------------------------------------------------------
                
                            ; ALLOT  ( x -- )  Reserve bytes in RAM at HERE
    6A2E 586A               DW   e_allot
    6A30 05616C             DB   5,"allot"
    6A33 6C6F74 
    6A36 1E     c_allot     PHL
    6A37 199559 _c_allot    JSR  c_dup
    6A3A 192671             JSR  c_unused
    6A3D 19F852             JSR  c_ugrtrthan
    6A40 190E45             JSR  pop_data_R4
    6A43 1515               TST  R4_H
    6A45 171D4A             JNF  Error_Mem
    6A48 190E45             JSR  pop_data_R4
    6A4B 0464               LDA  CP_L
    6A4D 2414               AD   R4_L
    6A4F 0664               STA  CP_L
    6A51 0465               LDA  CP_H
    6A53 1015               ADD  R4_H
    6A55 0665               STA  CP_H
    6A57 1F                 RTS
                e_allot     ;------------------------------------------------------------------
                
                            ; does>  The function of DOES> is to specify a run-time action for the "child" words of a defining word.
    6A58 786A               DW   e_doesgt
    6A5A 05646F             DB   5,"does>"
    6A5D 65733E 
                c_doesgt    ;drop return address because does> does not return (=do not save LR to stack)
                            ;use the value in LR to jump to the code that follows the JSR call to does>
    6A60 020C93             LD   PTR_L,DOESH_L
    6A63 020D94             LD   PTR_H,DOESH_H
    6A66 1B0B               PSH  LR_H
    6A68 1B0A               PSH  LR_L
    6A6A 0318               LDA  #0x18
    6A6C 19D93A             JSR  sap_inc_ptr
    6A6F 1C0E               POP
    6A71 19D93A             JSR  sap_inc_ptr
    6A74 1C0E               POP
    6A76 07                 SAP
    6A77 1F                 RTS
                e_doesgt    ;------------------------------------------------------------------
                
                            ; +LOOP
    6A78 896A               DW   e_ploop
    6A7A 852B6C             DB   5+FL_IMMEDIATE,"+loop"
    6A7D 6F6F70 
                c_ploop     ;insert code that calls the loop_code routine
    6A80 011A3B             LD   R7_L,#<ploop_code
    6A83 011B4F             LD   R7_H,#>ploop_code
    6A86 18D15D             JMP  _c_loop_1  ; share the rest of the code with c_loop
                e_ploop     ;------------------------------------------------------------------
                
                            ; LEAVE  Leave a loop
    6A89 AC6A               DW   e_leave
    6A8B 856C65             DB   5+FL_IMMEDIATE,"leave"
    6A8E 617665 
    6A91 1E     c_leave     PHL
                            ;insert code that calls the c_unloop routine
    6A92 011ACA             LD   R7_L,#<c_unloop
    6A95 011B6F             LD   R7_H,#>c_unloop
    6A98 193B4D             JSR  emit_jsr
                            ;insert an unconditional jump to the word behind the loop word
    6A9B 19A244             JSR  lcfs_pop
    6A9E 198E44             JSR  lcfs_push
    6AA1 0318               LDA  #0x18
    6AA3 19134E             JSR  emit_code
    6AA6 19DE40             JSR  dec_r4
    6AA9 18FD50             JMP  emit_R4_ret
                e_leave     ;------------------------------------------------------------------
                
                            ; BEGIN  ( -- )  Begin a program flow description
    6AAC B76A               DW   e_begin
    6AAE 856265             DB   5+FL_IMMEDIATE,"begin"
    6AB1 67696E 
    6AB4 185944 c_begin     JMP  ccfs_push_cp
                e_begin     ;------------------------------------------------------------------
                
                            ; AGAIN  ( -- )  Continue program execution at previous BEGIN
    6AB7 CB6A               DW   e_again
    6AB9 856167             DB   5+FL_IMMEDIATE,"again"
    6ABC 61696E 
    6ABF 1E     c_again     PHL
    6AC0 197344 _c_again1   JSR  ccfs_pop
    6AC3 0318               LDA  #0x18
    6AC5 19134E _c_again2   JSR  emit_code
    6AC8 18FD50             JMP  emit_R4_ret
                e_again     ;------------------------------------------------------------------
                
                            ; UNTIL  ( x -- )  If all bits of x are zero, continue execution at previous BEGIN
    6ACB E56A               DW   e_until
    6ACD 85756E             DB   5+FL_IMMEDIATE,"until"
    6AD0 74696C 
    6AD3 1E     c_until     PHL
    6AD4 011A7F             LD   R7_L,#<until_code
    6AD7 011B4F             LD   R7_H,#>until_code
    6ADA 193B4D             JSR  emit_jsr
    6ADD 197344             JSR  ccfs_pop
    6AE0 0316               LDA  #0x16
    6AE2 18C56A             JMP  _c_again2
                e_until     ;------------------------------------------------------------------
                
                            ; WHILE  ( x -- )  If all bits of x are zero, continue execution after WHILE, otherwise leave the loop.
    6AE5 026B               DW   e_while
    6AE7 857768             DB   5+FL_IMMEDIATE,"while"
    6AEA 696C65 
    6AED 1E     c_while     PHL
    6AEE 011A7F             LD   R7_L,#<until_code  ; share the until_code
    6AF1 011B4F             LD   R7_H,#>until_code
    6AF4 193B4D             JSR  emit_jsr
    6AF7 0316               LDA  #0x16
    6AF9 19134E             JSR  emit_code
    6AFC 195944             JSR  ccfs_push_cp
    6AFF 18C354             JMP  _c_do_2
                e_while     ;------------------------------------------------------------------
                
                            ; ENDOF  ( -- )  End an OF-ENDOF construct
    6B02 256B               DW   e_endof
    6B04 85656E             DB   5+FL_IMMEDIATE,"endof"
    6B07 646F66 
    6B0A 1E     c_endof     PHL
    6B0B 197344             JSR  ccfs_pop
    6B0E 19423B             JSR  psh_r4
    6B11 197344             JSR  ccfs_pop
    6B14 195F44             JSR  ccfs_push
    6B17 0318               LDA  #0x18
    6B19 021A14             LD   R7_L,R4_L
    6B1C 021B15             LD   R7_H,R4_H
    6B1F 193D4D             JSR  emit_opaadr
    6B22 18B05D             JMP  _c_else1    ;share the rest of the code with ELSE
                e_endof     ;------------------------------------------------------------------
                
                            ; CHAR+  ( c-addr1 -- c-addr2 )
    6B25 376B               DW   e_charplus
    6B27 056368             DB   5,"char+"
    6B2A 61722B 
    6B2D 1E     c_charplus  PHL
    6B2E 190E45             JSR  pop_data_R4
    6B31 19F93A             JSR  inc_r4
    6B34 18D744             JMP  push_data_R4_ret
                e_charplus  ;------------------------------------------------------------------
                
                            ; CHARS  ( n1 -- n2 )
    6B37 406B               DW   e_chars
    6B39 056368             DB   5,"chars"
    6B3C 617273 
    6B3F 1A     c_chars     RET
                e_chars     ;------------------------------------------------------------------
                
                            ; COUNT  ( c-addr1 -- c-addr2 u )
    6B40 5B6B               DW   e_count
    6B42 05636F             DB   5,"count"
    6B45 756E74 
    6B48 1E     c_count     PHL
    6B49 190E45             JSR  pop_data_R4
    6B4C 19213B             JSR  ld_ptr_r4
    6B4F 05                 LAP
    6B50 0616               STA  R5_L
    6B52 011700             LD   R5_H,#0
    6B55 19F93A             JSR  inc_r4
    6B58 18F644             JMP  push_data_R4_R5_ret
                e_count     ;------------------------------------------------------------------
                
                            ; FALSE  ( -- false )
    6B5B 666B               DW   e_false
    6B5D 056661             DB   5,"false"
    6B60 6C7365 
    6B63 18C944 c_false     JMP  push_data_zero
                e_false     ;------------------------------------------------------------------
                
                            ; DEPTH  ( -- n )
    6B66 7A6B               DW   e_depth
    6B68 056465             DB   5,"depth"
    6B6B 707468 
    6B6E 021495 c_depth     LD   R4_L,fPSP
    6B71 23                 CLC
    6B72 0C14               ROR  R4_L
    6B74 011500             LD   R4_H,#0
    6B77 18DB44             JMP  push_data_R4
                e_depth     ;------------------------------------------------------------------
                
                            ; */MOD  ( n1 n2 n3 -- n4 n5 )
    6B7A A76B               DW   e_ssmod
    6B7C 052A2F             DB   5,"*/mod"
    6B7F 6D6F64 
    6B82 1E     c_ssmod     PHL
    6B83 190E45             JSR  pop_data_R4
    6B86 021814             LD   R6_L,R4_L
    6B89 021915             LD   R6_H,R4_H
    6B8C 193A45             JSR  pop_data_R4_R5
    6B8F 190A43             JSR  multiply_s
    6B92 190A42             JSR  div_i32i16
    6B95 193942             JSR  div_i32_crem
    6B98 021614             LD   R5_L,R4_L
    6B9B 021715             LD   R5_H,R4_H
    6B9E 021418             LD   R4_L,R6_L
    6BA1 021519             LD   R4_H,R6_H
    6BA4 18F644             JMP  push_data_R4_R5_ret
                e_ssmod     ;------------------------------------------------------------------
                
                            ; VALUE  ( x "<spaces>name" -- )
    6BA7 C76B               DW   e_value
    6BA9 057661             DB   5,"value"
    6BAC 6C7565 
    6BAF 1E     c_value     PHL
    6BB0 19B66F             JSR  c_create  ;VALUE is defined as ": VALUE CREATE , DOES> @ ;"
    6BB3 0300               LDA  #0        ;My4TH definition is ": VALUE CREATE 0 c, , DOES> @ ;"
    6BB5 19134E             JSR  emit_code ;emit a flag-byte that shows the TO word that only one 16-bit value can be stored here
    6BB8 19F950             JSR  c_comma
    6BBB 19606A             JSR  c_doesgt
    6BBE 190E45             JSR  pop_data_R4
    6BC1 19F93A             JSR  inc_r4
    6BC4 182C50             JMP  c_at_ldpret
                e_value     ;------------------------------------------------------------------
                
                            ; ALIGN  ( -- )
    6BC7 D06B               DW   e_align
    6BC9 05616C             DB   5,"align"
    6BCC 69676E 
    6BCF 1A     c_align     RET
                e_align     ;------------------------------------------------------------------
                
                            ; ABORT  ( -- )
    6BD0 E06B               DW   e_abort
    6BD2 056162             DB   5,"abort"
    6BD5 6F7274 
                c_abort     PRINT text_abort
    6BD8 198633           JSR  printstrm
    6BDB BE               DB   <text_abort
    6BDC 78               DB   >text_abort
    6BDD 185447             JMP  abort_restart
                e_abort     ;------------------------------------------------------------------
                
                            ; WORDS  ( -- )
    6BE0 426C               DW   e_words
    6BE2 05776F             DB   5,"words"
    6BE5 726473 
    6BE8 1E     c_words     PHL
    6BE9 011264             LD   R2,#100
    6BEC 011101             LD   R1,#1
    6BEF 19024C _cwords01   JSR  chooseDictionary
    6BF2 05                 LAP
    6BF3 0618               STA  R6_L
    6BF5 090C               INC  PTR_L
    6BF7 05                 LAP
    6BF8 0619               STA  R6_H
                            ;loop over all dictionary entries
                            ;R6 points to the header of the current word.
    6BFA 192F3B _cwords02   JSR  ld_ptr_r6
    6BFD 19CE3A             JSR  lap_inc_ptr
    6C00 0618               STA  R6_L
    6C02 19CE3A             JSR  lap_inc_ptr
    6C05 0619               STA  R6_H       ;R6: ptr to next entry in the dictionary
    6C07 19CE3A             JSR  lap_inc_ptr
    6C0A 01051F             AND  #0x1F      ;mask out bits 5-7, they are FLAGs for other purposes
    6C0D 0D05   
    6C0F 0610               STA  R0         ;string length
    6C11 1510               TST  R0
    6C13 16366C             JPF   _cwords03 ;jump if end of dictionary
                            ;start a new line if line is already too long
    6C16 0437               LDA  LIB_DISPMAXX
    6C18 2512               SU   R2
    6C1A 16236C             JPF  _cwords05
    6C1D 011212             LD   R2,#18
    6C20 192233             JSR  print_nl
                _cwords05   ;print the word
    6C23 19CE3A             JSR  lap_inc_ptr
    6C26 192433             JSR  print_char
    6C29 0912               INC  R2
    6C2B 20236C             JLP  _cwords05
    6C2E 191833             JSR  print_space
    6C31 0912               INC  R2
    6C33 18FA6B             JMP  _cwords02
                _cwords03   ;next dictionary
    6C36 0911               INC  R1
    6C38 0309               LDA  #9
    6C3A 1411               CMP  R1
    6C3C 17EF6B             JNF  _cwords01
    6C3F 183D61             JMP  printnl_rts
                e_words     ;------------------------------------------------------------------
                
                            ; ERASE  ( addr u -- )
    6C42 536C               DW   e_erase
    6C44 056572             DB   5,"erase"
    6C47 617365 
    6C4A 1E     c_erase     PHL
    6C4B 195945             JSR  pop_data_R5_R4
    6C4E 0300               LDA  #0
    6C50 18B85E             JMP  _c_fill_4
                e_erase     ;------------------------------------------------------------------
                
                            ; PARSE  ( char "ccc<char>" -- c-addr u )  Parse ccc delimited by the delimiter char.
    6C53 8D6C               DW   e_parse
    6C55 057061             DB   5,"parse"
    6C58 727365 
    6C5B 1E     c_parse     PHL
    6C5C 199249 _c_parse    JSR  skipSpaces
    6C5F 192445             JSR  pop_data_R5
    6C62 19BF49             JSR  push_data_inptr
    6C65 011000             LD   R0,#0
    6C68 19B849             JSR  ld_ptr_inptr
    6C6B 05     _c_parse1   LAP
    6C6C 150E               TST
    6C6E 167E6C             JPF  _c_parse3
    6C71 19DA3A             JSR  inc_ptr
    6C74 1416               CMP  R5_L
    6C76 16856C             JPF  _c_parse2
    6C79 0910               INC  R0
    6C7B 186B6C             JMP  _c_parse1
    6C7E 0416   _c_parse3   LDA  R5_L
    6C80 1320               CMP  #0x20
    6C82 17234A             JNF  Error_Syntax
    6C85 19B149 _c_parse2   JSR  ld_inptr_ptr
    6C88 0410               LDA  R0
    6C8A 18D244             JMP  push_data_accu_ret
                e_parse     ;------------------------------------------------------------------
                
                            ; >BODY  ( xt -- a-addr )   a-addr is the data-field address corresponding to xt.
    6C8D A26C               DW   e_tobody
    6C8F 053E62             DB   5,">body"
    6C92 6F6479 
    6C95 1E     c_tobody    PHL
    6C96 01140D             LD   R4_L,#13  ;16
    6C99 011500             LD   R4_H,#0
    6C9C 19DB44             JSR  push_data_R4
    6C9F 189950             JMP  _c_sum16
                e_tobody    ;------------------------------------------------------------------
                
                            ; STATE
    6CA2 B36C               DW   e_state
    6CA4 057374             DB   5,"state"
    6CA7 617465 
    6CAA 01149A c_state     LD   R4_L,#STATE
    6CAD 011580 ret_regadr  LD   R4_H,#REGPAGE_HI
    6CB0 18DB44             JMP  push_data_R4
                e_state     ;------------------------------------------------------------------
                
                            ; DEFER  ( "name" -- )   create a deferred word
    6CB3 CF6C               DW   e_defer
    6CB5 056465             DB   5,"defer"
    6CB8 666572 
    6CBB 1E     c_defer     PHL
    6CBC 159A               TST  STATE
    6CBE 17234A             JNF  Error_Syntax
    6CC1 190F4D             JSR  begin_add_new_word
    6CC4 010CCD             LD   PTR_L,#<ret_opc
    6CC7 010D3A             LD   PTR_H,#>ret_opc
    6CCA 0318               LDA  #0x18
    6CCC 182E4D             JMP  add_JmpOrJsr_ret
                e_defer     ;------------------------------------------------------------------
                
                            ; AT-XY  ( xpos ypos -- )   set cursor to screen position
    6CCF E56C               DW   e_at_xy
    6CD1 056174             DB   5,"at-xy"
    6CD4 2D7879 
    6CD7 1E     c_at_xy     PHL
    6CD8 193A45             JSR  pop_data_R4_R5
    6CDB 021016             LD   R0,R5_L
    6CDE 021114             LD   R1,R4_L
    6CE1 19BF32 _c_atxy_rts JSR  display_gotoxy
    6CE4 1F                 RTS
                e_at_xy     ;------------------------------------------------------------------
                
                            ; HOLDS  ( c-addr u -- )
    6CE5 176D               DW   e_holds
    6CE7 05686F             DB   5,"holds"
    6CEA 6C6473 
    6CED 1E     c_holds     PHL
    6CEE 190E45             JSR  pop_data_R4
    6CF1 19DB44             JSR  push_data_R4
    6CF4 1B14               PSH  R4_L
    6CF6 199850             JSR  c_sum16
    6CF9 1C0E   _cholds01   POP
    6CFB 150E               TST
    6CFD 16136D             JPF  _cholds02
    6D00 0A0E               DEC
    6D02 1B0E               PSH
    6D04 191353             JSR  c_1minus
    6D07 199559             JSR  c_dup
    6D0A 192850             JSR  c_at
    6D0D 19535E             JSR  c_hold
    6D10 18F96C             JMP  _cholds01
    6D13 190E45 _cholds02   JSR  pop_data_R4      
    6D16 1F                 RTS
                e_holds     ;------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 6 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 7 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 8 characters
                ;------------------------------------------------------------------------------
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_block.asm]
                
                
                            ; FLUSH  ( -- )  Perform the function of SAVE-BUFFERS, then unassign all block buffers.
    6D17 266D               DW   e_flush
    6D19 05666C             DB   5,"flush"
    6D1C 757368 
    6D1F 1E     c_flush     PHL
    6D20 193462 _c_flush    JSR  c_savebuffers
    6D23 18676D             JMP  _c_emptybuffers
                e_flush     ;------------------------------------------------------------------
                
                
                            ; BLOCK  ( u -- a-addr )  Load a data block from EEPROM into memory
    6D26 566D               DW   e_block
    6D28 05626C             DB   5,"block"
    6D2B 6F636B 
                            ; "blk_alloc dup blk_struct cell+ @ = if drop else
                            ;  save-buffers dup blk_struct cell+ ! blk_struct @ eepload then blk_struct @"
    6D2E 1E     c_block     PHL
    6D2F 199F72             JSR  _cbuf03  ;share code with BUFFER
    6D32 168172             JPF  _cbuf04  ;jump if same block number
                            ;other block number
    6D35 199559             JSR  c_dup
    6D38 198772             JSR  _cbuf05  ;share code with BUFFER
                            ;implementation of c_eepload:
    6D3B 190E45             JSR  pop_data_R4  ; get addr and push it to the processor stack
    6D3E 19423B             JSR  psh_r4
                            ;prepare loading the block
    6D41 19AC4F             JSR  prep_eepblk
    6D44 19C64F             JSR  feep_start_read
                            ;load the block from EEPROM
    6D47 19563B             JSR  pop_ptr
    6D4A 19BF4F             JSR  ld_R5_1024
    6D4D 19AA38             JSR  eeprom_read_block
                            ;finished
    6D50 19DE2D             JSR  i2c_stop
    6D53 189672             JMP  _cbuf02
                e_block     ;------------------------------------------------------------------
                
                
                            ; EMPTY-BUFFERS  ( -- ) 
    6D56 6D6D               DW   e_emptybuffers
    6D58 0D656D             DB   13,"empty-buffers"
    6D5B 707479 
    6D5E 2D6275 
    6D61 666665 
    6D64 7273   
                c_emptybuffers  ; "blk_struct cell+ 2 cells erase"
    6D66 1E                 PHL
                _c_emptybuffers
    6D67 197A62             JSR  _c_blk_free
    6D6A 18A562             JMP  _empty_blkstruct
                e_emptybuffers ;---------------------------------------------------------------
                ;[File: forth_allwords.asm]
                ;[File: forth_words_my4th.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for My4TH
                ;------------------------------------------------------------------------------
                
                ;#ifdef WORDS_LEN_2
                ;            ; ,> ( "hexbytestream" -- )  Compile machine code to currently compiled word
                ;            DW   e_mgt
                ;            DB   2+FL_IMMEDIATE,",>"
                ;c_mgt       PHL
                ;            JSR  ld_ptr_inptr
                ;_c_mgt_1    LAP
                ;            TST
                ;            JPF  _c_mgt_2
                ;            CMP  #0x20
                ;            JPF  _c_mgt_2
                ;            JSR  inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            ROL
                ;            ROL
                ;            ROL
                ;            ROL
                ;            STA  R0
                ;            JSR  lap_inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            OR   R0
                ;            JSR  emit_code
                ;            JMP  _c_mgt_1
                ;_c_mgt_2    JSR  ld_inptr_ptr
                ;            RTS
                ;e_mgt       ;------------------------------------------------------------------
                ;#endif
                
                ;#ifdef WORDS_LEN_3
                ;            ; >SY  Convert index number to system call address
                ;            DW   e_2system
                ;            DB   3,">sy"
                ;c_2system   PHL
                ;            JSR  pop_data_R4
                ;            LDA  #<tab_syscalls
                ;            CLC
                ;            ROL  R4_L
                ;            ADD  R4_L
                ;            STA  PTR_L
                ;            LD   PTR_H,#>tab_syscalls
                ;            JSR  lap_inc_ptr
                ;            STA  R4_L
                ;            LAP
                ;            STA  R4_H
                ;            JMP  push_data_R4_ret
                ;e_2system   ;------------------------------------------------------------------
                ;#endif
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                            ; RDROP   remove one word from return stack
    6D6D 7A6D               DW   e_rdrop
    6D6F 057264             DB   5,"rdrop"
    6D72 726F70 
    6D75 0A97   c_rdrop     DEC  RETSP
    6D77 0A97               DEC  RETSP
    6D79 1A                 RET
                e_rdrop     ;------------------------------------------------------------------
                
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_mynor.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for MyNOR
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_bload.asm]
                ;------------------------------------------------------------------------------
                ;  Binary Driver Loader
                ;------------------------------------------------------------------------------
                ;
                ;  This module can load and relocate a binary driver image into RAM memory.
                ;
                ;  The binary driver image must begin with this header:
                ;
                ;    1. byte :  ID 0x1B
                ;    2. byte :  reserved, must be 0
                ;    3. byte :  file size, bits 0-7
                ;    4. byte :  file size, bits 8-15
                ;    5. byte :  module compile address, bits 0-7
                ;    6. byte :  module compile address, bits 8-15
                ;    7. byte :  offset to the startup function, bits 0-7   (can be 0 if not used)
                ;    8. byte :  offset to the startup function, bits 8-15  (can be 0 if not used)
                ;    9. byte :  size of the following data section, bits 0-7
                ;   10. byte :  size of the following data section, bits 8-15
                ;
                ;  This module relocates all address it finds in the code section.
                ;  Data pointers must be written as a pair of " LD PTR_L,# / LD PTR_H,# ",
                ;  otherwise they won't be recognized.
                ;
                ;------------------------------------------------------------------------------
                
                
                BDL_MEMSTART    SET LIB_BUF+0  ; binary blob start address in SRAM
                BDL_FILESIZE    SET LIB_BUF+2  ; binary blob size
                BDL_SRCADDR     SET LIB_BUF+4  ; original compile address of the binary
                BDL_DATASIZE    SET LIB_BUF+6  ; size of the data section
                BDL_EXPORTS     SET LIB_BUF+8  ; pointer to list of exported words
                BDL_IMPORTS     SET LIB_BUF+10 ; pointer to list of imported words
                BDL_FSTARTOFS   SET LIB_BUF+12 ; offset to the start function
                
                            ; BLOAD ( n -- )   Load a binary driver from block n and following blocks
    6D7A 616F               DW   e_bload
    6D7C 05626C             DB   5,"bload"
    6D7F 6F6164 
    6D82 1E     c_bload     PHL
                            ;----------------------------------------------
                            ; Load the header and then the whole file
                            ;----------------------------------------------
                
                            ;get block number from stack, but keep the original on stack
    6D83 199559             JSR  c_dup
    6D86 190E45             JSR  pop_data_R4
    6D89 193038             JSR  fblockToEepromAddr
    6D8C 16264A             JPF  Error_Value
                            ;read first 14 bytes from EEPROM (the beginning of the program header)
    6D8F 199A38             JSR  eeprom_start_read
    6D92 163F4A             JPF  Error_InOut
    6D95 01160E             LD   R5_L,#14
    6D98 011700             LD   R5_H,#0
    6D9B 010C20             LD   PTR_L,#LIB_BUF
    6D9E 010D80             LD   PTR_H,#>REGPAGE
    6DA1 19AA38             JSR  eeprom_read_block
    6DA4 190039             JSR  eeprom_stop
    6DA7 0420               LDA  LIB_BUF+0
    6DA9 131B               CMP  #BIN_HDR_FLAG
    6DAB 17F958             JNF  _c_loadferr
                            ;store the start address of the binrary blob in memory in LIB_BUF+0/1
    6DAE 022064             LD   LIB_BUF+0,CP_L
    6DB1 022165             LD   LIB_BUF+1,CP_H
                            ;allocate the required memory, LIB_BUF+2/3 contains the size of the binary image in the EEPROM
    6DB4 021422             LD   R4_L,LIB_BUF+2
    6DB7 021523             LD   R4_H,LIB_BUF+3
    6DBA 19DB44             JSR  push_data_R4
    6DBD 19366A             JSR  c_allot
                            ;load R6 with the size of the binary image and PTR with the memory destination address
    6DC0 020C20             LD   PTR_L,LIB_BUF+0
    6DC3 020D21             LD   PTR_H,LIB_BUF+1
    6DC6 021822             LD   R6_L,LIB_BUF+2
    6DC9 021923             LD   R6_H,LIB_BUF+3
                            ;now load the whole binary blob into memory (the block number is on the data stack)
    6DCC 190159             JSR  loadForthBlocksToMemory
                            ;NOTE: the program is now in memory,
                            ;and the whole program header is also stored in LIB_BUF - LIB_BUF+13
                
                            ;----------------------------------------------
                            ; Correct memory addresses in the code
                            ;----------------------------------------------
                
                            ;calculate code offset, put offset into R7
    6DCF 0420               LDA  BDL_MEMSTART
    6DD1 2524               SU   BDL_SRCADDR
    6DD3 061A               STA  R7_L
    6DD5 0421               LDA  BDL_MEMSTART+1
    6DD7 1125               SUB  BDL_SRCADDR+1
    6DD9 061B               STA  R7_H
                            ;re-locate the code
                            ;get ptr to code section into R4
    6DDB 0420               LDA  BDL_MEMSTART
    6DDD 2426               AD   BDL_DATASIZE
    6DDF 0614               STA  R4_L
    6DE1 0421               LDA  BDL_MEMSTART+1
    6DE3 1027               ADD  BDL_DATASIZE+1
    6DE5 0615               STA  R4_H
                            ;put size of code section -1 into R5
                            ;the end of the code is reached when R5_H is 0xFF
    6DE7 23                 CLC
    6DE8 0422               LDA  BDL_FILESIZE
    6DEA 1126               SUB  BDL_DATASIZE
    6DEC 0616               STA  R5_L
    6DEE 0423               LDA  BDL_FILESIZE+1
    6DF0 1127               SUB  BDL_DATASIZE+1
    6DF2 0617               STA  R5_H
                            ;loop over all the code
    6DF4 19213B _binld01    JSR  ld_ptr_r4
    6DF7 05                 LAP
    6DF8 0610               STA  R0
    6DFA 060C               STA  PTR_L
    6DFC 010D7B             LD   PTR_H,#>tab_opcode
    6DFF 05                 LAP
    6E00 0611               STA  R1
    6E02 0B0E               ROL
    6E04 17766E             JNF  _binld02
                            ;the op-code must be modified
    6E07 0410               LDA  R0
                            ;test for LD PTR_L,#
    6E09 1301               CMP  #0x01
    6E0B 17526E             JNF  _binld07
    6E0E 19213B             JSR  ld_ptr_r4
    6E11 19E43A             JSR  inc_ptr_lap
    6E14 130C               CMP  #PTR_L
    6E16 17726E             JNF  _binld10
    6E19 19E43A             JSR  inc_ptr_lap
    6E1C 0618               STA  R6_L
    6E1E 19E43A             JSR  inc_ptr_lap
    6E21 1301               CMP  #0x01
    6E23 17726E             JNF  _binld10
    6E26 19E43A             JSR  inc_ptr_lap
    6E29 130D               CMP  #PTR_H
    6E2B 17726E             JNF  _binld10
                            ;it's "load pointer"
    6E2E 19E43A             JSR  inc_ptr_lap
    6E31 0619               STA  R6_H
    6E33 0B0E               ROL
    6E35 17726E             JNF  _binld10 ;don't touch this pointer, it points into ROM code
                            ;R6 = original address
    6E38 19536F             JSR  _bl_translate
    6E3B 19213B             JSR  ld_ptr_r4
    6E3E 19DA3A             JSR  inc_ptr
    6E41 19DA3A             JSR  inc_ptr
    6E44 0418               LDA  R6_L
    6E46 19D93A             JSR  sap_inc_ptr
    6E49 19DA3A             JSR  inc_ptr
    6E4C 19DA3A             JSR  inc_ptr
    6E4F 186F6E             JMP  _binld08
                _binld07    ;it's a jump instruction
    6E52 19213B             JSR  ld_ptr_r4
    6E55 19E43A             JSR  inc_ptr_lap
    6E58 0618               STA  R6_L
    6E5A 19E43A             JSR  inc_ptr_lap
    6E5D 0619               STA  R6_H
    6E5F 0B0E               ROL
    6E61 17726E             JNF  _binld10 ;don't touch this pointer, it points into ROM code
    6E64 19536F             JSR  _bl_translate
    6E67 0418               LDA  R6_L
    6E69 19EF3A             JSR  dec_ptr
    6E6C 19D93A             JSR  sap_inc_ptr
    6E6F 0419   _binld08    LDA  R6_H
    6E71 07                 SAP
                            ;finished with this op-code
    6E72 0411   _binld10    LDA  R1
    6E74 0B0E               ROL
                _binld02    ;skip bytes and continue with next op-code
    6E76 23                 CLC
    6E77 0C0E               ROR
    6E79 0610               STA  R0
    6E7B 0914   _binld03    INC  R4_L
    6E7D 1514               TST  R4_L
    6E7F 17846E             JNF  _binld04
    6E82 0915               INC  R4_H
    6E84 1516   _binld04    TST  R5_L
    6E86 17906E             JNF  _binld05
    6E89 1517               TST  R5_H
    6E8B 16986E             JPF  _binld06
    6E8E 0A17               DEC  R5_H
    6E90 0A16   _binld05    DEC  R5_L
    6E92 207B6E             JLP  _binld03
    6E95 18F46D             JMP  _binld01
                _binld06    ;Code translated.
                
                            ;----------------------------------------------
                            ; Walk through the list of imports
                            ;----------------------------------------------
                
    6E98 042A               LDA  BDL_IMPORTS
    6E9A 241A               AD   R7_L
    6E9C 060C               STA  PTR_L
    6E9E 042B               LDA  BDL_IMPORTS+1
    6EA0 241B               AD   R7_H
    6EA2 060D               STA  PTR_H
    6EA4 19513B             JSR  psh_r7
    6EA7 19CE3A _binld20    JSR  lap_inc_ptr
    6EAA 150E               TST
    6EAC 16EB6E             JPF  _binld21
    6EAF 193D3B             JSR  psh_ptr
    6EB2 19DA3A             JSR  inc_ptr
    6EB5 19DA3A             JSR  inc_ptr
    6EB8 19124C             JSR  search_forth_word
    6EBB 17D26E             JNF  _binld22
                            PRINT text_errImport
    6EBE 198633           JSR  printstrm
    6EC1 A6               DB   <text_errImport
    6EC2 78               DB   >text_errImport
    6EC3 19563B             JSR  pop_ptr
    6EC6 19DA3A             JSR  inc_ptr
    6EC9 19DA3A             JSR  inc_ptr
    6ECC 194633             JSR  print_str
    6ECF 18394A             JMP  _err_prnl
    6ED2 02160C _binld22    LD   R5_L,PTR_L
    6ED5 02170D             LD   R5_H,PTR_H
    6ED8 19563B             JSR  pop_ptr
    6EDB 0416               LDA  R5_L
    6EDD 19D93A             JSR  sap_inc_ptr
    6EE0 0417               LDA  R5_H
    6EE2 19D93A             JSR  sap_inc_ptr
    6EE5 192C3C             JSR  strlen
    6EE8 18A76E             JMP  _binld20
    6EEB 196A3B _binld21    JSR  pop_r7
                
                            ;----------------------------------------------
                            ; Walk through the list of exports
                            ;----------------------------------------------
                
    6EEE 19C849             JSR  push_inptr
    6EF1 0428               LDA  BDL_EXPORTS
    6EF3 241A               AD   R7_L
    6EF5 060C               STA  PTR_L
    6EF7 0429               LDA  BDL_EXPORTS+1
    6EF9 241B               AD   R7_H
    6EFB 060D               STA  PTR_H
    6EFD 19CE3A _binld23    JSR  lap_inc_ptr
    6F00 0618               STA  R6_L
    6F02 19CE3A             JSR  lap_inc_ptr
    6F05 150E               TST
    6F07 163B6F             JPF  _binld24
    6F0A 0619               STA  R6_H
    6F0C 19536F             JSR  _bl_translate
    6F0F 19B149             JSR  ld_inptr_ptr
    6F12 190F4D             JSR  begin_add_new_word
    6F15 0318               LDA  #0x18
    6F17 19134E             JSR  emit_code
    6F1A 0418               LDA  R6_L
    6F1C 19134E             JSR  emit_code
    6F1F 0419               LDA  R6_H
    6F21 19134E             JSR  emit_code
    6F24 19B849             JSR  ld_ptr_inptr
    6F27 19CE3A             JSR  lap_inc_ptr   ; name-end-marker can be 0x00 or 0x20
    6F2A 150E               TST
    6F2C 16FD6E             JPF  _binld23
    6F2F 193D3B             JSR  psh_ptr
    6F32 19AB51             JSR  c_immediate   ; if marker is 0x20, this is an immediate word
    6F35 19563B             JSR  pop_ptr
    6F38 18FD6E             JMP  _binld23
    6F3B 19DE49 _binld24    JSR  pop_inptr
                
                            ;----------------------------------------------
                            ; Now execute the init function
                            ;----------------------------------------------
                
    6F3E 152D               TST  BDL_FSTARTOFS+1
    6F40 16526F             JPF  _binld09
    6F43 02182C             LD   R6_L,BDL_FSTARTOFS
    6F46 02192D             LD   R6_H,BDL_FSTARTOFS+1
    6F49 19536F             JSR  _bl_translate
    6F4C 011718             LD   R5_H,#0x18
    6F4F 191780             JSR  REGPAGE+R5_H
                _binld09    ;back from init function
                            ;all done
    6F52 1F                 RTS
                
                _bl_translate:
                            ;Translate memory address in R6 to new, correct address.
    6F53 1E                 PHL
    6F54 041A               LDA  R7_L
    6F56 2418               AD   R6_L
    6F58 0618               STA  R6_L
    6F5A 041B               LDA  R7_H
    6F5C 1019               ADD  R6_H
    6F5E 0619               STA  R6_H
    6F60 1F                 RTS
                
                e_bload     ;------------------------------------------------------------------
                ;[File: forth_allwords.asm]
                ;[File: forth_words_edit.asm]
                
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words.asm]
    6F61 000000   DB 0,0,0 ;end-marker
                
                dictionary_6:
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words_basis.asm]
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 2 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 3 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 4 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 5 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 6 characters
                ;------------------------------------------------------------------------------
                
                
                            ; negate ( x -- -x )  Negate the number on top of the stack
    6F64 7A6F               DW   e_negate
    6F66 066E65             DB   6,"negate"
    6F69 676174 
    6F6C 65     
    6F6D 1E     c_negate    PHL
    6F6E 190E45             JSR  pop_data_R4
    6F71 19AE40 _c_negate_1 JSR  inv_r4
    6F74 19F93A             JSR  inc_r4
    6F77 18D744             JMP  push_data_R4_ret
                e_negate    ;------------------------------------------------------------------
                
                            ; invert ( x -- -x )  Invert the number on top of the stack
    6F7A 8D6F               DW   e_invert
    6F7C 06696E             DB   6,"invert"
    6F7F 766572 
    6F82 74     
    6F83 1E     c_invert    PHL
    6F84 190E45 _c_invert   JSR  pop_data_R4
    6F87 19AE40             JSR  inv_r4
    6F8A 18D744             JMP  push_data_R4_ret
                e_invert    ;------------------------------------------------------------------
                
                            ; spaces ( x -- )  Print some space characters
    6F8D AD6F               DW   e_spaces
    6F8F 067370             DB   6,"spaces"
    6F92 616365 
    6F95 73     
    6F96 1E     c_spaces    PHL
    6F97 190E45             JSR  pop_data_R4
    6F9A 1514   _c_space_2  TST  R4_L
    6F9C 17A46F             JNF  _c_space_1
    6F9F 1515               TST  R4_H
    6FA1 16CA3A             JPF  return
    6FA4 191833 _c_space_1  JSR  print_space
    6FA7 19DE40             JSR  dec_r4
    6FAA 179A6F             JNF  _c_space_2
                e_spaces    ;------------------------------------------------------------------
                
                            ; create  ( -- )  Create a new dictionary entry (for variables and data)
    6FAD C16F               DW   e_create
    6FAF 066372             DB   6,"create"
    6FB2 656174 
    6FB5 65     
    6FB6 1E     c_create    PHL
    6FB7 190F4D             JSR  begin_add_new_word
    6FBA 19244D             JSR  add_word_entry_code
    6FBD 194B4D             JSR  write_create_code
    6FC0 1F                 RTS
                e_create    ;------------------------------------------------------------------
                
                            ; UNLOOP  Remove one set of loop control parameters from the loop control flow stack
    6FC1 D36F               DW   e_unloop
    6FC3 06756E             DB   6,"unloop"
    6FC6 6C6F6F 
    6FC9 70     
    6FCA 0999   c_unloop    INC  LCFSP
    6FCC 0999               INC  LCFSP
    6FCE 0999               INC  LCFSP
    6FD0 0999               INC  LCFSP
    6FD2 1A                 RET
                e_unloop    ;------------------------------------------------------------------
                
                            ; REPEAT  ( -- )  Continue program execution at previous BEGIN
    6FD3 FA6F               DW   e_repeat
    6FD5 867265             DB   6+FL_IMMEDIATE,"repeat"
    6FD8 706561 
    6FDB 74     
    6FDC 1E     c_repeat    PHL
    6FDD 197344             JSR  ccfs_pop
    6FE0 19213B             JSR  ld_ptr_r4
    6FE3 193E4E             JSR  ld_r4_cp
    6FE6 19F93A             JSR  inc_r4
    6FE9 19F93A             JSR  inc_r4
    6FEC 19F93A             JSR  inc_r4
    6FEF 0414               LDA  R4_L
    6FF1 19D93A             JSR  sap_inc_ptr
    6FF4 0415               LDA  R4_H
    6FF6 07                 SAP
    6FF7 18C06A             JMP  _c_again1
                e_repeat    ;------------------------------------------------------------------
                
                            ; LSHIFT  ( x1 u -- x2 )   Perform a logical left shift of u bit-places on x1, giving x2.
    6FFA 1570               DW   e_lshift
    6FFC 066C73             DB   6,"lshift"
    6FFF 686966 
    7002 74     
    7003 1E     c_lshift    PHL
    7004 195945             JSR  pop_data_R5_R4
    7007 1516   _c_lshift_1 TST  R5_L
    7009 16D744             JPF  push_data_R4_ret
                            ;CLC
    700C 0B14               ROL  R4_L
    700E 0B15               ROL  R4_H
    7010 0A16               DEC  R5_L
    7012 180770             JMP  _c_lshift_1
                e_lshift    ;------------------------------------------------------------------
                
                            ; RSHIFT  ( x1 u -- x2 )   Perform a logical right shift of u bit-places on x1, giving x2.
    7015 3070               DW   e_rshift
    7017 067273             DB   6,"rshift"
    701A 686966 
    701D 74     
    701E 1E     c_rshift    PHL
    701F 195945             JSR  pop_data_R5_R4
    7022 1516   _c_rshift_1 TST  R5_L
    7024 16D744             JPF  push_data_R4_ret
                            ;CLC
    7027 0C15               ROR  R4_H
    7029 0C14               ROR  R4_L
    702B 0A16               DEC  R5_L
    702D 182270             JMP  _c_rshift_1
                e_rshift    ;------------------------------------------------------------------
                
                            ; UM/MOD  ( ud u1 -- u2 u3 )   Divide ud by u1, giving the quotient u3 and the remainder u2.
    7030 5570               DW   e_umsmod
    7032 06756D             DB   6,"um/mod"
    7035 2F6D6F 
    7038 64     
    7039 1E     c_umsmod    PHL
    703A 190E45             JSR  pop_data_R4
    703D 021814             LD   R6_L,R4_L
    7040 021915             LD   R6_H,R4_H
    7043 195945             JSR  pop_data_R5_R4
    7046 192441             JSR  div_u32u16
    7049 021618 _c_umsmod1  LD   R5_L,R6_L
    704C 021719             LD   R5_H,R6_H
    704F 19FD44             JSR  push_data_R5
    7052 18D744             JMP  push_data_R4_ret
                e_umsmod    ;------------------------------------------------------------------
                
                            ; SM/REM  ( d1 n1 -- n2 n3 )  Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2.
    7055 7470               DW   e_smsrem
    7057 06736D             DB   6,"sm/rem"
    705A 2F7265 
    705D 6D     
    705E 1E     c_smsrem    PHL
    705F 190E45             JSR  pop_data_R4
    7062 021814             LD   R6_L,R4_L
    7065 021915             LD   R6_H,R4_H
    7068 195945             JSR  pop_data_R5_R4
    706B 190A42             JSR  div_i32i16
    706E 193942             JSR  div_i32_crem
    7071 184970             JMP  _c_umsmod1
                e_smsrem    ;------------------------------------------------------------------
                
                            ; [CHAR]  ( -- char )  Place char, the value of the first character of name, on the stack.
    7074 8770               DW   e_brcharbr
    7076 865B63             DB   6+FL_IMMEDIATE,"[char]"
    7079 686172 
    707C 5D     
    707D 1E     c_brcharbr  PHL
    707E 19635E             JSR  c_char
    7081 190E45             JSR  pop_data_R4
    7084 18B04D             JMP  add_16bit_literal_ret
                e_brcharbr  ;------------------------------------------------------------------
                
                            ; FM/MOD  ( d1 n1 -- n2 n3 )  Divide d1 by n1, giving the floored quotient n3 and the remainder n2.
    7087 9370               DW   e_fmsrem
    7089 06666D             DB   6,"fm/mod"
    708C 2F6D6F 
    708F 64     
    7090 185E70 c_fmsrem    JMP  c_smsrem     ;re-use the code of SM/REM - it is not the same but similar
                e_fmsrem    ;------------------------------------------------------------------
                
                            ; 2VALUE  ( x1 x2 "<spaces>name" -- )
    7093 B770               DW   e_2value
    7095 063276             DB   6,"2value"
    7098 616C75 
    709B 65     
    709C 1E     c_2value    PHL
    709D 19B66F             JSR  c_create  ;VALUE is defined as ": VALUE CREATE , , DOES> 2@ ;"
    70A0 0301               LDA  #1        ;My4TH definition is ": VALUE CREATE 1 c, , , DOES> 1+ 2@ ;"
    70A2 19134E             JSR  emit_code ;emit a flag-byte that shows the TO word that only one 16-bit value can be stored here
    70A5 19F950             JSR  c_comma
    70A8 19F950             JSR  c_comma
    70AB 19606A             JSR  c_doesgt
    70AE 190E45             JSR  pop_data_R4
    70B1 19F93A             JSR  inc_r4
    70B4 182055             JMP  _c_2at_1
                e_2value    ;------------------------------------------------------------------
                
                            ; ACCEPT  ( c-addr +n1 -- +n2 )
    70B7 0671               DW   e_accept
    70B9 066163             DB   6,"accept"
    70BC 636570 
    70BF 74     
    70C0 1E     c_accept    PHL
    70C1 190E45             JSR  pop_data_R4
    70C4 19F93A             JSR  inc_r4
    70C7 011050             LD   R0,#80
    70CA 1515               TST  R4_H
    70CC 17D970             JNF  _c_acpt01
    70CF 0414               LDA  R4_L
    70D1 1110               SUB  R0
    70D3 16D970             JPF  _c_acpt01
    70D6 021014             LD   R0,R4_L
    70D9 011430 _c_acpt01   LD   R4_L,#<SYS_BUF
    70DC 0115FE             LD   R4_H,#>SYS_BUF
    70DF 011A00             LD   R7_L,#0
    70E2 193835             JSR  input_string
    70E5 010C30             LD   PTR_L,#<SYS_BUF
    70E8 010DFE             LD   PTR_H,#>SYS_BUF
    70EB 192C3C             JSR  strlen
    70EE 021810             LD   R6_L,R0
    70F1 011430             LD   R4_L,#<SYS_BUF
    70F4 0115FE             LD   R4_H,#>SYS_BUF
    70F7 192445             JSR  pop_data_R5
    70FA 19804E             JSR  memcpy_short
    70FD 021410             LD   R4_L,R0
    7100 011500             LD   R4_H,#0
    7103 19D744             JSR  push_data_R4_ret
                e_accept    ;------------------------------------------------------------------
                
                            ; ABORT"  Print a string and abort if flag is nonzero
    7106 1D71               DW   e_abortq
    7108 866162             DB   6+FL_IMMEDIATE,"abort",0x22
    710B 6F7274 
    710E 22     
    710F 159A   c_abortq    TST  STATE
    7111 165447             JPF  abort_restart  ;quit here if in interpreter mode
    7114 011A8B             LD   R7_L,#<abort_code
    7117 011B4F             LD   R7_H,#>abort_code
    711A 187553             JMP  _prstr_common            
                e_abortq    ;------------------------------------------------------------------
                
                            ; UNUSED  ( -- u )  u is the amount of space remaining in the region addressed by HERE
    711D 3571               DW   e_unused
    711F 06756E             DB   6,"unused"
    7122 757365 
    7125 64     
    7126 0300   c_unused    LDA  #<(HEAP_END+1)
    7128 2564               SU   CP_L
    712A 0614               STA  R4_L
    712C 03FD               LDA  #>(HEAP_END+1)
    712E 1165               SUB  CP_H
    7130 0615               STA  R4_H
    7132 18DB44             JMP  push_data_R4
                e_unused    ;------------------------------------------------------------------
                
                            ; FORGET
    7135 9471               DW   e_forget
    7137 06666F             DB   6,"forget"
    713A 726765 
    713D 74     
    713E 1E     c_forget    PHL
    713F 19224C             JSR  search_word_ex
    7142 16074A             JPF  Error_Word ;word not found
    7145 0415               LDA  R4_H
    7147 0B0E               ROL
    7149 17074A             JNF  Error_Word ;word not found (in RAM)
                _cforget    ;R4 = ptr to header (= memory barrier address, words at this and after this address will be deleted)
                            ;re-set the "HERE" ptr to this address
    714C 026414             LD   CP_L,R4_L
    714F 026515             LD   CP_H,R4_H
    7152 011366             LD   R3,#DICTA
                _c_forget1  ;do for all 8 dictionary pointers
    7155 020C13             LD   PTR_L,R3
    7158 010D80             LD   PTR_H,#>REGPAGE
                            ;load current dictionary pointer into R5 and compare with R4
    715B 19CE3A             JSR  lap_inc_ptr
    715E 0616               STA  R5_L
    7160 2514               SU   R4_L
    7162 05                 LAP
    7163 0617               STA  R5_H
    7165 1115               SUB  R4_H
    7167 178671             JNF  _c_forget2  ; jump if current pointer points to memory below the word that shall be deleted
                            ;delete the word, unchain it from the dictionary pointer list
    716A 19283B             JSR  ld_ptr_r5
    716D 19CE3A             JSR  lap_inc_ptr
    7170 0618               STA  R6_L
    7172 05                 LAP
    7173 0619               STA  R6_H
    7175 020C13             LD   PTR_L,R3
    7178 010D80             LD   PTR_H,#>REGPAGE
    717B 0418               LDA  R6_L
    717D 19D93A             JSR  sap_inc_ptr
    7180 0419               LDA  R6_H
    7182 07                 SAP
                            ;check this dictionary pointer again
    7183 185571             JMP  _c_forget1
                _c_forget2  ;next dictionary pointer
    7186 0913               INC  R3
    7188 0913               INC  R3
    718A 0376               LDA  #DICTA+2*8
    718C 1413               CMP  R3
    718E 175571             JNF  _c_forget1
                            ;now check also the BLOCK structure to be sure
    7191 18D572             JMP  _chk_bptr_1
                e_forget    ;------------------------------------------------------------------
                
                            ; DEFER!  ( xt xt-deferred -- )
    7194 AA71               DW   e_deferstor
    7196 066465             DB   6,"defer!"
    7199 666572 
    719C 21     
    719D 1E     c_deferstor PHL
    719E 195945 _c_defstor  JSR  pop_data_R5_R4 ; get ptr to deferred xt, and get ptr to new xt
    71A1 19283B             JSR  ld_ptr_r5
    71A4 19DA3A             JSR  inc_ptr
    71A7 184550             JMP  _c_store_2
                e_deferstor ;------------------------------------------------------------------
                
                            ; DEFER@  ( xt-deferred -- xt )
    71AA BD71               DW   e_deferld
    71AC 066465             DB   6,"defer@"
    71AF 666572 
    71B2 40     
    71B3 1E     c_deferld   PHL
    71B4 190E45 _c_deferld  JSR  pop_data_R4
    71B7 19F93A             JSR  inc_r4
    71BA 182C50             JMP  c_at_ldpret
                e_deferld   ;------------------------------------------------------------------
                
                            ; WITHIN  ( n low high -- flag )
    71BD EE71               DW   e_within
    71BF 067769             DB   6,"within"
    71C2 746869 
    71C5 6E     
    71C6 1E     c_within    PHL
                _cwithin_rts
                            ;implemented as " over - >r - r> u< "
    71C7 195945             JSR  pop_data_R5_R4
    71CA 19E171             JSR  _subR5R4
    71CD 19473B             JSR  psh_r5
    71D0 192445             JSR  pop_data_R5
    71D3 19E171             JSR  _subR5R4
    71D6 021416             LD   R4_L,R5_L
    71D9 0615               STA  R4_H
    71DB 19603B             JSR  pop_r5
    71DE 186250             JMP  _c_lthan_2
    71E1 0416   _subR5R4    LDA  R5_L
    71E3 2514               SU   R4_L
    71E5 0616               STA  R5_L
    71E7 0417               LDA  R5_H
    71E9 1115               SUB  R4_H
    71EB 0617               STA  R5_H
    71ED 1A                 RET
                e_within    ;------------------------------------------------------------------
                
                            ; MARKER  ( -- )
    71EE 2F72               DW   e_marker
    71F0 066D61             DB   6,"marker"
    71F3 726B65 
    71F6 72     
    71F7 1E     c_marker    PHL
                            ;compile time
    71F8 190F4D             JSR  begin_add_new_word
    71FB 193E4E             JSR  ld_r4_cp
    71FE 19244D             JSR  add_word_entry_code
    7201 19AF4D             JSR  add_16bit_literal
    7204 0318               LDA  #0x18
    7206 010C0F             LD   PTR_L,#<_cmarker01
    7209 010D72             LD   PTR_H,#>_cmarker01
    720C 182E4D             JMP  add_JmpOrJsr_ret
                _cmarker01  ;word run time
                            ;find the beginning of the word in RAM
    720F 190E45             JSR  pop_data_R4
    7212 19213B             JSR  ld_ptr_r4
    7215 19EF3A _cmarker02  JSR  dec_ptr
    7218 05                 LAP
    7219 010560             AND  #0x60
    721C 0D05   
    721E 150E               TST
    7220 171572             JNF   _cmarker02
    7223 19EF3A             JSR  dec_ptr
    7226 19EF3A             JSR  dec_ptr
    7229 19AA49             JSR  ld_r4_ptr
                            ;R4 points now to the beginning of the word in memory (the name length byte)
    722C 184C71             JMP  _cforget
                e_marker    ;------------------------------------------------------------------
                
                            ; SOURCE  ( -- c-addr u )   c-addr is the address of, and u is the number of characters in, the input buffer.
                            ; Note: This is very special on My4TH. Because My4TH is really slow in addition, it internally never adds
                            ; an index to a base address. So IN contains always an address and not an offset. Because of this,
                            ; every buffer is assumed to begin at address 0x0000. Thus, when IN is assumed to contain an offset, and
                            ; the buffer address is 0x0000, adding IN to 0x0000 results in the real address of the next character
                            ; in the input buffer. Furthermore, the word SOURCE returns a virtual (and very large) size of the
                            ; buffer (which starts virtually at address 0x0000). Subtracting IN from the buffer size gives the
                            ; amount of unread characters in the input buffer.
                            ; Note 2: If code is loaded from a BLOCK, this function will not return the size of the block buffer but
                            ; the size of the line buffer where the currently executed line is stored in. This is because of speed
                            ; and memory optimisation, the code is loaded line-by-line from the EEPROM into a temporary buffer before
                            ; it is executed.
    722F 4D72               DW   e_source
    7231 06736F             DB   6,"source"
    7234 757263 
    7237 65     
    7238 1E     c_source    PHL
    7239 19C944             JSR  push_data_zero
    723C 19B849             JSR  ld_ptr_inptr
    723F 192C3C             JSR  strlen
    7242 0410               LDA  R0
    7244 19EE44             JSR  push_data_accu
    7247 19BF49             JSR  push_data_inptr
    724A 189950             JMP  _c_sum16
                e_source    ;------------------------------------------------------------------
                
                            ; REFILL  ( -- flag ) 
    724D 7172               DW   e_refill
    724F 067265             DB   6,"refill"
    7252 66696C 
    7255 6C     
    7256 1E     c_refill    PHL
    7257 19FC4F             JSR  test_blk
    725A 16B852             JPF  ret_false  ; can not refill other input sources than blocks
    725D 02148D             LD   R4_L,BLK_L
    7260 02158E             LD   R4_H,BLK_H
    7263 19F93A             JSR  inc_r4
    7266 193038             JSR  fblockToEepromAddr
    7269 16B852             JPF  ret_false
    726C 0992               INC  REFILL
    726E 188E50             JMP  ret_true
                e_refill    ;------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 7 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 8 characters
                ;------------------------------------------------------------------------------
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_block.asm]
                
                
                
                            ; BUFFER  ( u -- a-addr )  
    7271 E772               DW   e_buffer
    7273 066275             DB   6,"buffer"
    7276 666665 
    7279 72     
                c_buffer    ; "blk_alloc dup blk_struct cell+ @ = if drop else
                            ;  save-buffers blk_struct cell+ ! then blk_struct @"
    727A 1E                 PHL
    727B 199F72             JSR  _cbuf03
    727E 178872             JNF  _cbuf01
                _cbuf04     ;same block number
    7281 193E5D             JSR  c_drop
    7284 189672             JMP  _cbuf02
    7287 1E     _cbuf05     PHL  ;entry-point for shared code with BLOCK word
                _cbuf01     ;other block number
    7288 193462             JSR  c_savebuffers
    728B 190E45             JSR  pop_data_R4
    728E 027A14             LD   BLKSTR_BLK+0,R4_L
    7291 027B15             LD   BLKSTR_BLK+1,R4_H
    7294 04                 DB   0x04  ; "jump" over following PHL instruction
                _c_bufaddr  ;get pointer to buffer
    7295 1E                 PHL
    7296 021478 _cbuf02     LD   R4_L,BLKSTR_BUF+0
    7299 021579             LD   R4_H,BLKSTR_BUF+1
    729C 18D744             JMP  push_data_R4_ret
                _cbuf03     ;shared code with c_block
    729F 1E                 PHL
    72A0 19B572             JSR _c_blk_alloc
    72A3 190E45             JSR  pop_data_R4
    72A6 19DB44             JSR  push_data_R4
    72A9 0414               LDA  R4_L
    72AB 147A               CMP  BLKSTR_BLK+0
    72AD 17CA3A             JNF  rts_opc
    72B0 0415               LDA  R4_H
    72B2 147B               CMP  BLKSTR_BLK+1
    72B4 1F                 RTS  ;return with FLAG=1 if same block number
                
                _c_blk_alloc
                            ; "blk_struct @ 0= if here blk_struct ! 1024 allot then"
    72B5 1E                 PHL
    72B6 19D472             JSR  _c_chk_bptr
    72B9 1579               TST  BLKSTR_BUF+1
    72BB 17CA3A             JNF  rts_opc
    72BE 19C85F             JSR  c_here
    72C1 19BF4F             JSR  ld_R5_1024
    72C4 19FD44             JSR  push_data_R5
    72C7 19366A             JSR  c_allot  ;allocate memory, may throw an error message if no memory available
    72CA 190E45             JSR  pop_data_R4
    72CD 027814             LD   BLKSTR_BUF+0,R4_L
    72D0 027915             LD   BLKSTR_BUF+1,R4_H
    72D3 1F                 RTS
                
                _c_chk_bptr
                            ; check if buffer pointer is still valid
    72D4 1E                 PHL
                _chk_bptr_1
    72D5 199572             JSR  _c_bufaddr
    72D8 19C85F             JSR  c_here
    72DB 19EC52             JSR  c_ulessthan
    72DE 190E45             JSR  pop_data_R4
    72E1 1515               TST  R4_H
    72E3 169F62             JPF  _cinitblks  ; jump if false (buffer address is invalid)
    72E6 1F                 RTS
                
                e_buffer    ;------------------------------------------------------------------
                
                
                            ; UPDATE  ( -- )  Mark the current block buffer as modified
    72E7 F472               DW   e_update
    72E9 067570             DB   6,"update"
    72EC 646174 
    72EF 65     
                c_update    ; "true blk_struct cell+ cell+ !"
    72F0 017CFF             LD   BLKSTR_UPD,#0xFF
    72F3 1A                 RET
                e_update    ;------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_my4th.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for My4TH
                ;------------------------------------------------------------------------------
                
                ;#ifdef WORDS_LEN_2
                ;            ; ,> ( "hexbytestream" -- )  Compile machine code to currently compiled word
                ;            DW   e_mgt
                ;            DB   2+FL_IMMEDIATE,",>"
                ;c_mgt       PHL
                ;            JSR  ld_ptr_inptr
                ;_c_mgt_1    LAP
                ;            TST
                ;            JPF  _c_mgt_2
                ;            CMP  #0x20
                ;            JPF  _c_mgt_2
                ;            JSR  inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            ROL
                ;            ROL
                ;            ROL
                ;            ROL
                ;            STA  R0
                ;            JSR  lap_inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            OR   R0
                ;            JSR  emit_code
                ;            JMP  _c_mgt_1
                ;_c_mgt_2    JSR  ld_inptr_ptr
                ;            RTS
                ;e_mgt       ;------------------------------------------------------------------
                ;#endif
                
                ;#ifdef WORDS_LEN_3
                ;            ; >SY  Convert index number to system call address
                ;            DW   e_2system
                ;            DB   3,">sy"
                ;c_2system   PHL
                ;            JSR  pop_data_R4
                ;            LDA  #<tab_syscalls
                ;            CLC
                ;            ROL  R4_L
                ;            ADD  R4_L
                ;            STA  PTR_L
                ;            LD   PTR_H,#>tab_syscalls
                ;            JSR  lap_inc_ptr
                ;            STA  R4_L
                ;            LAP
                ;            STA  R4_H
                ;            JMP  push_data_R4_ret
                ;e_2system   ;------------------------------------------------------------------
                ;#endif
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                            ; RANDOM  ( n -- u )  Random number generator. The generated number u is in the range 0 .. n-1.
    72F4 1F73               DW   e_random
    72F6 067261             DB   6,"random"
    72F9 6E646F 
    72FC 6D     
    72FD 1E     c_random    PHL
    72FE 0214A4             LD   R4_L,RANDVAR+0
    7301 04A6               LDA  RANDVAR+2
    7303 0B0E               ROL
    7305 090F               INC  FLAG
    7307 21A4               RWL  RANDVAR+0
    7309 090F               INC  FLAG
    730B 0BA6               ROL  RANDVAR+2
    730D 031F               LDA  #31
    730F 24A5               AD   RANDVAR+1
    7311 06A5               STA  RANDVAR+1
    7313 0615               STA  R4_H
    7315 19DB44             JSR  push_data_R4
    7318 19305D             JSR  c_swap
    731B 19D259             JSR  c_mod16
    731E 1F                 RTS
                e_random    ;------------------------------------------------------------------
                
                
                
                
                
                
                            ; BOUNDS  ( addr u -- addr+u addr )
    731F 3273               DW   e_bounds
    7321 06626F             DB   6,"bounds"
    7324 756E64 
    7327 73     
    7328 1E     c_bounds    PHL
    7329 19175D             JSR  c_over
    732C 199850             JSR  c_sum16
    732F 18315D             JMP  _c_swap
                e_bounds      ;------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_mynor.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for MyNOR
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_bload.asm]
                ;------------------------------------------------------------------------------
                ;  Binary Driver Loader
                ;------------------------------------------------------------------------------
                ;
                ;  This module can load and relocate a binary driver image into RAM memory.
                ;
                ;  The binary driver image must begin with this header:
                ;
                ;    1. byte :  ID 0x1B
                ;    2. byte :  reserved, must be 0
                ;    3. byte :  file size, bits 0-7
                ;    4. byte :  file size, bits 8-15
                ;    5. byte :  module compile address, bits 0-7
                ;    6. byte :  module compile address, bits 8-15
                ;    7. byte :  offset to the startup function, bits 0-7   (can be 0 if not used)
                ;    8. byte :  offset to the startup function, bits 8-15  (can be 0 if not used)
                ;    9. byte :  size of the following data section, bits 0-7
                ;   10. byte :  size of the following data section, bits 8-15
                ;
                ;  This module relocates all address it finds in the code section.
                ;  Data pointers must be written as a pair of " LD PTR_L,# / LD PTR_H,# ",
                ;  otherwise they won't be recognized.
                ;
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_edit.asm]
                
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words.asm]
    7332 000000   DB 0,0,0 ;end-marker
                
                dictionary_7:
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words_basis.asm]
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 2 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 3 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 4 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 5 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 6 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 7 characters
                ;------------------------------------------------------------------------------
                
                
                            ; EXECUTE ( xt -- )  Execute the token on stack
    7335 4C73               DW   e_execute
    7337 076578             DB   7,"execute"
    733A 656375 
    733D 7465   
    733F 1E     c_execute   PHL
    7340 190E45             JSR  pop_data_R4
    7343 027E14             LD   JSRSPACE+1,R4_L
    7346 027F15             LD   JSRSPACE+2,R4_H
    7349 187D80             JMP  JSRSPACE_JMP
                e_execute   ;------------------------------------------------------------------
                
                            ; LITERAL  ( x -- )
    734C 5D73               DW   e_literal
    734E 876C69             DB   7+FL_IMMEDIATE,"literal"
    7351 746572 
    7354 616C   
    7356 1E     c_literal   PHL
    7357 190E45             JSR  pop_data_R4
    735A 18B04D             JMP  add_16bit_literal_ret
                e_literal   ;------------------------------------------------------------------
                
                            ; ALIGNED  ( addr -- a-addr )
    735D 6873               DW   e_aligned
    735F 07616C             DB   7,"aligned"
    7362 69676E 
    7365 6564   
    7367 1A     c_aligned   RET
                e_aligned   ;------------------------------------------------------------------
                
                            ; ENDCASE  ( x --  )
    7368 8E73               DW   e_endcase
    736A 87656E             DB   7+FL_IMMEDIATE,"endcase"
    736D 646361 
    7370 7365   
    7372 1E     c_endcase   PHL
    7373 011A0E             LD   R7_L,#<pop_data_R4
    7376 011B45             LD   R7_H,#>pop_data_R4
    7379 193B4D             JSR  emit_jsr   ; insert "JSR pop_data_R4" to remove the case selector from stack
    737C 197344             JSR  ccfs_pop   ; resolve the JMP target address in the CASE word
    737F 19F93A             JSR  inc_r4
    7382 19213B _c_endcase1 JSR  ld_ptr_r4
    7385 0464   _c_endcase2 LDA  CP_L
    7387 19D93A             JSR  sap_inc_ptr
    738A 0465               LDA  CP_H
    738C 07                 SAP
    738D 1F                 RTS
                e_endcase   ;------------------------------------------------------------------
                
                            ; DECIMAL  ( -- ) 
    738E 9E73               DW   e_decimal
    7390 076465             DB   7,"decimal"
    7393 63696D 
    7396 616C   
    7398 01890A c_decimal   LD   BASE,#10
    739B 187A5B             JMP  _c_hex1
                e_decimal   ;------------------------------------------------------------------
                
                            ; DNEGATE  ( d1 -- d2 )
    739E AF73               DW   e_dnegate
    73A0 07646E             DB   7,"dnegate"
    73A3 656761 
    73A6 7465   
    73A8 1E     c_dnegate   PHL
    73A9 192445             JSR  pop_data_R5
    73AC 18935E             JMP  _c_dabs1
                e_dnegate   ;------------------------------------------------------------------
                
                            ; >NUMBER  ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
    73AF 0E74               DW   e_tonumber
    73B1 073E6E             DB   7,">number"
    73B4 756D62 
    73B7 6572   
    73B9 1E     c_tonumber  PHL
    73BA 195945             JSR  pop_data_R5_R4
    73BD 021116             LD   R1,R5_L
    73C0 19213B             JSR  ld_ptr_r4  ; ptr to string
    73C3 195945             JSR  pop_data_R5_R4 ; R4/R5 = double number accu
    73C6 1511   _c_tonmb01  TST  R1
    73C8 16FC73             JPF  _c_tonmb02  ; end of conversion
    73CB 05                 LAP
    73CC 19C34B             JSR  char2binnum
    73CF 17FC73             JNF  _c_tonmb02  ; end of conversion
    73D2 1B0E               PSH
    73D4 0A11               DEC  R1
    73D6 19DA3A             JSR  inc_ptr
    73D9 021889             LD   R6_L,BASE
    73DC 011900             LD   R6_H,#0
    73DF 1B11               PSH  R1
    73E1 194442             JSR  mul32u
    73E4 1C11               POP  R1
    73E6 1C0E               POP
    73E8 2414               AD   R4_L
    73EA 0614               STA  R4_L
    73EC 17C673             JNF  _c_tonmb01
    73EF 0915               INC  R4_H
    73F1 1515               TST  R4_H
    73F3 17C673             JNF  _c_tonmb01
    73F6 19033B             JSR  inc_r5
    73F9 18C673             JMP  _c_tonmb01
    73FC 19DB44 _c_tonmb02  JSR  push_data_R4
    73FF 19FD44             JSR  push_data_R5
    7402 19AA49             JSR  ld_r4_ptr
    7405 021611             LD   R5_L,R1
    7408 011700             LD   R5_H,#0
    740B 18F644             JMP  push_data_R4_R5_ret
                e_tonumber  ;------------------------------------------------------------------
                
                            ; RECURSE  ( -- )
    740E 2274               DW   e_recurse
    7410 877265             DB   7+FL_IMMEDIATE,"recurse"
    7413 637572 
    7416 7365   
    7418 1E     c_recurse   PHL
    7419 020C9C             LD   PTR_L,CW_L
    741C 020D9D             LD   PTR_H,CW_H
    741F 18CE74 _c_recur1   JMP  add_word_call_ret
                e_recurse   ;------------------------------------------------------------------
                
                            ; :NONAME
    7422 3D74               DW   e_cnoname
    7424 873A6E             DB   7+FL_IMMEDIATE,":noname"
    7427 6F6E61 
    742A 6D65   
    742C 1E     c_cnoname   PHL
    742D 159A               TST  STATE
    742F 17234A             JNF  Error_Syntax
    7432 099A               INC  STATE
    7434 193E4E             JSR  ld_r4_cp
    7437 19244D             JSR  add_word_entry_code
    743A 18D744             JMP  push_data_R4_ret
                e_cnoname   ;------------------------------------------------------------------
                
                            ; BUFFER:
    743D 4E74               DW   e_cbufferc
    743F 076275             DB   7,"buffer:"
    7442 666665 
    7445 723A   
    7447 1E     c_bufferc   PHL
    7448 19B66F             JSR  c_create
    744B 18376A             JMP  _c_allot
                e_cbufferc ;------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 8 characters
                ;------------------------------------------------------------------------------
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_block.asm]
                
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_my4th.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for My4TH
                ;------------------------------------------------------------------------------
                
                ;#ifdef WORDS_LEN_2
                ;            ; ,> ( "hexbytestream" -- )  Compile machine code to currently compiled word
                ;            DW   e_mgt
                ;            DB   2+FL_IMMEDIATE,",>"
                ;c_mgt       PHL
                ;            JSR  ld_ptr_inptr
                ;_c_mgt_1    LAP
                ;            TST
                ;            JPF  _c_mgt_2
                ;            CMP  #0x20
                ;            JPF  _c_mgt_2
                ;            JSR  inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            ROL
                ;            ROL
                ;            ROL
                ;            ROL
                ;            STA  R0
                ;            JSR  lap_inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            OR   R0
                ;            JSR  emit_code
                ;            JMP  _c_mgt_1
                ;_c_mgt_2    JSR  ld_inptr_ptr
                ;            RTS
                ;e_mgt       ;------------------------------------------------------------------
                ;#endif
                
                ;#ifdef WORDS_LEN_3
                ;            ; >SY  Convert index number to system call address
                ;            DW   e_2system
                ;            DB   3,">sy"
                ;c_2system   PHL
                ;            JSR  pop_data_R4
                ;            LDA  #<tab_syscalls
                ;            CLC
                ;            ROL  R4_L
                ;            ADD  R4_L
                ;            STA  PTR_L
                ;            LD   PTR_H,#>tab_syscalls
                ;            JSR  lap_inc_ptr
                ;            STA  R4_L
                ;            LAP
                ;            STA  R4_H
                ;            JMP  push_data_R4_ret
                ;e_2system   ;------------------------------------------------------------------
                ;#endif
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_mynor.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for MyNOR
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_bload.asm]
                ;------------------------------------------------------------------------------
                ;  Binary Driver Loader
                ;------------------------------------------------------------------------------
                ;
                ;  This module can load and relocate a binary driver image into RAM memory.
                ;
                ;  The binary driver image must begin with this header:
                ;
                ;    1. byte :  ID 0x1B
                ;    2. byte :  reserved, must be 0
                ;    3. byte :  file size, bits 0-7
                ;    4. byte :  file size, bits 8-15
                ;    5. byte :  module compile address, bits 0-7
                ;    6. byte :  module compile address, bits 8-15
                ;    7. byte :  offset to the startup function, bits 0-7   (can be 0 if not used)
                ;    8. byte :  offset to the startup function, bits 8-15  (can be 0 if not used)
                ;    9. byte :  size of the following data section, bits 0-7
                ;   10. byte :  size of the following data section, bits 8-15
                ;
                ;  This module relocates all address it finds in the code section.
                ;  Data pointers must be written as a pair of " LD PTR_L,# / LD PTR_H,# ",
                ;  otherwise they won't be recognized.
                ;
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_edit.asm]
                
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words.asm]
    744E 000000   DB 0,0,0 ;end-marker
                
                dictionary_8:
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words_basis.asm]
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 2 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 3 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 4 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 5 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 6 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 7 characters
                ;------------------------------------------------------------------------------
                
                
                ;------------------------------------------------------------------------------
                ;  Words with names that have a length of 8 characters
                ;------------------------------------------------------------------------------
                
                
                            ;CONSTANT ( x -- )  Creates a new 16-bit constant
    7451 6774               DW   e_constant
    7453 08636F             DB   8,"constant"
    7456 6E7374 
    7459 616E74 
    745C 1E     c_constant  PHL
    745D 190F4D             JSR  begin_add_new_word
    7460 190E45             JSR  pop_data_R4
    7463 19674D             JSR  write_constant_body
    7466 1F                 RTS
                e_constant  ;------------------------------------------------------------------
                
                            ; VARIABLE  Creates a new variable with one 16-bit cell
    7467 8174               DW   e_variable
    7469 087661             DB   8,"variable"
    746C 726961 
    746F 626C65 
    7472 1E     c_variable  PHL
    7473 190F4D             JSR  begin_add_new_word
    7476 19534D             JSR  write_variable_body
    7479 0300               LDA  #0
    747B 19134E _c_var_2em  JSR  emit_code
    747E 18274D             JMP  emit_code_ret
                e_variable  ;------------------------------------------------------------------
                
                            ; 2LITERAL  ( x1 x2 -- )  Run-time: Place cell pair x1 x2 on the stack.
    7481 9774               DW   e_2literal
    7483 88326C             DB   8+FL_IMMEDIATE,"2literal"
    7486 697465 
    7489 72616C 
    748C 1E     c_2literal  PHL
    748D 19305D             JSR  c_swap
    7490 195673             JSR  c_literal
    7493 195673             JSR  c_literal
    7496 1F                 RTS
                e_2literal  ;------------------------------------------------------------------
                
                            ; POSTPONE
    7497 D374               DW   e_postpone
    7499 88706F             DB   8+FL_IMMEDIATE,"postpone"
    749C 737470 
    749F 6F6E65 
    74A2 1E     c_postpone  PHL
    74A3 19224C             JSR  search_word_ex
    74A6 16074A             JPF  Error_Word ;word not found
    74A9 0B12               ROL  R2
    74AB 16CE74             JPF  add_word_call_ret  ;add direct call to immediate word
                            ;append call to insert JSR to the word later
    74AE 19114E             JSR  emit_code_ldi
    74B1 030C               LDA  #PTR_L
    74B3 19134E             JSR  emit_code
    74B6 040C               LDA  PTR_L
    74B8 19134E             JSR  emit_code
    74BB 19114E             JSR  emit_code_ldi
    74BE 030D               LDA  #PTR_H
    74C0 19134E             JSR  emit_code
    74C3 040D               LDA  PTR_H
    74C5 19134E             JSR  emit_code
    74C8 010C2B             LD   PTR_L,#<add_word_call
    74CB 010D4D             LD   PTR_H,#>add_word_call
                add_word_call_ret:
    74CE 0319               LDA  #0x19
    74D0 182E4D             JMP  add_JmpOrJsr_ret
                e_postpone  ;------------------------------------------------------------------
                
                            ; COMPILE,
    74D3 E874               DW   e_compilec
    74D5 08636F             DB   8,"compile,"
    74D8 6D7069 
    74DB 6C652C 
    74DE 1E     c_compilec  PHL
    74DF 190E45             JSR  pop_data_R4
    74E2 19213B             JSR  ld_ptr_r4
    74E5 18CE74             JMP  add_word_call_ret
                e_compilec  ;------------------------------------------------------------------
                
                            ; EVALUATE  ( i*x c-addr u -- j*x )
    74E8 2A75               DW   e_evaluate
    74EA 086576             DB   8,"evaluate"
    74ED 616C75 
    74F0 617465 
    74F3 1E     c_evaluate  PHL
    74F4 195945             JSR  pop_data_R5_R4
                            ;R5 = strlen
                            ;R4 = ptr to the source string
                            ;now: copy string, terminate it with a zero
    74F7 021816             LD   R6_L,R5_L
    74FA 011600             LD   R5_L,#<EVALUATE_BUF
    74FD 0117FF             LD   R5_H,#>EVALUATE_BUF
    7500 19804E             JSR  memcpy_short
    7503 19283B             JSR  ld_ptr_r5
    7506 0300               LDA  #0
    7508 07                 SAP
                            ;evaluate the zero-terminated string
    7509 010C8D             LD   PTR_L,#<BLK_L
    750C 19CB49             JSR  push_zpvar
    750F 018D00             LD   BLK_L,#0
    7512 018E00             LD   BLK_H,#0
    7515 19C849             JSR  push_inptr
    7518 01A100             LD   INPTR_L,#<EVALUATE_BUF
    751B 01A2FF             LD   INPTR_H,#>EVALUATE_BUF
    751E 19BD48             JSR  evaluate
    7521 19DE49             JSR  pop_inptr
    7524 010C8D             LD   PTR_L,#<BLK_L
    7527 18E249             JMP  pop_zpvar_rts
                e_evaluate  ;------------------------------------------------------------------
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_block.asm]
                
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_my4th.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for My4TH
                ;------------------------------------------------------------------------------
                
                ;#ifdef WORDS_LEN_2
                ;            ; ,> ( "hexbytestream" -- )  Compile machine code to currently compiled word
                ;            DW   e_mgt
                ;            DB   2+FL_IMMEDIATE,",>"
                ;c_mgt       PHL
                ;            JSR  ld_ptr_inptr
                ;_c_mgt_1    LAP
                ;            TST
                ;            JPF  _c_mgt_2
                ;            CMP  #0x20
                ;            JPF  _c_mgt_2
                ;            JSR  inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            ROL
                ;            ROL
                ;            ROL
                ;            ROL
                ;            STA  R0
                ;            JSR  lap_inc_ptr
                ;            JSR  is_hexchar
                ;            JPF  Error_Value
                ;            OR   R0
                ;            JSR  emit_code
                ;            JMP  _c_mgt_1
                ;_c_mgt_2    JSR  ld_inptr_ptr
                ;            RTS
                ;e_mgt       ;------------------------------------------------------------------
                ;#endif
                
                ;#ifdef WORDS_LEN_3
                ;            ; >SY  Convert index number to system call address
                ;            DW   e_2system
                ;            DB   3,">sy"
                ;c_2system   PHL
                ;            JSR  pop_data_R4
                ;            LDA  #<tab_syscalls
                ;            CLC
                ;            ROL  R4_L
                ;            ADD  R4_L
                ;            STA  PTR_L
                ;            LD   PTR_H,#>tab_syscalls
                ;            JSR  lap_inc_ptr
                ;            STA  R4_L
                ;            LAP
                ;            STA  R4_H
                ;            JMP  push_data_R4_ret
                ;e_2system   ;------------------------------------------------------------------
                ;#endif
                
                
                
                
                
                            ; I2C-STOP  ( -- )  send a stop condition
    752A 3875               DW   e_i2cstop
    752C 086932             DB   8,"i2c-stop"
    752F 632D73 
    7532 746F70 
    7535 18DE2D c_i2cstop   JMP  i2c_stop
                e_i2cstop   ;------------------------------------------------------------------
                
                            ; I2C-SEND  ( byte -- ack )  send a byte
    7538 5375               DW   e_i2csend
    753A 086932             DB   8,"i2c-send"
    753D 632D73 
    7540 656E64 
    7543 1E     c_i2csend   PHL
    7544 190E45             JSR  pop_data_R4
    7547 021114             LD   R1,R4_L
    754A 19042E             JSR  i2c_send
    754D 090F   _ci2csnd01  INC  FLAG
    754F 19BD44             JSR  push_flag
    7552 1F                 RTS
                e_i2csend   ;------------------------------------------------------------------
                
                            ; I2C-RECV  ( ack -- byte )  receive a byte  (ack is usually 0 and must be 1 for the very last byte)
    7553 6C75               DW   e_i2crecv
    7555 086932             DB   8,"i2c-recv"
    7558 632D72 
    755B 656376 
    755E 1E     c_i2crecv   PHL
    755F 190E45             JSR  pop_data_R4
    7562 021114             LD   R1,R4_L
    7565 192E2E             JSR  i2c_recv
    7568 19EE44             JSR  push_data_accu
    756B 1F                 RTS
                e_i2crecv   ;------------------------------------------------------------------
                
                
                
                
                
                            ; TERMINAL
    756C 9275               DW   e_terminal
    756E 087465             DB   8,"terminal"
    7571 726D69 
    7574 6E616C 
    7577 015400 c_terminal  LD   VECT_OUTPUT+2,#0 ;set standard vector
    757A 015700             LD   VECT_INPUT+2,#0  ;set standard vector
    757D 153A               TST  LIB_LCDOUT
    757F 16CD3A             JPF  ret_opc
    7582 1E                 PHL
    7583 199732             JSR  display_clear
                            PRINT text_useterm
    7586 198633           JSR  printstrm
    7589 8A               DB   <text_useterm
    758A 79               DB   >text_useterm
    758B 193A2F             JSR  lcd_disable
    758E 198339             JSR  keyboard_term
    7591 1F                 RTS
                e_terminal  ;------------------------------------------------------------------
                
                
                
                
                
                
                
                
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_mynor.asm]
                ;------------------------------------------------------------------------------
                ;  Words with special functions for MyNOR
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_bload.asm]
                ;------------------------------------------------------------------------------
                ;  Binary Driver Loader
                ;------------------------------------------------------------------------------
                ;
                ;  This module can load and relocate a binary driver image into RAM memory.
                ;
                ;  The binary driver image must begin with this header:
                ;
                ;    1. byte :  ID 0x1B
                ;    2. byte :  reserved, must be 0
                ;    3. byte :  file size, bits 0-7
                ;    4. byte :  file size, bits 8-15
                ;    5. byte :  module compile address, bits 0-7
                ;    6. byte :  module compile address, bits 8-15
                ;    7. byte :  offset to the startup function, bits 0-7   (can be 0 if not used)
                ;    8. byte :  offset to the startup function, bits 8-15  (can be 0 if not used)
                ;    9. byte :  size of the following data section, bits 0-7
                ;   10. byte :  size of the following data section, bits 8-15
                ;
                ;  This module relocates all address it finds in the code section.
                ;  Data pointers must be written as a pair of " LD PTR_L,# / LD PTR_H,# ",
                ;  otherwise they won't be recognized.
                ;
                ;------------------------------------------------------------------------------
                
                ;[File: forth_allwords.asm]
                ;[File: forth_words_edit.asm]
                
                ;[File: forth_allwords.asm]
                
                ;[File: forth_words.asm]
    7592 000000   DB 0,0,0 ;end-marker
                
                ;[File: my4th-rom_8MHz.asm]
                reset_entry:
                
                          ;initialize stack and output port first
    7595 010700           LD   SP,#0
    7598 011CFF           LD   OUTP,#0xFF  ; TXD = 1, SDA = 1, SCL = 1
    759B 261C             OUT  OUTP
                
                          ;test mode: blink a LED connected to TXD if configured by user
    759D 19CC75           JSR  test_and_blink_led
                
                          ;initialize variables
    75A0 191E46           JSR  init_vectors
    75A3 013A00           LD   LIB_LCDOUT,#0
                
                          ;initialize the local console (LCD+keyboard or terminal via RS232)
    75A6 19B275           JSR  init_console
                
                          ;initialize the system
    75A9 19902D           JSR  i2c_init
    75AC 19EB36           JSR  eeprom_init
                
                          ;start forth
    75AF 18A746           JMP  forth_start
                
                init_console:
    75B2 1E               PHL
                          ;Initialize the keyboard (if any is present). Must be initialized before the LCD gets initialized.
    75B3 19C275           JSR  terminal_init
    75B6 195C39           JSR  keyboard_init
                          ;initialize LCD (if any is present) 
    75B9 1534             TST  LIB_BIGKEYB
    75BB 16C175           JPF  _aenokeyb
    75BE 19A12E           JSR  lcd_init
    75C1 1F     _aenokeyb RTS
                
                terminal_init:
    75C2 013A00           LD   LIB_LCDOUT,#0
    75C5 013750           LD   LIB_DISPMAXX,#80
    75C8 013818           LD   LIB_DISPMAXY,#24
    75CB 1A               RET
                
                test_and_blink_led:
                          ;check if jumper wire is installed between SCL and RXD
    75CC 1D               IN
    75CD 0C0E             ROR
    75CF 17CD3A           JNF  ret_opc
    75D2 03FB             LDA  #0xFB
    75D4 260E             OUT
    75D6 1D               IN
    75D7 0C0E             ROR
    75D9 16CD3A           JPF  ret_opc
    75DC 261C             OUT  OUTP
    75DE 1D               IN
    75DF 0C0E             ROR
    75E1 17CD3A           JNF  ret_opc
                          ;blink the LED
    75E4 0300             LDA  #0
    75E6 011171           LD   R1,#0x71
    75E9 01129E           LD   R2,#0x9E
    75EC 011007 _tabl2    LD   R0,#7
    75EF 01133B           LD   R3,#59
    75F2 010501           AND  #1
    75F5 0D05   
    75F7 2411   _tabl1    AD   R1
    75F9 2412             AD   R2
    75FB 0A13             DEC  R3
    75FD 1513             TST  R3
    75FF 17F775           JNF  _tabl1
    7602 20F775           JLP  _tabl1
    7605 0105FE           OR   #0xFE
    7608 0E05   
    760A 260E             OUT
    760C 18EC75           JMP  _tabl2
                


Segment Table:
**************
Segment Name                 Startaddr  Endaddr     Size  Type
=========================================================================
_program                          2D00     760E     490F  CODE  fixed
delay_functions                   7670     7680       11  CODE  fixed
uart_functions                    7690     76FA       6B  CODE  fixed
transfer_functions                7700     77D6       D7  CODE  fixed
_strings                          7800     7A26      227  CODE  fixed
aligned_tables                    7AE0     7AFF       20  CODE  fixed
@(0)aligned_tables                7B00     7BD2       D3  CODE  fixed
@(1)aligned_tables                7BE0     7BFF       20  CODE  fixed
@(2)aligned_tables                7C00     7CAE       AF  CODE  fixed
@(3)aligned_tables                7CC0     7CE3       24  CODE  fixed
@(4)aligned_tables                7D00     7D57       58  CODE  fixed
@(5)aligned_tables                7D60     7D7F       20  CODE  fixed
@(6)aligned_tables                7D80     7DDF       60  CODE  fixed
@(7)aligned_tables                7DE0     7DF2       13  CODE  fixed
@(8)aligned_tables                7DFF     7DFF        1  CODE  fixed
@(9)aligned_tables                7E00     7FFF      200  CODE  fixed
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_zeropage                           20       A9       8A  DATA  fixed
_zpbinmod                           E0       FF       20  DATA  fixed
_zeropage_end                      100      100        0  DATA  fixed
_stack                            8100     8100        0  DATA  fixed
_ram                              8200     83DA      1DB  DATA  fixed
forth_program                     8400     8400        0  DATA  fixed
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

No errors found.
